---
title: Kernel and Applications
keywords: 
tags: [Kernel Applications]
sidebar: kratos_for_developers
summary: 
---

## Overview

Kratos is designed as a framework for building multi-disciplinary finite element programs. Generality in design and implementation is the first requirement. Flexibility and extensibility are another key points in this design, enabling the developers to implement very different formulations and algorithms involving in the solution of multi-disciplinary problems. Kratos as a library must provide a good level of reusability in its provided tools. The key point here is to help users develop easily and fastly their own finite element code using generic components provided by Kratos, or any other applications. Important requirements are good performance and memory efficiency. This features are necessary for enabling applications implemented using Kratos, to deal with industrial multi-disciplinary problems. Finally it has to provide different levels of users' (LINK to who may use kratos) contributions to the Kratos system, and match their requirements and difficulties in the way they extend it. Developers may want to just make a plug-in extension, create an application over it, or using IO scripts to make Kratos perform a certain algorithm. Experts of different fields are given a unique framework to work on in order to create multi-disciplinary finite element applications.

An object-oriented structure has been designed to maximize the reusability and extensibility of the code. This structure is based on finite element methodology and many objects are designed to represent the basic finite element concepts. In this way the structure becomes easily understandable for developers with a finite element method background. In this design Vector, Matrix, and Quadrature representing the basic numerical concepts. Node, Element, Condition, and Dof are defined directly form finite element concepts. Model, Mesh, and Properties are from the practical methodology used in finite element modeling complemented by ModelPart, and SpatialContainer, for organizing better all data necessary for analysis. IO, LinearSolver, Process, and Strategy represent the different steps of a finite element program flow. Finally Kernel and Application are defined for library management and its interface definition.

[image](http://kratos-wiki.cimne.upc.edu/images/5/59/ObjectsKratosintro.jpg)

Kratos uses a multi-layer approach in its design which reduces the dependency between different parts of program. It helps in maintenance of the code and also helps developers in understanding the code. These layers are defined in a way such as each user has to work in the smallest number of layers as possible. In this way the amount of code that each users has to be familiar with is minimized and the chance of conflict between users of different categories is reduced. The implementation difficulties needed for each layer is also tuned for the knowledge of users working in it. For example the finite element layer uses only basic to average features of C++ programming but the main developer layer use advanced language features in order to provide desired performance.

[image](http://kratos-wiki.cimne.upc.edu/images/2/20/LayersKratosintro.jpg)

## Basic Tools

Different reusable tools have been implemented to help developers in writing their applications in Kratos. Several geometries and different quadrature methods are provided and their performances are optimized. Their flexible design and general interface make them suitable for use in different applications. Their optimized performance make them appropriate not only for academic applications but also for real industrial simulations. An extensible structure for linear solvers has been designed and different common solvers have been implemented. In this design the solver encapsulates only the solving algorithms and all operations over vectors and matrices are encapsulated in space classes. In this way solvers become independent of the type of mathematical containers and can be used to solve completely different types of equations systems like symmetric, skyline, etc. This structure also allows highly optimized solvers (for just one type of matrices or vectors) to be implemented without any problem.

## Variable Base Interface

A new variable base interface has been designed and implemented. All information about a concept or variable to be passed through this interface is encapsulated in the Variable class. The information about components of a variable also is encapsulated in the VariableComponent class which gives an additional flexibility to this interface. This interface is used at different levels of abstraction and proved to be very clear, flexible, and extensible. Variable provides the type of data statically and objects can use it to configure their operations for a given type of data via template implementation. This type information also prevents the use of variables in procedures that cannot handle their type of data. Each variable has a unique key which can be used as the reference key in data structures. The name of variable as an string helps routines like IO to read and write them without requiring additional parameters. Finally it provides a zero value which can be used for initializing data independent of its type in generic algorithms. Beside this information, variable provides different methods for raw memory manipulations. These methods are excellent tools for low level generic programming, specially for writing heterogeneous containers. This interface has been used successfully in different parts of Kratos. Its flexibility and extendibility is demonstrated in practice and its evident contribution to readability of the code is shown. This interface played a great role in uniforming different concepts coming from different area of analysis.

## Data Structure

New heterogeneous containers have been implemented in order to hold different types of data without any modifications. The DataValueContainer can be used to store variables of any type without even explicitly defining the list of them. This container is very flexible but uses a search mechanism to retrieve given variable's data. The VariablesListContainer only stores the variables defined in its variables list which can be have any type but its advantage is its fast indirection mechanism for finding the variables data. In Kratos these two containers are used alternatively in places where performance or flexibility are more important. Being able to store even the list of neighbor Nodes or Elements shows their flexibility in practice. An entity base data structure has been developed in Kratos. This approach gives more freedom in partitioning the domain or in creating and removing Nodes and Elements, for example in adaptive meshing. Several levels of abstraction are provided to help users group model and data information in different ways. In Kratos the Model contains the whole model, divided to different ModelParts. Each model part can have different Meshes which hold a complete set of entities in Kratos. These objects are effectively used for separating domain information or sending a single part to some process.

## Finite Element Implementation

The Element and Condition classes are designed as the extension points of Kratos. Their generic interfaces provide all information necessary for calculating their local components and also are flexible enough for handling new arguments in the future. Several processes and strategies has been developed to handle standard procedures in finite element programming. These components increase the reusability of the code and decrease the effort needed to implement new finite element application using Kratos. Some experimental work has been done to handle elemental expression using a higher level of abstraction. In this way elemental expressions can be written in C++ but with a meta language very similar to mathematical notations and then can be compiled with the rest of the code using the C++ compiler. These expressions have been successfully tested and their performance is comparable to manually implemented codes.Finally the Formulation is designed to handle nodal, edge based, or even elemental formulations in different forms of implementations. However these capabilities have not been implemented yet due to the lack of interest from developers.

## Input-Output

A flexible and extensible IO module for finite element programs has been developed. It can handle new concepts very easily while Kratos automatically adds variables to its components and IO uses these components as its list of concepts. Therefore any application built with Kratos can use IO for reading and writing its own concepts without making any change to it. However, more effort is required to extend this IO system to handle new types of data. This IO is multi-format. It can support new formats just by adding a new IO derived class an without changing any other part of IO. For example a binary format IO can be added using this feature. An interpreter is also implemented to handle Kratos data files. Its format is relatively intuitive and similar to Python scripts. The major interpreting task is given to the Python interpreter. This flexible interpreter with its object-oriented high level language can be used to implement and execute new algorithms using Kratos. In this way the implementation and maintenance cost of a new sophisticated interpreter is eliminated.
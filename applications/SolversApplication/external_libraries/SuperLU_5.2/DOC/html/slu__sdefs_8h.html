<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SuperLU: SRC/slu_sdefs.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SuperLU
   &#160;<span id="projectnumber">5.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_1e771ff450ae847412a8c28572c155bb.html">SRC</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">slu_sdefs.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for real operations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;limits.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="slu__Cnames_8h_source.html">slu_Cnames.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="supermatrix_8h_source.html">supermatrix.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="slu__util_8h_source.html">slu_util.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for slu_sdefs.h:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h__incl.png" border="0" usemap="#SRC_2slu__sdefs_8h" alt=""/></div>
<map name="SRC_2slu__sdefs_8h" id="SRC_2slu__sdefs_8h">
<area shape="rect" id="node8" href="slu__Cnames_8h.html" title="Macros defining how C routines will be called. " alt="" coords="521,80,628,107"/><area shape="rect" id="node9" href="supermatrix_8h.html" title="Defines matrix types. " alt="" coords="652,80,753,107"/><area shape="rect" id="node10" href="slu__util_8h.html" title="Utility header file. " alt="" coords="281,80,355,107"/><area shape="rect" id="node12" href="superlu__enum__consts_8h.html" title="enum constants header file " alt="" coords="269,155,428,181"/></map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h__dep__incl.png" border="0" usemap="#SRC_2slu__sdefs_8hdep" alt=""/></div>
<map name="SRC_2slu__sdefs_8hdep" id="SRC_2slu__sdefs_8hdep">
<area shape="rect" id="node2" href="ilu__scolumn__dfs_8c.html" title="Performs a symbolic factorization. " alt="" coords="5,80,164,107"/><area shape="rect" id="node3" href="ilu__scopy__to__ucol_8c.html" title="Copy a computed column of U to the compressed data structure and drop some small entries. " alt="" coords="189,80,360,107"/><area shape="rect" id="node4" href="ilu__sdrop__row_8c.html" title="Drop small rows from L. " alt="" coords="384,80,531,107"/><area shape="rect" id="node5" href="ilu__spanel__dfs_8c.html" title="Peforms a symbolic factorization on a panel of symbols and record the entries with maximum absolute v..." alt="" coords="555,80,703,107"/><area shape="rect" id="node6" href="ilu__spivotL_8c.html" title="Performs numerical pivoting. " alt="" coords="728,80,856,107"/><area shape="rect" id="node7" href="ilu__ssnode__dfs_8c.html" title="Determines the union of row structures of columns within the relaxed node. " alt="" coords="881,80,1033,107"/><area shape="rect" id="node8" href="scolumn__bmod_8c.html" title="performs numeric block updates " alt="" coords="1059,80,1212,107"/><area shape="rect" id="node9" href="scolumn__dfs_8c.html" title="Performs a symbolic factorization. " alt="" coords="1238,80,1377,107"/><area shape="rect" id="node10" href="scopy__to__ucol_8c.html" title="Copy a computed column of U to the compressed data structure. " alt="" coords="1402,80,1552,107"/><area shape="rect" id="node11" href="sdiagonal_8c.html" title="Auxiliary routines to work with diagonal elements. " alt="" coords="1577,80,1697,107"/><area shape="rect" id="node12" href="sgscon_8c.html" title="Estimates reciprocal of the condition number of a general matrix. " alt="" coords="1722,80,1829,107"/><area shape="rect" id="node13" href="sgsequ_8c.html" title="Computes row and column scalings. " alt="" coords="1854,80,1961,107"/><area shape="rect" id="node14" href="sgsisx_8c.html" title="Computes an approximate solutions of linear equations A*X=B or A&#39;*X=B. " alt="" coords="1987,80,2091,107"/><area shape="rect" id="node15" href="sgsitrf_8c.html" title="Computes an ILU factorization of a general sparse matrix. " alt="" coords="2115,80,2217,107"/><area shape="rect" id="node16" href="sgsrfs_8c.html" title="Improves computed solution to a system of inear equations. " alt="" coords="2242,80,2344,107"/><area shape="rect" id="node17" href="sgssv_8c.html" title="Solves the system of linear equations A*X=B. " alt="" coords="2369,80,2471,107"/><area shape="rect" id="node18" href="sgssvx_8c.html" title="Solves the system of linear equations A*X=B or A&#39;*X=B. " alt="" coords="2495,80,2603,107"/><area shape="rect" id="node19" href="sgstrf_8c.html" title="Computes an LU factorization of a general sparse matrix. " alt="" coords="2628,80,2727,107"/><area shape="rect" id="node20" href="sgstrs_8c.html" title="Solves a system using LU factorization. " alt="" coords="2751,80,2853,107"/><area shape="rect" id="node21" href="slangs_8c.html" title="Returns the value of the one norm. " alt="" coords="2879,80,2983,107"/><area shape="rect" id="node22" href="slaqgs_8c.html" title="Equlibrates a general sprase matrix. " alt="" coords="3007,80,3111,107"/><area shape="rect" id="node23" href="sldperm_8c.html" title="Finds a row permutation so that the matrix has large entries on the diagonal. " alt="" coords="3135,80,3245,107"/><area shape="rect" id="node24" href="smemory_8c.html" title="Memory details. " alt="" coords="3271,80,3391,107"/><area shape="rect" id="node25" href="spanel__bmod_8c.html" title="Performs numeric block updates. " alt="" coords="3415,80,3557,107"/><area shape="rect" id="node26" href="spanel__dfs_8c.html" title="Peforms a symbolic factorization on a panel of symbols. " alt="" coords="3582,80,3711,107"/><area shape="rect" id="node27" href="spivotgrowth_8c.html" title="Computes the reciprocal pivot growth factor. " alt="" coords="3735,80,3875,107"/><area shape="rect" id="node28" href="spivotL_8c.html" title="Performs numerical pivoting. " alt="" coords="3899,80,4007,107"/><area shape="rect" id="node29" href="spruneL_8c.html" title="Prunes the L&#45;structure. " alt="" coords="4032,80,4143,107"/><area shape="rect" id="node30" href="sreadhb_8c.html" title="Read a matrix stored in Harwell&#45;Boeing format. " alt="" coords="4168,80,4279,107"/><area shape="rect" id="node31" href="sreadrb_8c.html" title="Read a matrix stored in Rutherford&#45;Boeing format. " alt="" coords="4304,80,4413,107"/><area shape="rect" id="node32" href="sreadtriple_8c.html" title="Read a matrix stored in triplet (coordinate) format. " alt="" coords="4438,80,4564,107"/><area shape="rect" id="node33" href="ssnode__bmod_8c.html" title="Performs numeric block updates within the relaxed snode. " alt="" coords="4589,80,4736,107"/><area shape="rect" id="node34" href="ssnode__dfs_8c.html" title="Determines the union of row structures of columns within the relaxed node. " alt="" coords="4760,80,4893,107"/><area shape="rect" id="node35" href="ssp__blas2_8c.html" title="Sparse BLAS 2, using some dense BLAS 2 operations. " alt="" coords="4917,80,5043,107"/><area shape="rect" id="node36" href="ssp__blas3_8c.html" title="Sparse BLAS3, using some dense BLAS3 operations. " alt="" coords="5067,80,5192,107"/><area shape="rect" id="node37" href="sutil_8c.html" title="Matrix utility functions. " alt="" coords="5216,80,5307,107"/><area shape="rect" id="node38" href="sfgmr_8c.html" title="flexible GMRES from ITSOL developed by Yousef Saad. " alt="" coords="5331,80,5464,107"/><area shape="rect" id="node39" href="sitersol_8c.html" title="Example #1 showing how to use ILU to precondition GMRES. " alt="" coords="5489,80,5631,107"/><area shape="rect" id="node40" href="sitersol1_8c.html" title="Example #2 showing how to use ILU to precondition GMRES. " alt="" coords="5655,80,5803,107"/><area shape="rect" id="node41" href="slinsol_8c.html" title="EXAMPLE/slinsol.c" alt="" coords="5829,80,5965,107"/><area shape="rect" id="node42" href="slinsol1_8c.html" title="EXAMPLE/slinsol1.c" alt="" coords="5991,80,6135,107"/><area shape="rect" id="node43" href="slinsolx_8c.html" title="EXAMPLE/slinsolx.c" alt="" coords="6159,80,6303,107"/><area shape="rect" id="node44" href="slinsolx1_8c.html" title="EXAMPLE/slinsolx1.c" alt="" coords="6327,80,6477,107"/><area shape="rect" id="node45" href="slinsolx2_8c.html" title="EXAMPLE/slinsolx2.c" alt="" coords="6502,80,6652,107"/><area shape="rect" id="node46" href="slinsolx3_8c.html" title="EXAMPLE/slinsolx3.c" alt="" coords="6677,80,6827,107"/><area shape="rect" id="node47" href="c__fortran__sgssv_8c.html" title="FORTRAN/c_fortran_sgssv.c" alt="" coords="6852,80,7047,107"/></map>
</div>
</div>
<p><a href="slu__sdefs_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab6fd6105e64ed14a0c9281326f05e623"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a></td></tr>
<tr class="separator:ab6fd6105e64ed14a0c9281326f05e623"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a44bbae3b1218d951ed229c461a5f14b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a44bbae3b1218d951ed229c461a5f14b6">sgssv</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="memdesc:a44bbae3b1218d951ed229c461a5f14b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver routines.  <a href="#a44bbae3b1218d951ed229c461a5f14b6">More...</a><br/></td></tr>
<tr class="separator:a44bbae3b1218d951ed229c461a5f14b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5f2ccee873d436a117b99b2bec60da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a9e5f2ccee873d436a117b99b2bec60da">sgssvx</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, int *, char *, float *, float *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, void *, int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, float *, float *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:a9e5f2ccee873d436a117b99b2bec60da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6cdbb84f0fbd4cbce7a64ea1f7eb20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aff6cdbb84f0fbd4cbce7a64ea1f7eb20">sgsisv</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:aff6cdbb84f0fbd4cbce7a64ea1f7eb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fcf6fe814189a632a72220d5a303f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a30fcf6fe814189a632a72220d5a303f8">sgsisx</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, int *, char *, float *, float *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, void *, int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:a30fcf6fe814189a632a72220d5a303f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3d30eea43abc536793244e7564e70d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#abb3d30eea43abc536793244e7564e70d">sCreate_CompCol_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int, float *, int *, int *, <a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>
<tr class="memdesc:abb3d30eea43abc536793244e7564e70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supernodal LU factor related.  <a href="#abb3d30eea43abc536793244e7564e70d">More...</a><br/></td></tr>
<tr class="separator:abb3d30eea43abc536793244e7564e70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77496309d539716f616365a2515aa653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a77496309d539716f616365a2515aa653">sCreate_CompRow_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int, float *, int *, int *, <a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>
<tr class="separator:a77496309d539716f616365a2515aa653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7369dba9a8c3e34a27bdc9eba73cbe3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a7369dba9a8c3e34a27bdc9eba73cbe3e">sCopy_CompCol_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>
<tr class="memdesc:a7369dba9a8c3e34a27bdc9eba73cbe3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy matrix A into matrix B.  <a href="#a7369dba9a8c3e34a27bdc9eba73cbe3e">More...</a><br/></td></tr>
<tr class="separator:a7369dba9a8c3e34a27bdc9eba73cbe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca98118f5539f098beff0b70c041c2e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aca98118f5539f098beff0b70c041c2e6">sCreate_Dense_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, float *, int, <a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>
<tr class="separator:aca98118f5539f098beff0b70c041c2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4386b0d87e1c8886b58fcf9d243bc12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#af4386b0d87e1c8886b58fcf9d243bc12">sCreate_SuperNode_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int, float *, int *, int *, int *, int *, int *, <a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>
<tr class="separator:af4386b0d87e1c8886b58fcf9d243bc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef26ab4351b4ab39c2ef3d0ff5d6cb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a5ef26ab4351b4ab39c2ef3d0ff5d6cb5">sCopy_Dense_Matrix</a> (int, int, float *, int, float *, int)</td></tr>
<tr class="separator:a5ef26ab4351b4ab39c2ef3d0ff5d6cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8086902aa8be3fc7d04c3c82ec3a79dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a8086902aa8be3fc7d04c3c82ec3a79dc">countnz</a> (const int, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="memdesc:a8086902aa8be3fc7d04c3c82ec3a79dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the total number of nonzeros in factors L and U, and in the symmetrically reduced L.  <a href="#a8086902aa8be3fc7d04c3c82ec3a79dc">More...</a><br/></td></tr>
<tr class="separator:a8086902aa8be3fc7d04c3c82ec3a79dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8eb367a0a2fcdf734738bc9630df85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aae8eb367a0a2fcdf734738bc9630df85">ilu_countnz</a> (const int, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="memdesc:aae8eb367a0a2fcdf734738bc9630df85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the total number of nonzeros in factors L and U.  <a href="#aae8eb367a0a2fcdf734738bc9630df85">More...</a><br/></td></tr>
<tr class="separator:aae8eb367a0a2fcdf734738bc9630df85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7061332d759d7e4d73c1b2e5cb0bf2bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a7061332d759d7e4d73c1b2e5cb0bf2bf">fixupL</a> (const int, const int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="memdesc:a7061332d759d7e4d73c1b2e5cb0bf2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix up the data storage lsub for L-subscripts. It removes the subscript sets for structural pruning, and applies permuation to the remaining subscripts.  <a href="#a7061332d759d7e4d73c1b2e5cb0bf2bf">More...</a><br/></td></tr>
<tr class="separator:a7061332d759d7e4d73c1b2e5cb0bf2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef6f98786d0bd76103237385ddbeb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aaef6f98786d0bd76103237385ddbeb9f">sallocateA</a> (int, int, float **, int **, int **)</td></tr>
<tr class="memdesc:aaef6f98786d0bd76103237385ddbeb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage for original matrix A.  <a href="#aaef6f98786d0bd76103237385ddbeb9f">More...</a><br/></td></tr>
<tr class="separator:aaef6f98786d0bd76103237385ddbeb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f83568633bc0ce7ec5adcb351c1497"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a77f83568633bc0ce7ec5adcb351c1497">sgstrf</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int *, void *, int, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:a77f83568633bc0ce7ec5adcb351c1497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d54c8dfc11f1e034b4b7175be60ffb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ad9d54c8dfc11f1e034b4b7175be60ffb">ssnode_dfs</a> (const int, const int, const int *, const int *, const int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:ad9d54c8dfc11f1e034b4b7175be60ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e60255360fae0b1458da070690a3a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a60e60255360fae0b1458da070690a3a2">ssnode_bmod</a> (const int, const int, const int, float *, float *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>
<tr class="memdesc:a60e60255360fae0b1458da070690a3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numeric block updates within the relaxed snode.  <a href="#a60e60255360fae0b1458da070690a3a2">More...</a><br/></td></tr>
<tr class="separator:a60e60255360fae0b1458da070690a3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77baf210393e04fa71d4e73b5e60e556"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a77baf210393e04fa71d4e73b5e60e556">spanel_dfs</a> (const int, const int, const int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, float *, int *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:a77baf210393e04fa71d4e73b5e60e556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51486936a9ff5079afed80eb5bf8a3e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a51486936a9ff5079afed80eb5bf8a3e0">spanel_bmod</a> (const int, const int, const int, const int, float *, float *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>
<tr class="separator:a51486936a9ff5079afed80eb5bf8a3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dc9300377cb7240572ba34a31af3d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a20dc9300377cb7240572ba34a31af3d1">scolumn_dfs</a> (const int, const int, int *, int *, int *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:a20dc9300377cb7240572ba34a31af3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21004feb23626f7ea648b46657a257a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ae21004feb23626f7ea648b46657a257a">scolumn_bmod</a> (const int, const int, float *, float *, int *, int *, int, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>
<tr class="separator:ae21004feb23626f7ea648b46657a257a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249a312149bcf091fcc8adbd0c536cb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a249a312149bcf091fcc8adbd0c536cb2">scopy_to_ucol</a> (int, int, int *, int *, int *, float *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:a249a312149bcf091fcc8adbd0c536cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ddf03faedae25b4d73e0b6b33bf50c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ad7ddf03faedae25b4d73e0b6b33bf50c">spivotL</a> (const int, const double, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>
<tr class="separator:ad7ddf03faedae25b4d73e0b6b33bf50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9da2c45289246ef663fc4a96d1ad78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#acf9da2c45289246ef663fc4a96d1ad78">spruneL</a> (const int, const int *, const int, const int, const int *, const int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:acf9da2c45289246ef663fc4a96d1ad78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab345670a95db3f9c4b9c451224db8227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab345670a95db3f9c4b9c451224db8227">sreadmt</a> (int *, int *, int *, float **, int **, int **)</td></tr>
<tr class="separator:ab345670a95db3f9c4b9c451224db8227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79adc3c2d496feb17f359aa303211fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab79adc3c2d496feb17f359aa303211fc">sGenXtrue</a> (int, int, float *, int)</td></tr>
<tr class="separator:ab79adc3c2d496feb17f359aa303211fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b784b5551863e8d50047ee280c34cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ac8b784b5551863e8d50047ee280c34cf">sFillRHS</a> (<a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>, int, float *, int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>
<tr class="memdesc:ac8b784b5551863e8d50047ee280c34cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let rhs[i] = sum of i-th row of A, so the solution vector is all 1's.  <a href="#ac8b784b5551863e8d50047ee280c34cf">More...</a><br/></td></tr>
<tr class="separator:ac8b784b5551863e8d50047ee280c34cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea450a9c52512127d6eaaebf0a65f9ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aea450a9c52512127d6eaaebf0a65f9ce">sgstrs</a> (<a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:aea450a9c52512127d6eaaebf0a65f9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa9941535fb0b2fdbd7b3287da5f2a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#acaa9941535fb0b2fdbd7b3287da5f2a0">sgsitrf</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int *, void *, int, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:acaa9941535fb0b2fdbd7b3287da5f2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69557d06b4e300aa6aca944561f3bb32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a69557d06b4e300aa6aca944561f3bb32">sldperm</a> (int, int, int, int[], int[], float[], int[], float[], float[])</td></tr>
<tr class="separator:a69557d06b4e300aa6aca944561f3bb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714eccb6cd0fb1fc0920e8a52489f1a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a714eccb6cd0fb1fc0920e8a52489f1a5">ilu_ssnode_dfs</a> (const int, const int, const int *, const int *, const int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:a714eccb6cd0fb1fc0920e8a52489f1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91b3297a15ace9ac5abd65c5e708f2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aa91b3297a15ace9ac5abd65c5e708f2d">ilu_spanel_dfs</a> (const int, const int, const int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, float *, float *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:aa91b3297a15ace9ac5abd65c5e708f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2366ea3e2cdcbf51b976432fc43616"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aab2366ea3e2cdcbf51b976432fc43616">ilu_scolumn_dfs</a> (const int, const int, int *, int *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:aab2366ea3e2cdcbf51b976432fc43616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a18be483569110edc1665d13e260e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a35a18be483569110edc1665d13e260e3">ilu_scopy_to_ucol</a> (int, int, int *, int *, int *, float *, int, <a class="el" href="superlu__enum__consts_8h.html#a0cb73c13a7c2390c3a9a0a8913477ff0">milu_t</a>, double, int, float *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, float *)</td></tr>
<tr class="separator:a35a18be483569110edc1665d13e260e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f61e0a95c151f53f8a400bc9c6192e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab7f61e0a95c151f53f8a400bc9c6192e">ilu_spivotL</a> (const int, const double, int *, int *, int, int *, int *, int *, int *, double, <a class="el" href="superlu__enum__consts_8h.html#a0cb73c13a7c2390c3a9a0a8913477ff0">milu_t</a>, float, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>
<tr class="separator:ab7f61e0a95c151f53f8a400bc9c6192e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5e67d3b2d715a388ca99bb28387fb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a5f5e67d3b2d715a388ca99bb28387fb9">ilu_sdrop_row</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, int, int, double, int, int *, double *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, float *, float *, int)</td></tr>
<tr class="separator:a5f5e67d3b2d715a388ca99bb28387fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbdb406f2fb8b186f0f8d3a4cd2d60d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a3dbdb406f2fb8b186f0f8d3a4cd2d60d">sgsequ</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, float *, float *, float *, int *)</td></tr>
<tr class="memdesc:a3dbdb406f2fb8b186f0f8d3a4cd2d60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver related.  <a href="#a3dbdb406f2fb8b186f0f8d3a4cd2d60d">More...</a><br/></td></tr>
<tr class="separator:a3dbdb406f2fb8b186f0f8d3a4cd2d60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4b556cd9d484f53606d114f83649d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#afe4b556cd9d484f53606d114f83649d4">slaqgs</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, float, float, float, char *)</td></tr>
<tr class="separator:afe4b556cd9d484f53606d114f83649d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c910cf12639a22a03727ad204575b3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a1c910cf12639a22a03727ad204575b3b">sgscon</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float, float *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:a1c910cf12639a22a03727ad204575b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8787465a6296109b9a306d5a315ff8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#acb8787465a6296109b9a306d5a315ff8">sPivotGrowth</a> (int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>
<tr class="separator:acb8787465a6296109b9a306d5a315ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae824bcb507f76ad3053d845352fb6b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ae824bcb507f76ad3053d845352fb6b3d">sgsrfs</a> (<a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, char *, float *, float *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:ae824bcb507f76ad3053d845352fb6b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d287b6b9bcaf72a692343e614c429c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aa6d287b6b9bcaf72a692343e614c429c">sp_strsv</a> (char *, char *, char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="memdesc:aa6d287b6b9bcaf72a692343e614c429c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves one of the systems of equations A*x = b, or A'*x = b.  <a href="#aa6d287b6b9bcaf72a692343e614c429c">More...</a><br/></td></tr>
<tr class="separator:aa6d287b6b9bcaf72a692343e614c429c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e543b2d14781b56ef349114012b4fc9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a9e543b2d14781b56ef349114012b4fc9">sp_sgemv</a> (char *, float, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, int, float, float *, int)</td></tr>
<tr class="memdesc:a9e543b2d14781b56ef349114012b4fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs one of the matrix-vector operations y := alpha*A*x + beta*y, or y := alpha*A'*x + beta*y,.  <a href="#a9e543b2d14781b56ef349114012b4fc9">More...</a><br/></td></tr>
<tr class="separator:a9e543b2d14781b56ef349114012b4fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b4a0e44c32443df609069021d27812"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a35b4a0e44c32443df609069021d27812">sp_sgemm</a> (char *, char *, int, int, int, float, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, int, float, float *, int)</td></tr>
<tr class="separator:a35b4a0e44c32443df609069021d27812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b49252f1cab66e35ac47ac1afb2adec"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a1b49252f1cab66e35ac47ac1afb2adec">smach</a> (char *)</td></tr>
<tr class="separator:a1b49252f1cab66e35ac47ac1afb2adec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68715ec86cde90aa31fec07164d6ea6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#af68715ec86cde90aa31fec07164d6ea6">sLUMemInit</a> (<a class="el" href="superlu__enum__consts_8h.html#ac785c8235480e5cfef9848d89c047c0a">fact_t</a>, void *, int, int, int, int, int, float, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, int **, float **)</td></tr>
<tr class="memdesc:af68715ec86cde90aa31fec07164d6ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory-related.  <a href="#af68715ec86cde90aa31fec07164d6ea6">More...</a><br/></td></tr>
<tr class="separator:af68715ec86cde90aa31fec07164d6ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b2859bf1ef1900506dfa702574c6ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab5b2859bf1ef1900506dfa702574c6ad">sSetRWork</a> (int, int, float *, float **, float **)</td></tr>
<tr class="memdesc:ab5b2859bf1ef1900506dfa702574c6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up pointers for real working arrays.  <a href="#ab5b2859bf1ef1900506dfa702574c6ad">More...</a><br/></td></tr>
<tr class="separator:ab5b2859bf1ef1900506dfa702574c6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9035f0d2a50cf5d8e29287572bd1be83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a9035f0d2a50cf5d8e29287572bd1be83">sLUWorkFree</a> (int *, float *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="memdesc:a9035f0d2a50cf5d8e29287572bd1be83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the working storage used by factor routines.  <a href="#a9035f0d2a50cf5d8e29287572bd1be83">More...</a><br/></td></tr>
<tr class="separator:a9035f0d2a50cf5d8e29287572bd1be83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af26d0426eb0bb63755880f2e67e7b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7">sLUMemXpand</a> (int, int, <a class="el" href="superlu__enum__consts_8h.html#abd31f838aefffa46191d0d7dc36a96b2">MemType</a>, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="memdesc:a9af26d0426eb0bb63755880f2e67e7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the data structures for L and U during the factorization.  <a href="#a9af26d0426eb0bb63755880f2e67e7b7">More...</a><br/></td></tr>
<tr class="separator:a9af26d0426eb0bb63755880f2e67e7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42361c3ce2ba81d149ffba01fbd6f138"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a42361c3ce2ba81d149ffba01fbd6f138">floatMalloc</a> (int)</td></tr>
<tr class="separator:a42361c3ce2ba81d149ffba01fbd6f138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1230bff11a9e47c35555299bcdcf1b"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a3e1230bff11a9e47c35555299bcdcf1b">floatCalloc</a> (int)</td></tr>
<tr class="separator:a3e1230bff11a9e47c35555299bcdcf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50ebebf3a620086366b6c310d52d681"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab50ebebf3a620086366b6c310d52d681">smemory_usage</a> (const int, const int, const int, const int)</td></tr>
<tr class="separator:ab50ebebf3a620086366b6c310d52d681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1357f9a3b2ffb9522883ad84affa63e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a1357f9a3b2ffb9522883ad84affa63e3">sQuerySpace</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *)</td></tr>
<tr class="separator:a1357f9a3b2ffb9522883ad84affa63e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb260ae3f26e2179b1cf33c3e754d6f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#adb260ae3f26e2179b1cf33c3e754d6f1">ilu_sQuerySpace</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *)</td></tr>
<tr class="separator:adb260ae3f26e2179b1cf33c3e754d6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad9d9454734717431356db0e8eb5deb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a6ad9d9454734717431356db0e8eb5deb">sreadhb</a> (FILE *, int *, int *, int *, float **, int **, int **)</td></tr>
<tr class="memdesc:a6ad9d9454734717431356db0e8eb5deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary routines.  <a href="#a6ad9d9454734717431356db0e8eb5deb">More...</a><br/></td></tr>
<tr class="separator:a6ad9d9454734717431356db0e8eb5deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad992a573876b4abfe192ec2bc207f6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ad992a573876b4abfe192ec2bc207f6b0">sreadrb</a> (int *, int *, int *, float **, int **, int **)</td></tr>
<tr class="separator:ad992a573876b4abfe192ec2bc207f6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99cb18465c8992235a7bc003237f692"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ae99cb18465c8992235a7bc003237f692">sreadtriple</a> (int *, int *, int *, float **, int **, int **)</td></tr>
<tr class="separator:ae99cb18465c8992235a7bc003237f692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4be8ddf6a62ef48ca8dfc3a6992634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aef4be8ddf6a62ef48ca8dfc3a6992634">sCompRow_to_CompCol</a> (int, int, int, float *, int *, int *, float **, int **, int **)</td></tr>
<tr class="memdesc:aef4be8ddf6a62ef48ca8dfc3a6992634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a row compressed storage into a column compressed storage.  <a href="#aef4be8ddf6a62ef48ca8dfc3a6992634">More...</a><br/></td></tr>
<tr class="separator:aef4be8ddf6a62ef48ca8dfc3a6992634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d734e40276e89a3ef04bf79bc21acb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a2d734e40276e89a3ef04bf79bc21acb6">sfill</a> (float *, int, float)</td></tr>
<tr class="memdesc:a2d734e40276e89a3ef04bf79bc21acb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a float precision array with a given value.  <a href="#a2d734e40276e89a3ef04bf79bc21acb6">More...</a><br/></td></tr>
<tr class="separator:a2d734e40276e89a3ef04bf79bc21acb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0eeda28d139bf88878880edd3cca5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aba0eeda28d139bf88878880edd3cca5a">sinf_norm_error</a> (int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *)</td></tr>
<tr class="memdesc:aba0eeda28d139bf88878880edd3cca5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the inf-norm of the error vector.  <a href="#aba0eeda28d139bf88878880edd3cca5a">More...</a><br/></td></tr>
<tr class="separator:aba0eeda28d139bf88878880edd3cca5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d44fe59660f87330b0172151a76141"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a98d44fe59660f87330b0172151a76141">sqselect</a> (int, float *, int)</td></tr>
<tr class="separator:a98d44fe59660f87330b0172151a76141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd6efad9d9fb7aef8a984f5e3cff66b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a5cd6efad9d9fb7aef8a984f5e3cff66b">sPrint_CompCol_Matrix</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>
<tr class="memdesc:a5cd6efad9d9fb7aef8a984f5e3cff66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines for debugging.  <a href="#a5cd6efad9d9fb7aef8a984f5e3cff66b">More...</a><br/></td></tr>
<tr class="separator:a5cd6efad9d9fb7aef8a984f5e3cff66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb289a84407c9cbbb33cdf3dbb1dacbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aeb289a84407c9cbbb33cdf3dbb1dacbe">sPrint_SuperNode_Matrix</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>
<tr class="separator:aeb289a84407c9cbbb33cdf3dbb1dacbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b29c47333295f4aa744e541e277ea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a25b29c47333295f4aa744e541e277ea0">sPrint_Dense_Matrix</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>
<tr class="separator:a25b29c47333295f4aa744e541e277ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297455c494a78c098b2bf418edbc6b16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a297455c494a78c098b2bf418edbc6b16">sprint_lu_col</a> (char *, int, int, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="memdesc:a297455c494a78c098b2bf418edbc6b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagnostic print of column "jcol" in the U/L factor.  <a href="#a297455c494a78c098b2bf418edbc6b16">More...</a><br/></td></tr>
<tr class="separator:a297455c494a78c098b2bf418edbc6b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0c06e9adc1e29a0ab2e78c38119bb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aad0c06e9adc1e29a0ab2e78c38119bb4">print_double_vec</a> (char *, int, double *)</td></tr>
<tr class="separator:aad0c06e9adc1e29a0ab2e78c38119bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaeba209bf02be915b199402a1367ee0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#afaeba209bf02be915b199402a1367ee0">scheck_tempv</a> (int, float *)</td></tr>
<tr class="memdesc:afaeba209bf02be915b199402a1367ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether tempv[] == 0. This should be true before and after calling any numeric routines, i.e., "panel_bmod" and "column_bmod".  <a href="#afaeba209bf02be915b199402a1367ee0">More...</a><br/></td></tr>
<tr class="separator:afaeba209bf02be915b199402a1367ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab822504d3d60a944da04997b4f91e067"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab822504d3d60a944da04997b4f91e067">sgemm_</a> (const char *, const char *, const int *, const int *, const int *, const float *, const float *, const int *, const float *, const int *, const float *, float *, const int *)</td></tr>
<tr class="memdesc:ab822504d3d60a944da04997b4f91e067"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS.  <a href="#ab822504d3d60a944da04997b4f91e067">More...</a><br/></td></tr>
<tr class="separator:ab822504d3d60a944da04997b4f91e067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab583b502d3953688a3fa27a9f4bbf1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aab583b502d3953688a3fa27a9f4bbf1e">strsv_</a> (char *, char *, char *, int *, float *, int *, float *, int *)</td></tr>
<tr class="separator:aab583b502d3953688a3fa27a9f4bbf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68de665c44346f6eacfe87e9f3c2a1e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a68de665c44346f6eacfe87e9f3c2a1e6">strsm_</a> (char *, char *, char *, char *, int *, int *, float *, float *, int *, float *, int *)</td></tr>
<tr class="separator:a68de665c44346f6eacfe87e9f3c2a1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29fbdb32369b70973b05d14fc3420c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ae29fbdb32369b70973b05d14fc3420c9">sgemv_</a> (char *, int *, int *, float *, float *a, int *, float *, int *, float *, float *, int *)</td></tr>
<tr class="separator:ae29fbdb32369b70973b05d14fc3420c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright (c) 2003, The Regents of the University of California, through Lawrence Berkeley National Laboratory (subject to receipt of any required approvals from U.S. Dept. of Energy)</p>
<p>All rights reserved.</p>
<p>The source code is distributed under BSD license, see the file License.txt at the top-level directory.</p>
<pre> 
&ndash; SuperLU routine (version 4.1) &ndash;
Univ. of California Berkeley, Xerox Palo Alto Research Center,
and Lawrence Berkeley National Lab.
November, 2010</pre><pre>Global data structures used in LU factorization -</pre><pre>  nsuper: #supernodes = nsuper + 1, numbered [0, nsuper].
  (xsup,supno): supno[i] is the supernode no to which i belongs;
     xsup(s) points to the beginning of the s-th supernode.
     e.g.   supno 0 1 2 2 3 3 3 4 4 4 4 4   (n=12)
             xsup 0 1 2 4 7 12
     Note: dfs will be performed on supernode rep. relative to the new 
           row pivoting ordering</pre><pre>  (xlsub,lsub): lsub[*] contains the compressed subscript of
     rectangular supernodes; xlsub[j] points to the starting
     location of the j-th column in lsub[*]. Note that xlsub 
     is indexed by column.
     Storage: original row subscripts</pre><pre>     During the course of sparse LU factorization, we also use
     (xlsub,lsub) for the purpose of symmetric pruning. For each
     supernode {s,s+1,...,t=s+r} with first column s and last
     column t, the subscript set
        lsub[j], j=xlsub[s], .., xlsub[s+1]-1
     is the structure of column s (i.e. structure of this supernode).
     It is used for the storage of numerical values.
     Furthermore,
        lsub[j], j=xlsub[t], .., xlsub[t+1]-1
     is the structure of the last column t of this supernode.
     It is for the purpose of symmetric pruning. Therefore, the
     structural subscripts can be rearranged without making physical
     interchanges among the numerical values.</pre><pre>     However, if the supernode has only one column, then we
     only keep one set of subscripts. For any subscript interchange
     performed, similar interchange must be done on the numerical
     values.</pre><pre>     The last column structures (for pruning) will be removed
     after the numercial LU factorization phase.</pre><pre>  (xlusup,lusup): lusup[*] contains the numerical values of the
     rectangular supernodes; xlusup[j] points to the starting
     location of the j-th column in storage vector lusup[*]
     Note: xlusup is indexed by column.
     Each rectangular supernode is stored by column-major
     scheme, consistent with Fortran 2-dim array storage.</pre><pre>  (xusub,ucol,usub): ucol[*] stores the numerical values of
     U-columns outside the rectangular supernodes. The row
     subscript of nonzero ucol[k] is stored in usub[k].
     xusub[i] points to the starting location of column i in ucol.
     Storage: new row subscripts; that is subscripts of PA.
</pre> </div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab6fd6105e64ed14a0c9281326f05e623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="slu__cdefs_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8086902aa8be3fc7d04c3c82ec3a79dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void countnz </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7061332d759d7e4d73c1b2e5cb0bf2bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fixupL </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e1230bff11a9e47c35555299bcdcf1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* floatCalloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a42361c3ce2ba81d149ffba01fbd6f138"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* floatMalloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aae8eb367a0a2fcdf734738bc9630df85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilu_countnz </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aab2366ea3e2cdcbf51b976432fc43616"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_scolumn_dfs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>lsub_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
  ILU_SCOLUMN_DFS performs a symbolic factorization on column jcol, and
  decide the supernode boundary.</pre><pre>  This routine does not use numeric values, but only use the RHS
  row indices to start the dfs.</pre><pre>  A supernode representative is the last column of a supernode.
  The nonzeros in U[*,j] are segments that end at supernodal
  representatives. The routine returns a list of such supernodal
  representatives in topological order of the dfs that generates them.
  The location of the first nonzero in each such supernodal segment
  (supernodal entry location) is also returned.</pre><pre><h1>Local parameters
</h1>
</pre><pre>
  nseg: no of segments in current U[*,j]
  jsuper: jsuper=EMPTY if column j does not belong to the same
     supernode as j-1. Otherwise, jsuper=nsuper.</pre><pre>  marker2: A-row &ndash;&gt; A-row/col (0/1)
  repfnz: SuperA-col &ndash;&gt; PA-row
  parent: SuperA-col &ndash;&gt; SuperA-col
  xplore: SuperA-col &ndash;&gt; index to L-structure</pre><pre><h1>Return value
</h1>
</pre><pre>
    0  success;
</p>
<blockquote class="doxtable">
<p>0  number of bytes allocated when run out of space.</p>
<p></p>
</blockquote>
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_aab2366ea3e2cdcbf51b976432fc43616_cgraph.png" border="0" usemap="#slu__sdefs_8h_aab2366ea3e2cdcbf51b976432fc43616_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_aab2366ea3e2cdcbf51b976432fc43616_cgraph" id="slu__sdefs_8h_aab2366ea3e2cdcbf51b976432fc43616_cgraph">
<area shape="rect" id="node2" href="slu__util_8h.html#a72be96e75e58564c4322ef9ef73ca65f" title="sp_ienv" alt="" coords="193,31,260,57"/><area shape="rect" id="node4" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7" title="Expand the data structures for L and U during the factorization. " alt="" coords="171,81,283,108"/><area shape="rect" id="node3" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="349,31,432,57"/><area shape="rect" id="node5" href="smemory_8c.html#aa2862f14356be7d9f12bfdfc175137a1" title="Expand the existing storage to accommodate more fill&#45;ins. " alt="" coords="355,81,426,108"/><area shape="rect" id="node10" href="smemory_8c.html#a658f955c5532813bd0490502efae563f" title="smemory_usage" alt="" coords="331,132,450,159"/><area shape="rect" id="node6" href="smemory_8c.html#ab59eea34474da95fb3dc125400a1287e" title="copy_mem_int" alt="" coords="505,5,612,32"/><area shape="rect" id="node7" href="smemory_8c.html#a00d00daa40d07c16e3ae6bfd87c70e3d" title="copy_mem_float" alt="" coords="499,56,618,83"/><area shape="rect" id="node8" href="smemory_8c.html#ad68adc1b6de3f821f9fb24cdcf24d281" title="suser_malloc" alt="" coords="509,107,608,133"/><area shape="rect" id="node9" href="smemory_8c.html#a4c226087c09a94ff40b92b14fa46fc53" title="user_bcopy" alt="" coords="514,157,603,184"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a35a18be483569110edc1665d13e260e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_scopy_to_ucol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#a0cb73c13a7c2390c3a9a0a8913477ff0">milu_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a35a18be483569110edc1665d13e260e3_cgraph.png" border="0" usemap="#slu__sdefs_8h_a35a18be483569110edc1665d13e260e3_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a35a18be483569110edc1665d13e260e3_cgraph" id="slu__sdefs_8h_a35a18be483569110edc1665d13e260e3_cgraph">
<area shape="rect" id="node2" href="slu__cdefs_8h.html#a1b49252f1cab66e35ac47ac1afb2adec" title="smach" alt="" coords="207,56,268,83"/><area shape="rect" id="node3" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7" title="Expand the data structures for L and U during the factorization. " alt="" coords="181,107,293,133"/><area shape="rect" id="node10" href="ilu__scopy__to__ucol_8c.html#af839d60e0d4028df30ea1106ce429210" title="scopy_" alt="" coords="205,157,269,184"/><area shape="rect" id="node11" href="qselect_8c.html#a5a36bc5d24fe074bc4f3cfb65d7f0ae8" title="sqselect" alt="" coords="202,208,273,235"/><area shape="rect" id="node12" href="ilu__cdrop__row_8c.html#a8ddf1742e9078a786574bb5aa80aed2a" title="_compare_" alt="" coords="194,259,281,285"/><area shape="rect" id="node4" href="smemory_8c.html#aa2862f14356be7d9f12bfdfc175137a1" title="Expand the existing storage to accommodate more fill&#45;ins. " alt="" coords="366,81,437,108"/><area shape="rect" id="node9" href="smemory_8c.html#a658f955c5532813bd0490502efae563f" title="smemory_usage" alt="" coords="342,132,461,159"/><area shape="rect" id="node5" href="smemory_8c.html#ab59eea34474da95fb3dc125400a1287e" title="copy_mem_int" alt="" coords="516,5,623,32"/><area shape="rect" id="node6" href="smemory_8c.html#a00d00daa40d07c16e3ae6bfd87c70e3d" title="copy_mem_float" alt="" coords="510,56,629,83"/><area shape="rect" id="node7" href="smemory_8c.html#ad68adc1b6de3f821f9fb24cdcf24d281" title="suser_malloc" alt="" coords="520,107,619,133"/><area shape="rect" id="node8" href="smemory_8c.html#a4c226087c09a94ff40b92b14fa46fc53" title="user_bcopy" alt="" coords="525,157,614,184"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5f5e67d3b2d715a388ca99bb28387fb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_sdrop_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa91b3297a15ace9ac5abd65c5e708f2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilu_spanel_dfs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panel_lsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>  Performs a symbolic factorization on a panel of columns [jcol, jcol+w).</pre><pre>  A supernode representative is the last column of a supernode.
  The nonzeros in U[*,j] are segments that end at supernodal
  representatives.</pre><pre>  The routine returns one list of the supernodal representatives
  in topological order of the dfs that generates them. This list is
  a superset of the topological order of each individual column within
  the panel.
  The location of the first nonzero in each supernodal segment
  (supernodal entry location) is also returned. Each column has a
  separate list for this purpose.</pre><pre>  Two marker arrays are used for dfs:
    marker[i] == jj, if i was visited during dfs of current column jj;
    marker1[i] &gt;= jcol, if i was visited by earlier columns in this panel;</pre><pre>  marker: A-row &ndash;&gt; A-row/col (0/1)
  repfnz: SuperA-col &ndash;&gt; PA-row
  parent: SuperA-col &ndash;&gt; SuperA-col
  xplore: SuperA-col &ndash;&gt; index to L-structure
</pre> 
</div>
</div>
<a class="anchor" id="ab7f61e0a95c151f53f8a400bc9c6192e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_spivotL </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>usepr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>diagind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iswap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#a0cb73c13a7c2390c3a9a0a8913477ff0">milu_t</a>&#160;</td>
          <td class="paramname"><em>milu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>drop_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
  Performs the numerical pivoting on the current column of L,
  and the CDIV operation.</pre><pre>  Pivot policy:
  (1) Compute thresh = u * max_(i&gt;=j) <a class="el" href="mc64ad_8c.html#a6a010865b10e541735fa2da8f3cd062d">abs(A_ij)</a>;
  (2) IF user specifies pivot row k and <a class="el" href="mc64ad_8c.html#a6a010865b10e541735fa2da8f3cd062d">abs(A_kj)</a> &gt;= thresh THEN
          pivot row = k;
      ELSE IF <a class="el" href="mc64ad_8c.html#a6a010865b10e541735fa2da8f3cd062d">abs(A_jj)</a> &gt;= thresh THEN
          pivot row = j;
      ELSE
          pivot row = m;</pre><pre>  Note: If you absolutely want to use a given pivot order, then set u=0.0.</pre><pre>  Return value: 0         success;
           i &gt; 0  U(i,i) is exactly zero.
</pre> 
</div>
</div>
<a class="anchor" id="adb260ae3f26e2179b1cf33c3e754d6f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_sQuerySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&#160;</td>
          <td class="paramname"><em>mem_usage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
mem_usage consists of the following fields:</p>
<ul>
<li>for_lu (float)
     The amount of space used in bytes for the L data structures.</li>
<li>total_needed (float)
     The amount of space needed in bytes to perform factorization.

</li>
</ul>
</pre>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_adb260ae3f26e2179b1cf33c3e754d6f1_cgraph.png" border="0" usemap="#slu__sdefs_8h_adb260ae3f26e2179b1cf33c3e754d6f1_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_adb260ae3f26e2179b1cf33c3e754d6f1_cgraph" id="slu__sdefs_8h_adb260ae3f26e2179b1cf33c3e754d6f1_cgraph">
<area shape="rect" id="node2" href="slu__util_8h.html#a72be96e75e58564c4322ef9ef73ca65f" title="sp_ienv" alt="" coords="176,5,243,32"/><area shape="rect" id="node3" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="291,5,373,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a714eccb6cd0fb1fc0920e8a52489f1a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_ssnode_dfs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>kcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>asub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>xa_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>xa_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
   <a class="el" href="ilu__ssnode__dfs_8c.html#a510a9174e442a65aaa83f9ce97390f85">ilu_ssnode_dfs()</a> - Determine the union of the row structures of those
   columns within the relaxed snode.
   Note: The relaxed snodes are leaves of the supernodal etree, therefore,
   the portion outside the rectangular supernode must be zero.</pre><pre><h1>Return value
</h1>
</pre><pre>
    0   success;
   &gt;0   number of bytes allocated when run out of memory.
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a714eccb6cd0fb1fc0920e8a52489f1a5_cgraph.png" border="0" usemap="#slu__sdefs_8h_a714eccb6cd0fb1fc0920e8a52489f1a5_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a714eccb6cd0fb1fc0920e8a52489f1a5_cgraph" id="slu__sdefs_8h_a714eccb6cd0fb1fc0920e8a52489f1a5_cgraph">
<area shape="rect" id="node2" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7" title="Expand the data structures for L and U during the factorization. " alt="" coords="163,107,275,133"/><area shape="rect" id="node3" href="smemory_8c.html#aa2862f14356be7d9f12bfdfc175137a1" title="Expand the existing storage to accommodate more fill&#45;ins. " alt="" coords="347,81,418,108"/><area shape="rect" id="node8" href="smemory_8c.html#a658f955c5532813bd0490502efae563f" title="smemory_usage" alt="" coords="323,132,442,159"/><area shape="rect" id="node4" href="smemory_8c.html#ab59eea34474da95fb3dc125400a1287e" title="copy_mem_int" alt="" coords="497,5,604,32"/><area shape="rect" id="node5" href="smemory_8c.html#a00d00daa40d07c16e3ae6bfd87c70e3d" title="copy_mem_float" alt="" coords="491,56,610,83"/><area shape="rect" id="node6" href="smemory_8c.html#ad68adc1b6de3f821f9fb24cdcf24d281" title="suser_malloc" alt="" coords="501,107,600,133"/><area shape="rect" id="node7" href="smemory_8c.html#a4c226087c09a94ff40b92b14fa46fc53" title="user_bcopy" alt="" coords="506,157,595,184"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aad0c06e9adc1e29a0ab2e78c38119bb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int print_double_vec </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaef6f98786d0bd76103237385ddbeb9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sallocateA </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_aaef6f98786d0bd76103237385ddbeb9f_cgraph.png" border="0" usemap="#slu__sdefs_8h_aaef6f98786d0bd76103237385ddbeb9f_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_aaef6f98786d0bd76103237385ddbeb9f_cgraph" id="slu__sdefs_8h_aaef6f98786d0bd76103237385ddbeb9f_cgraph">
<area shape="rect" id="node2" href="smemory_8c.html#a4a866452c5dcba66083ef463662955ee" title="floatMalloc" alt="" coords="136,5,221,32"/><area shape="rect" id="node3" href="memory_8c.html#a49bbe20102e5b541c8e8963afa2bd46a" title="intMalloc" alt="" coords="141,56,216,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="afaeba209bf02be915b199402a1367ee0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scheck_tempv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae21004feb23626f7ea648b46657a257a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int scolumn_bmod </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>tempv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fpanelc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose:
</h1>
</pre><pre>
Performs numeric block updates (sup-col) in topological order.
It features: col-col, 2cols-col, 3cols-col, and sup-col updates.
Special processing on the supernodal portion of L[*,j]
Return value:   0 - successful return
              &gt; 0 - number of bytes allocated when run out of space
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_ae21004feb23626f7ea648b46657a257a_cgraph.png" border="0" usemap="#slu__sdefs_8h_ae21004feb23626f7ea648b46657a257a_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_ae21004feb23626f7ea648b46657a257a_cgraph" id="slu__sdefs_8h_ae21004feb23626f7ea648b46657a257a_cgraph">
<area shape="rect" id="node2" href="slu__sdefs_8h.html#aab583b502d3953688a3fa27a9f4bbf1e" title="strsv_" alt="" coords="192,5,251,32"/><area shape="rect" id="node3" href="slu__sdefs_8h.html#ae29fbdb32369b70973b05d14fc3420c9" title="sgemv_" alt="" coords="187,56,255,83"/><area shape="rect" id="node4" href="scolumn__bmod_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="190,107,253,133"/><area shape="rect" id="node5" href="scolumn__bmod_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="185,157,257,184"/><area shape="rect" id="node6" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7" title="Expand the data structures for L and U during the factorization. " alt="" coords="165,208,277,235"/><area shape="rect" id="node7" href="smemory_8c.html#aa2862f14356be7d9f12bfdfc175137a1" title="Expand the existing storage to accommodate more fill&#45;ins. " alt="" coords="350,183,421,209"/><area shape="rect" id="node12" href="smemory_8c.html#a658f955c5532813bd0490502efae563f" title="smemory_usage" alt="" coords="326,233,445,260"/><area shape="rect" id="node8" href="smemory_8c.html#ab59eea34474da95fb3dc125400a1287e" title="copy_mem_int" alt="" coords="500,107,607,133"/><area shape="rect" id="node9" href="smemory_8c.html#a00d00daa40d07c16e3ae6bfd87c70e3d" title="copy_mem_float" alt="" coords="494,157,613,184"/><area shape="rect" id="node10" href="smemory_8c.html#ad68adc1b6de3f821f9fb24cdcf24d281" title="suser_malloc" alt="" coords="504,208,603,235"/><area shape="rect" id="node11" href="smemory_8c.html#a4c226087c09a94ff40b92b14fa46fc53" title="user_bcopy" alt="" coords="509,259,598,285"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a20dc9300377cb7240572ba34a31af3d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int scolumn_dfs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>lsub_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
  SCOLUMN_DFS performs a symbolic factorization on column jcol, and
  decide the supernode boundary.</pre><pre>  This routine does not use numeric values, but only use the RHS 
  row indices to start the dfs.</pre><pre>  A supernode representative is the last column of a supernode.
  The nonzeros in U[*,j] are segments that end at supernodal
  representatives. The routine returns a list of such supernodal 
  representatives in topological order of the dfs that generates them.
  The location of the first nonzero in each such supernodal segment
  (supernodal entry location) is also returned.</pre><pre><h1>Local parameters
</h1>
</pre><pre>
  nseg: no of segments in current U[*,j]
  jsuper: jsuper=EMPTY if column j does not belong to the same
     supernode as j-1. Otherwise, jsuper=nsuper.</pre><pre>  marker2: A-row &ndash;&gt; A-row/col (0/1)
  repfnz: SuperA-col &ndash;&gt; PA-row
  parent: SuperA-col &ndash;&gt; SuperA-col
  xplore: SuperA-col &ndash;&gt; index to L-structure</pre><pre><h1>Return value
</h1>
</pre><pre>
    0  success;
</p>
<blockquote class="doxtable">
<p>0  number of bytes allocated when run out of space.</p>
<p></p>
</blockquote>
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a20dc9300377cb7240572ba34a31af3d1_cgraph.png" border="0" usemap="#slu__sdefs_8h_a20dc9300377cb7240572ba34a31af3d1_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a20dc9300377cb7240572ba34a31af3d1_cgraph" id="slu__sdefs_8h_a20dc9300377cb7240572ba34a31af3d1_cgraph">
<area shape="rect" id="node2" href="slu__util_8h.html#a72be96e75e58564c4322ef9ef73ca65f" title="sp_ienv" alt="" coords="172,31,239,57"/><area shape="rect" id="node4" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7" title="Expand the data structures for L and U during the factorization. " alt="" coords="149,81,261,108"/><area shape="rect" id="node3" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="328,31,411,57"/><area shape="rect" id="node5" href="smemory_8c.html#aa2862f14356be7d9f12bfdfc175137a1" title="Expand the existing storage to accommodate more fill&#45;ins. " alt="" coords="334,81,405,108"/><area shape="rect" id="node10" href="smemory_8c.html#a658f955c5532813bd0490502efae563f" title="smemory_usage" alt="" coords="310,132,429,159"/><area shape="rect" id="node6" href="smemory_8c.html#ab59eea34474da95fb3dc125400a1287e" title="copy_mem_int" alt="" coords="484,5,591,32"/><area shape="rect" id="node7" href="smemory_8c.html#a00d00daa40d07c16e3ae6bfd87c70e3d" title="copy_mem_float" alt="" coords="478,56,597,83"/><area shape="rect" id="node8" href="smemory_8c.html#ad68adc1b6de3f821f9fb24cdcf24d281" title="suser_malloc" alt="" coords="488,107,587,133"/><area shape="rect" id="node9" href="smemory_8c.html#a4c226087c09a94ff40b92b14fa46fc53" title="user_bcopy" alt="" coords="493,157,582,184"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aef4be8ddf6a62ef48ca8dfc3a6992634"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCompRow_to_CompCol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_aef4be8ddf6a62ef48ca8dfc3a6992634_cgraph.png" border="0" usemap="#slu__sdefs_8h_aef4be8ddf6a62ef48ca8dfc3a6992634_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_aef4be8ddf6a62ef48ca8dfc3a6992634_cgraph" id="slu__sdefs_8h_aef4be8ddf6a62ef48ca8dfc3a6992634_cgraph">
<area shape="rect" id="node2" href="slu__cdefs_8h.html#a42361c3ce2ba81d149ffba01fbd6f138" title="floatMalloc" alt="" coords="224,5,309,32"/><area shape="rect" id="node3" href="memory_8c.html#a49bbe20102e5b541c8e8963afa2bd46a" title="intMalloc" alt="" coords="229,56,304,83"/><area shape="rect" id="node4" href="memory_8c.html#aaf51f82a79c361236a2d825a59a63403" title="intCalloc" alt="" coords="230,107,303,133"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7369dba9a8c3e34a27bdc9eba73cbe3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCopy_CompCol_Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ef26ab4351b4ab39c2ef3d0ff5d6cb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCopy_Dense_Matrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a two-dimensional matrix X to another matrix Y.</p>

</div>
</div>
<a class="anchor" id="a249a312149bcf091fcc8adbd0c536cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int scopy_to_ucol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a249a312149bcf091fcc8adbd0c536cb2_cgraph.png" border="0" usemap="#slu__sdefs_8h_a249a312149bcf091fcc8adbd0c536cb2_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a249a312149bcf091fcc8adbd0c536cb2_cgraph" id="slu__sdefs_8h_a249a312149bcf091fcc8adbd0c536cb2_cgraph">
<area shape="rect" id="node2" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7" title="Expand the data structures for L and U during the factorization. " alt="" coords="160,107,272,133"/><area shape="rect" id="node3" href="smemory_8c.html#aa2862f14356be7d9f12bfdfc175137a1" title="Expand the existing storage to accommodate more fill&#45;ins. " alt="" coords="345,81,415,108"/><area shape="rect" id="node8" href="smemory_8c.html#a658f955c5532813bd0490502efae563f" title="smemory_usage" alt="" coords="321,132,439,159"/><area shape="rect" id="node4" href="smemory_8c.html#ab59eea34474da95fb3dc125400a1287e" title="copy_mem_int" alt="" coords="495,5,601,32"/><area shape="rect" id="node5" href="smemory_8c.html#a00d00daa40d07c16e3ae6bfd87c70e3d" title="copy_mem_float" alt="" coords="489,56,607,83"/><area shape="rect" id="node6" href="smemory_8c.html#ad68adc1b6de3f821f9fb24cdcf24d281" title="suser_malloc" alt="" coords="499,107,597,133"/><area shape="rect" id="node7" href="smemory_8c.html#a4c226087c09a94ff40b92b14fa46fc53" title="user_bcopy" alt="" coords="503,157,593,184"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="abb3d30eea43abc536793244e7564e70d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCreate_CompCol_Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a77496309d539716f616365a2515aa653"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCreate_CompRow_Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aca98118f5539f098beff0b70c041c2e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCreate_Dense_Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af4386b0d87e1c8886b58fcf9d243bc12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCreate_SuperNode_Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2d734e40276e89a3ef04bf79bc21acb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sfill </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac8b784b5551863e8d50047ee280c34cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sFillRHS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_ac8b784b5551863e8d50047ee280c34cf_cgraph.png" border="0" usemap="#slu__sdefs_8h_ac8b784b5551863e8d50047ee280c34cf_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_ac8b784b5551863e8d50047ee280c34cf_cgraph" id="slu__sdefs_8h_ac8b784b5551863e8d50047ee280c34cf_cgraph">
<area shape="rect" id="node2" href="slu__sdefs_8h.html#a35b4a0e44c32443df609069021d27812" title="sp_sgemm" alt="" coords="129,5,215,32"/><area shape="rect" id="node3" href="slu__sdefs_8h.html#a9e543b2d14781b56ef349114012b4fc9" title="Performs one of the matrix&#45;vector operations y := alpha*A*x + beta*y, or y := alpha*A&#39;*x + beta*y..." alt="" coords="264,5,347,32"/><area shape="rect" id="node4" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="395,5,477,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab822504d3d60a944da04997b4f91e067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sgemm_ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae29fbdb32369b70973b05d14fc3420c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sgemv_ </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab79adc3c2d496feb17f359aa303211fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sGenXtrue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c910cf12639a22a03727ad204575b3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgscon </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>anorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose   
</h1>
</pre><pre></pre><pre>  SGSCON estimates the reciprocal of the condition number of a general 
  real matrix A, in either the 1-norm or the infinity-norm, using   
  the LU factorization computed by SGETRF.   *</pre><pre>  An estimate is obtained for norm(inv(A)), and the reciprocal of the   
  condition number is computed as   
     RCOND = 1 / ( norm(A) * norm(inv(A)) ).</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments   
</h1>
</pre><pre></pre><pre>   NORM    (input) char*
           Specifies whether the 1-norm condition number or the   
           infinity-norm condition number is required:   
           = '1' or 'O':  1-norm;   
           = 'I':         Infinity-norm.</pre><pre>   L       (input) SuperMatrix*
           The factor L from the factorization Pr*A*Pc=L*U as computed by
           <a class="el" href="sgstrf_8c.html#a7f9874cec10809f11998cc3d9cb88f8b">sgstrf()</a>. Use compressed row subscripts storage for supernodes,
           i.e., L has types: Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>   U       (input) SuperMatrix*
           The factor U from the factorization Pr*A*Pc=L*U as computed by
           <a class="el" href="sgstrf_8c.html#a7f9874cec10809f11998cc3d9cb88f8b">sgstrf()</a>. Use column-wise storage scheme, i.e., U has types:
           Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>   ANORM   (input) float
           If NORM = '1' or 'O', the 1-norm of the original matrix A.   
           If NORM = 'I', the infinity-norm of the original matrix A.</pre><pre>   RCOND   (output) float*
          The reciprocal of the condition number of the matrix A,   
          computed as RCOND = 1/(norm(A) * norm(inv(A))).</pre><pre>   INFO    (output) int*
          = 0:  successful exit   
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value   
</p>
<hr/>

</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a1c910cf12639a22a03727ad204575b3b_cgraph.png" border="0" usemap="#slu__sdefs_8h_a1c910cf12639a22a03727ad204575b3b_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a1c910cf12639a22a03727ad204575b3b_cgraph" id="slu__sdefs_8h_a1c910cf12639a22a03727ad204575b3b_cgraph">
<area shape="rect" id="node2" href="slacon2_8c.html#ad34d61602254b2aad398e30cc3c5436d" title="slacon2_" alt="" coords="117,107,192,133"/><area shape="rect" id="node7" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="241,208,324,235"/><area shape="rect" id="node8" href="slu__cdefs_8h.html#a3e1230bff11a9e47c35555299bcdcf1b" title="floatCalloc" alt="" coords="241,259,325,285"/><area shape="rect" id="node9" href="memory_8c.html#a49bbe20102e5b541c8e8963afa2bd46a" title="intMalloc" alt="" coords="117,360,192,387"/><area shape="rect" id="node10" href="slu__sdefs_8h.html#aa6d287b6b9bcaf72a692343e614c429c" title="Solves one of the systems of equations A*x = b, or A&#39;*x = b. " alt="" coords="119,309,191,336"/><area shape="rect" id="node3" href="ilu__sdrop__row_8c.html#a18eff2aa758918dee76e31b812c88c9f" title="isamax_" alt="" coords="247,56,318,83"/><area shape="rect" id="node4" href="ilu__sdrop__row_8c.html#a43ef780d8b669dc0b19d41fa6727124f" title="sasum_" alt="" coords="249,107,317,133"/><area shape="rect" id="node5" href="ilu__scopy__to__ucol_8c.html#af839d60e0d4028df30ea1106ce429210" title="scopy_" alt="" coords="251,157,315,184"/><area shape="rect" id="node6" href="ilu__ddrop__row_8c.html#afdb24942915626f5de65c50cb31c267a" title="idamax_" alt="" coords="247,5,318,32"/><area shape="rect" id="node11" href="slu__sdefs_8h.html#aab583b502d3953688a3fa27a9f4bbf1e" title="strsv_" alt="" coords="253,461,312,488"/><area shape="rect" id="node12" href="slu__sdefs_8h.html#ae29fbdb32369b70973b05d14fc3420c9" title="sgemv_" alt="" coords="249,512,317,539"/><area shape="rect" id="node13" href="ssp__blas2_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="251,309,314,336"/><area shape="rect" id="node14" href="ssp__blas2_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="247,360,319,387"/><area shape="rect" id="node15" href="ssp__blas2_8c.html#a25ea48f4f948c68a423f5bd3929e3c1f" title="Solves a dense upper triangular system. " alt="" coords="249,411,316,437"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3dbdb406f2fb8b186f0f8d3a4cd2d60d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgsequ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rowcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>colcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose   
</h1>
</pre><pre></pre><pre>  SGSEQU computes row and column scalings intended to equilibrate an   
  M-by-N sparse matrix A and reduce its condition number. R returns the row
  scale factors and C the column scale factors, chosen to try to make   
  the largest element in each row and column of the matrix B with   
  elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.</pre><pre>  R(i) and C(j) are restricted to be between SMLNUM = smallest safe   
  number and BIGNUM = largest safe number.  Use of these scaling   
  factors is not guaranteed to reduce the condition number of A but   
  works well in practice.</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments   
</h1>
</pre><pre></pre><pre>  A       (input) SuperMatrix*
          The matrix of dimension (A-&gt;nrow, A-&gt;ncol) whose equilibration
          factors are to be computed. The type of A can be:
          Stype = SLU_NC; Dtype = SLU_S; Mtype = SLU_GE.</pre><pre>  R       (output) float*, size A-&gt;nrow
          If INFO = 0 or INFO &gt; M, R contains the row scale factors   
          for A.</pre><pre>  C       (output) float*, size A-&gt;ncol
          If INFO = 0,  C contains the column scale factors for A.</pre><pre>  ROWCND  (output) float*
          If INFO = 0 or INFO &gt; M, ROWCND contains the ratio of the   
          smallest R(i) to the largest R(i).  If ROWCND &gt;= 0.1 and   
          AMAX is neither too large nor too small, it is not worth   
          scaling by R.</pre><pre>  COLCND  (output) float*
          If INFO = 0, COLCND contains the ratio of the smallest   
          C(i) to the largest C(i).  If COLCND &gt;= 0.1, it is not   
          worth scaling by C.</pre><pre>  AMAX    (output) float*
          Absolute value of largest matrix element.  If AMAX is very   
          close to overflow or very close to underflow, the matrix   
          should be scaled.</pre><pre>  INFO    (output) int*
          = 0:  successful exit   
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value   
          &gt; 0:  if INFO = i,  and i is   
                &lt;= A-&gt;nrow:  the i-th row of A is exactly zero   
                &gt;  A-&gt;ncol:  the (i-M)-th column of A is exactly zero   
</p>
<hr/>

</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a3dbdb406f2fb8b186f0f8d3a4cd2d60d_cgraph.png" border="0" usemap="#slu__sdefs_8h_a3dbdb406f2fb8b186f0f8d3a4cd2d60d_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a3dbdb406f2fb8b186f0f8d3a4cd2d60d_cgraph" id="slu__sdefs_8h_a3dbdb406f2fb8b186f0f8d3a4cd2d60d_cgraph">
<area shape="rect" id="node2" href="slu__cdefs_8h.html#a1b49252f1cab66e35ac47ac1afb2adec" title="smach" alt="" coords="128,5,189,32"/><area shape="rect" id="node3" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="117,56,200,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aff6cdbb84f0fbd4cbce7a64ea1f7eb20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgsisv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a30fcf6fe814189a632a72220d5a303f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgsisx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>etree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>recip_pivot_growth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&#160;</td>
          <td class="paramname"><em>mem_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>SGSISX computes an approximate solutions of linear equations
A*X=B or A'*X=B, using the ILU factorization from <a class="el" href="sgsitrf_8c.html#a8c16e3d29bb8fbcc614ed6f77372b616">sgsitrf()</a>.
An estimation of the condition number is provided. 
The routine performs the following steps:</pre><pre>  1. If A is stored column-wise (A-&gt;Stype = SLU_NC):</pre><pre>     1.1. If options-&gt;Equil = YES or options-&gt;RowPerm = LargeDiag, scaling
          factors are computed to equilibrate the system:
          options-&gt;Trans = NOTRANS:
         diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
          options-&gt;Trans = TRANS:
         (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
          options-&gt;Trans = CONJ:
         (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
          Whether or not the system will be equilibrated depends on the
          scaling of the matrix A, but if equilibration is used, A is
          overwritten by diag(R)*A*diag(C) and B by diag(R)*B
          (if options-&gt;Trans=NOTRANS) or diag(C)*B (if options-&gt;Trans
          = TRANS or CONJ).</pre><pre>     1.2. Permute columns of A, forming A*Pc, where Pc is a permutation
          matrix that usually preserves sparsity.
          For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix. ">sp_preorder.c</a>.</pre><pre>     1.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
          factor the matrix A (after equilibration if options-&gt;Equil = YES)
          as Pr*A*Pc = L*U, with Pr determined by partial pivoting.</pre><pre>     1.4. Compute the reciprocal pivot growth factor.</pre><pre>     1.5. If some U(i,i) = 0, so that U is exactly singular, then the
          routine fills a small number on the diagonal entry, that is
        U(i,i) = ||A(:,i)||_oo * options-&gt;ILU_FillTol ** (1 - i / n),
          and info will be increased by 1. The factored form of A is used
          to estimate the condition number of the preconditioner. If the
          reciprocal of the condition number is less than machine precision,
          info = A-&gt;ncol+1 is returned as a warning, but the routine still
          goes on to solve for X.</pre><pre>     1.6. The system of equations is solved for X using the factored form
          of A.</pre><pre>     1.7. options-&gt;IterRefine is not used</pre><pre>     1.8. If equilibration was used, the matrix X is premultiplied by
          diag(C) (if options-&gt;Trans = NOTRANS) or diag(R)
          (if options-&gt;Trans = TRANS or CONJ) so that it solves the
          original system before equilibration.</pre><pre>     1.9. options for ILU only
          1) If options-&gt;RowPerm = LargeDiag, MC64 is used to scale and
        permute the matrix to an I-matrix, that is Pr*Dr*A*Dc has
        entries of modulus 1 on the diagonal and off-diagonal entries
        of modulus at most 1. If MC64 fails, <a class="el" href="dgsequ_8c.html#aaf22b247cc134fb0ba90285e84ccebb4" title="Driver related. ">dgsequ()</a> is used to
        equilibrate the system.
             ( Default: LargeDiag )
          2) options-&gt;ILU_DropTol = tau is the threshold for dropping.
        For L, it is used directly (for the whole row in a supernode);
        For U, ||A(:,i)||_oo * tau is used as the threshold
             for the    i-th column.
        If a secondary dropping rule is required, tau will
             also be used to compute the second threshold.
             ( Default: 1e-4 )
          3) options-&gt;ILU_FillFactor = gamma, used as the initial guess
        of memory growth.
        If a secondary dropping rule is required, it will also
             be used as an upper bound of the memory.
             ( Default: 10 )
          4) options-&gt;ILU_DropRule specifies the dropping rule.
        Option        Meaning
        ======        ===========
        DROP_BASIC:   Basic dropping rule, supernodal based ILUTP(tau).
        DROP_PROWS:   Supernodal based ILUTP(p,tau), p = gamma*nnz(A)/n.
        DROP_COLUMN:  Variant of ILUTP(p,tau), for j-th column,
                      p = gamma * nnz(A(:,j)).
        DROP_AREA:    Variation of ILUTP, for j-th column, use
                      nnz(F(:,1:j)) / nnz(A(:,1:j)) to control memory.
        DROP_DYNAMIC: Modify the threshold tau during factorizaion:
                      If nnz(L(:,1:j)) / nnz(A(:,1:j)) &gt; gamma
                          tau_L(j) := MIN(tau_0, tau_L(j-1) * 2);
                      Otherwise
                          tau_L(j) := MAX(tau_0, tau_L(j-1) / 2);
                      tau_U(j) uses the similar rule.
                      NOTE: the thresholds used by L and U are separate.
        DROP_INTERP:  Compute the second dropping threshold by
                      interpolation instead of sorting (default).
                      In this case, the actual fill ratio is not
                      guaranteed smaller than gamma.
        DROP_PROWS, DROP_COLUMN and DROP_AREA are mutually exclusive.
        ( Default: DROP_BASIC | DROP_AREA )
          5) options-&gt;ILU_Norm is the criterion of measuring the magnitude
        of a row in a supernode of L. ( Default is INF_NORM )
        options-&gt;ILU_Norm       RowSize(x[1:n])
        =================       ===============
        ONE_NORM                ||x||_1 / n
        TWO_NORM                ||x||_2 / sqrt(n)
        INF_NORM                max{|x[i]|}
          6) options-&gt;ILU_MILU specifies the type of MILU's variation.
        = SILU: do not perform Modified ILU;
        = SMILU_1 (not recommended):
            U(i,i) := U(i,i) + sum(dropped entries);
        = SMILU_2:
            U(i,i) := U(i,i) + <a class="el" href="ilu__zpivotL_8c.html#a95ed41486ca0ed53262e4b8934d4afac">SGN(U(i,i))</a> * sum(dropped entries);
        = SMILU_3:
            U(i,i) := U(i,i) + <a class="el" href="ilu__zpivotL_8c.html#a95ed41486ca0ed53262e4b8934d4afac">SGN(U(i,i))</a> * sum(|dropped entries|);
        NOTE: Even SMILU_1 does not preserve the column sum because of
        late dropping.
             ( Default: SILU )
          7) options-&gt;ILU_FillTol is used as the perturbation when
        encountering zero pivots. If some U(i,i) = 0, so that U is
        exactly singular, then
           U(i,i) := ||A(:,i)|| * options-&gt;ILU_FillTol ** (1 - i / n).
             ( Default: 1e-2 )</pre><pre>  2. If A is stored row-wise (A-&gt;Stype = SLU_NR), apply the above algorithm
     to the transpose of A:</pre><pre>     2.1. If options-&gt;Equil = YES or options-&gt;RowPerm = LargeDiag, scaling
          factors are computed to equilibrate the system:
          options-&gt;Trans = NOTRANS:
         diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
          options-&gt;Trans = TRANS:
         (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
          options-&gt;Trans = CONJ:
         (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
          Whether or not the system will be equilibrated depends on the
          scaling of the matrix A, but if equilibration is used, A' is
          overwritten by diag(R)*A'*diag(C) and B by diag(R)*B
          (if trans='N') or diag(C)*B (if trans = 'T' or 'C').</pre><pre>     2.2. Permute columns of transpose(A) (rows of A),
          forming transpose(A)*Pc, where Pc is a permutation matrix that
          usually preserves sparsity.
          For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix. ">sp_preorder.c</a>.</pre><pre>     2.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
          factor the transpose(A) (after equilibration if
          options-&gt;Fact = YES) as Pr*transpose(A)*Pc = L*U with the
          permutation Pr determined by partial pivoting.</pre><pre>     2.4. Compute the reciprocal pivot growth factor.</pre><pre>     2.5. If some U(i,i) = 0, so that U is exactly singular, then the
          routine fills a small number on the diagonal entry, that is
         U(i,i) = ||A(:,i)||_oo * options-&gt;ILU_FillTol ** (1 - i / n).
          And info will be increased by 1. The factored form of A is used
          to estimate the condition number of the preconditioner. If the
          reciprocal of the condition number is less than machine precision,
          info = A-&gt;ncol+1 is returned as a warning, but the routine still
          goes on to solve for X.</pre><pre>     2.6. The system of equations is solved for X using the factored form
          of transpose(A).</pre><pre>     2.7. If options-&gt;IterRefine is not used.</pre><pre>     2.8. If equilibration was used, the matrix X is premultiplied by
          diag(C) (if options-&gt;Trans = NOTRANS) or diag(R)
          (if options-&gt;Trans = TRANS or CONJ) so that it solves the
          original system before equilibration.</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>options (input) superlu_options_t*
        The structure defines the input parameters to control
        how the LU decomposition will be performed and how the
        system will be solved.</pre><pre>A          (input/output) SuperMatrix*
        Matrix A in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol). The number
        of the linear equations is A-&gt;nrow. Currently, the type of A can be:
        Stype = SLU_NC or SLU_NR, Dtype = SLU_S, Mtype = SLU_GE.
        In the future, more general A may be handled.</pre><pre>        On entry, If options-&gt;Fact = FACTORED and equed is not 'N',
        then A must have been equilibrated by the scaling factors in
        R and/or C.
        On exit, A is not modified
        if options-&gt;Equil = NO, or
        if options-&gt;Equil = YES but equed = 'N' on exit, or
        if options-&gt;RowPerm = NO.</pre><pre>        Otherwise, if options-&gt;Equil = YES and equed is not 'N',
        A is scaled as follows:
        If A-&gt;Stype = SLU_NC:
          equed = 'R':  A := diag(R) * A
          equed = 'C':  A := A * diag(C)
          equed = 'B':  A := diag(R) * A * diag(C).
        If A-&gt;Stype = SLU_NR:
          equed = 'R':  transpose(A) := diag(R) * transpose(A)
          equed = 'C':  transpose(A) := transpose(A) * diag(C)
          equed = 'B':  transpose(A) := diag(R) * transpose(A) * diag(C).</pre><pre>        If options-&gt;RowPerm = LargeDiag, MC64 is used to scale and permute
           the matrix to an I-matrix, that is A is modified as follows:
           P*Dr*A*Dc has entries of modulus 1 on the diagonal and 
           off-diagonal entries of modulus at most 1. P is a permutation
           obtained from MC64.
           If MC64 fails, <a class="el" href="sgsequ_8c.html#ad8a808e807e38c32c08cfbeadb088f08" title="Driver related. ">sgsequ()</a> is used to equilibrate the system,
           and A is scaled as above, but no permutation is involved.
           On exit, A is restored to the orginal row numbering, so
           Dr*A*Dc is returned.</pre><pre>perm_c  (input/output) int*
        If A-&gt;Stype = SLU_NC, Column permutation vector of size A-&gt;ncol,
        which defines the permutation matrix Pc; perm_c[i] = j means
        column i of A is in position j in A*Pc.
        On exit, perm_c may be overwritten by the product of the input
        perm_c and a permutation that postorders the elimination tree
        of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree
        is already in postorder.</pre><pre>        If A-&gt;Stype = SLU_NR, column permutation vector of size A-&gt;nrow,
        which describes permutation of columns of transpose(A) 
        (rows of A) as described above.</pre><pre>perm_r  (input/output) int*
        If A-&gt;Stype = SLU_NC, row permutation vector of size A-&gt;nrow, 
        which defines the permutation matrix Pr, and is determined
        by MC64 first then followed by partial pivoting.
        perm_r[i] = j means row i of A is in position j in Pr*A.</pre><pre>        If A-&gt;Stype = SLU_NR, permutation vector of size A-&gt;ncol, which
        determines permutation of rows of transpose(A)
        (columns of A) as described above.</pre><pre>        If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
        will try to use the input perm_r, unless a certain threshold
        criterion is violated. In that case, perm_r is overwritten by a
        new permutation determined by partial pivoting or diagonal
        threshold pivoting.
        Otherwise, perm_r is output argument.</pre><pre>etree   (input/output) int*,  dimension (A-&gt;ncol)
        Elimination tree of Pc'*A'*A*Pc.
        If options-&gt;Fact != FACTORED and options-&gt;Fact != DOFACT,
        etree is an input argument, otherwise it is an output argument.
        Note: etree is a vector of parent pointers for a forest whose
        vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.</pre><pre>equed   (input/output) char*
        Specifies the form of equilibration that was done.
        = 'N': No equilibration.
        = 'R': Row equilibration, i.e., A was premultiplied by diag(R).
        = 'C': Column equilibration, i.e., A was postmultiplied by diag(C).
        = 'B': Both row and column equilibration, i.e., A was replaced 
          by diag(R)*A*diag(C).
        If options-&gt;Fact = FACTORED, equed is an input argument,
        otherwise it is an output argument.</pre><pre>R          (input/output) float*, dimension (A-&gt;nrow)
        The row scale factors for A or transpose(A).
        If equed = 'R' or 'B', A (if A-&gt;Stype = SLU_NC) or transpose(A)
            (if A-&gt;Stype = SLU_NR) is multiplied on the left by diag(R).
        If equed = 'N' or 'C', R is not accessed.
        If options-&gt;Fact = FACTORED, R is an input argument,
            otherwise, R is output.
        If options-&gt;Fact = FACTORED and equed = 'R' or 'B', each element
            of R must be positive.</pre><pre>C          (input/output) float*, dimension (A-&gt;ncol)
        The column scale factors for A or transpose(A).
        If equed = 'C' or 'B', A (if A-&gt;Stype = SLU_NC) or transpose(A)
            (if A-&gt;Stype = SLU_NR) is multiplied on the right by diag(C).
        If equed = 'N' or 'R', C is not accessed.
        If options-&gt;Fact = FACTORED, C is an input argument,
            otherwise, C is output.
        If options-&gt;Fact = FACTORED and equed = 'C' or 'B', each element
            of C must be positive.</pre><pre>L          (output) SuperMatrix*
        The factor L from the factorization
            Pr*A*Pc=L*U         (if A-&gt;Stype SLU_= NC) or
            Pr*transpose(A)*Pc=L*U      (if A-&gt;Stype = SLU_NR).
        Uses compressed row subscripts storage for supernodes, i.e.,
        L has types: Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>U          (output) SuperMatrix*
        The factor U from the factorization
            Pr*A*Pc=L*U         (if A-&gt;Stype = SLU_NC) or
            Pr*transpose(A)*Pc=L*U      (if A-&gt;Stype = SLU_NR).
        Uses column-wise storage scheme, i.e., U has types:
        Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>work    (workspace/output) void*, size (lwork) (in bytes)
        User supplied workspace, should be large enough
        to hold data structures for factors L and U.
        On exit, if fact is not 'F', L and U point to this array.</pre><pre>lwork   (input) int
        Specifies the size of work array in bytes.
        = 0:  allocate space internally by system malloc;
        &gt; 0:  use user-supplied work array of length lwork in bytes,
         returns error if space runs out.
        = -1: the routine guesses the amount of space needed without
         performing the factorization, and returns it in
         mem_usage-&gt;total_needed; no other side effects.</pre><pre>        See argument 'mem_usage' for memory usage statistics.</pre><pre>B          (input/output) SuperMatrix*
        B has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
        On entry, the right hand side matrix.
        If B-&gt;ncol = 0, only LU decomposition is performed, the triangular
                   solve is skipped.
        On exit,
           if equed = 'N', B is not modified; otherwise
           if A-&gt;Stype = SLU_NC:
         if options-&gt;Trans = NOTRANS and equed = 'R' or 'B',
            B is overwritten by diag(R)*B;
         if options-&gt;Trans = TRANS or CONJ and equed = 'C' of 'B',
            B is overwritten by diag(C)*B;
           if A-&gt;Stype = SLU_NR:
         if options-&gt;Trans = NOTRANS and equed = 'C' or 'B',
            B is overwritten by diag(C)*B;
         if options-&gt;Trans = TRANS or CONJ and equed = 'R' of 'B',
            B is overwritten by diag(R)*B.</pre><pre>X          (output) SuperMatrix*
        X has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
        If info = 0 or info = A-&gt;ncol+1, X contains the solution matrix
        to the original system of equations. Note that A and B are modified
        on exit if equed is not 'N', and the solution to the equilibrated
        system is inv(diag(C))*X if options-&gt;Trans = NOTRANS and
        equed = 'C' or 'B', or inv(diag(R))*X if options-&gt;Trans = 'T' or 'C'
        and equed = 'R' or 'B'.</pre><pre>recip_pivot_growth (output) float*
        The reciprocal pivot growth factor max_j( norm(A_j)/norm(U_j) ).
        The infinity norm is used. If recip_pivot_growth is much less
        than 1, the stability of the LU factorization could be poor.</pre><pre>rcond   (output) float*
        The estimate of the reciprocal condition number of the matrix A
        after equilibration (if done). If rcond is less than the machine
        precision (in particular, if rcond = 0), the matrix is singular
        to working precision. This condition is indicated by a return
        code of info &gt; 0.</pre><pre>mem_usage (output) mem_usage_t*
        Record the memory usage statistics, consisting of following fields:</p>
<ul>
<li>for_lu (float)
          The amount of space used in bytes for L data structures.</li>
<li>total_needed (float)
          The amount of space needed in bytes to perform factorization.</li>
<li>expansions (int)
          The number of memory expansions during the LU factorization.</li>
</ul>
</pre><pre>stat   (output) SuperLUStat_t*
       Record the statistics on runtime and floating-point operation count.
       See <a class="el" href="slu__util_8h.html" title="Utility header file. ">slu_util.h</a> for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>info    (output) int*
        = 0: successful exit
        &lt; 0: if info = -i, the i-th argument had an illegal value
        &gt; 0: if info = i, and i is
        &lt;= A-&gt;ncol: number of zero pivots. They are replaced by small
              entries due to options-&gt;ILU_FillTol.
        = A-&gt;ncol+1: U is nonsingular, but RCOND is less than machine
              precision, meaning that the matrix is singular to
              working precision. Nevertheless, the solution and
              error bounds are computed because there are a number
              of situations where the computed solution can be more
              accurate than the value of RCOND would suggest.
        &gt; A-&gt;ncol+1: number of bytes allocated when memory allocation
              failure occurred, plus A-&gt;ncol.
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a30fcf6fe814189a632a72220d5a303f8_cgraph.png" border="0" usemap="#slu__sdefs_8h_a30fcf6fe814189a632a72220d5a303f8_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a30fcf6fe814189a632a72220d5a303f8_cgraph" id="slu__sdefs_8h_a30fcf6fe814189a632a72220d5a303f8_cgraph">
<area shape="rect" id="node2" href="slangs_8c.html#a201bfd9f2017cf5904aada9f21f23ab2" title="slangs" alt="" coords="182,5,242,32"/><area shape="rect" id="node3" href="slu__cdefs_8h.html#a1b49252f1cab66e35ac47ac1afb2adec" title="smach" alt="" coords="604,157,665,184"/><area shape="rect" id="node4" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="739,613,821,640"/><area shape="rect" id="node5" href="slu__util_8h.html#a72be96e75e58564c4322ef9ef73ca65f" title="sp_ienv" alt="" coords="601,613,668,640"/><area shape="rect" id="node6" href="slu__sdefs_8h.html#abb3d30eea43abc536793244e7564e70d" title="Supernodal LU factor related. " alt="" coords="357,1424,531,1451"/><area shape="rect" id="node7" href="slu__util_8h.html#a0c6777573bbfe81917cd381e0090d355" title="Timer function. " alt="" coords="386,1829,502,1856"/><area shape="rect" id="node8" href="memory_8c.html#a49bbe20102e5b541c8e8963afa2bd46a" title="intMalloc" alt="" coords="597,1348,672,1375"/><area shape="rect" id="node9" href="sldperm_8c.html#a6c181d905cb61481e86ddfce701e74a0" title="sldperm" alt="" coords="178,1677,246,1704"/><area shape="rect" id="node13" href="sgsequ_8c.html#ad8a808e807e38c32c08cfbeadb088f08" title="Driver related. " alt="" coords="412,56,476,83"/><area shape="rect" id="node14" href="slaqgs_8c.html#af44216962efdebc7e1117b273743e84f" title="slaqgs" alt="" coords="182,157,242,184"/><area shape="rect" id="node15" href="get__perm__c_8c.html#aaecb6e6e7a3e97356050bcfdf2573796" title="get_perm_c" alt="" coords="167,1905,257,1932"/><area shape="rect" id="node20" href="slu__util_8h.html#adf9c573cbfb4520a5ea820702d27cfa5" title="sp_preorder" alt="" coords="167,2083,257,2109"/><area shape="rect" id="node26" href="sgsitrf_8c.html#a8c16e3d29bb8fbcc614ed6f77372b616" title="sgsitrf" alt="" coords="183,968,241,995"/><area shape="rect" id="node45" href="slu__sdefs_8h.html#acb8787465a6296109b9a306d5a315ff8" title="sPivotGrowth" alt="" coords="161,107,263,133"/><area shape="rect" id="node46" href="sgscon_8c.html#a76b21c7561d5bce81821a76c3465601b" title="sgscon" alt="" coords="412,664,476,691"/><area shape="rect" id="node47" href="sgstrs_8c.html#a9b6e1e555af9cf109ef3a584054a91e2" title="sgstrs" alt="" coords="183,1475,241,1501"/><area shape="rect" id="node48" href="slu__sdefs_8h.html#adb260ae3f26e2179b1cf33c3e754d6f1" title="ilu_sQuerySpace" alt="" coords="151,625,273,652"/><area shape="rect" id="node49" href="slu__util_8h.html#a4de38e1c0ef18dd0791cb206c7f5348f" title="A is of type Stype==NCP. " alt="" coords="115,2133,309,2160"/><area shape="rect" id="node50" href="slu__util_8h.html#a2c43be55861c6e4ee5b806ac16cc382c" title="Deallocate the structure pointing to the actual storage of the matrix. " alt="" coords="139,2185,285,2226"/><area shape="rect" id="node10" href="slu__util_8h.html#ade363dcb4babb66fa0e5f51bd2e6e42c" title="slu_PrintInt10" alt="" coords="393,1728,495,1755"/><area shape="rect" id="node11" href="sldperm_8c.html#a1e6fb0c8dd36aef071ef165136ece781" title="mc64id_" alt="" coords="409,1779,479,1805"/><area shape="rect" id="node12" href="sldperm_8c.html#a1bf33c16a135cdc671242aed1705e1cd" title="mc64ad_" alt="" coords="407,1677,481,1704"/><area shape="rect" id="node16" href="get__perm__c_8c.html#a90f30e2b284864f6a800a98ceaff8fbc" title="getata" alt="" coords="415,1880,473,1907"/><area shape="rect" id="node17" href="get__perm__c_8c.html#a486ee50799ff66abe91efa46a5950a57" title="at_plus_a" alt="" coords="405,2032,483,2059"/><area shape="rect" id="node18" href="get__perm__c_8c.html#ae92c26cd488b7a86b8277cee2773d8ef" title="get_colamd" alt="" coords="399,1931,489,1957"/><area shape="rect" id="node19" href="get__perm__c_8c.html#a792508355b6bef974fcd9e214de40c8e" title="genmmd_" alt="" coords="405,1981,483,2008"/><area shape="rect" id="node21" href="slu__util_8h.html#a8a3ba6cbe163f9c12f6f10ee8ba98fc7" title="print_int_vec" alt="" coords="396,2133,492,2160"/><area shape="rect" id="node22" href="sp__preorder_8c.html#ac79059104ae6abf212c41986820d358c" title="check_perm" alt="" coords="397,2184,491,2211"/><area shape="rect" id="node23" href="sp__coletree_8c.html#a657d6b291654432e815392c2a00d2b84" title="sp_symetree" alt="" coords="395,2235,493,2261"/><area shape="rect" id="node24" href="slu__util_8h.html#af8198f26bef3c82fbb8601fc5a8e0d9e" title="sp_coletree" alt="" coords="399,2285,489,2312"/><area shape="rect" id="node25" href="slu__util_8h.html#a44084fde835d2ccaa25e9fd942a72b7a" title="TreePostorder" alt="" coords="583,1880,687,1907"/><area shape="rect" id="node27" href="slu__sdefs_8h.html#af68715ec86cde90aa31fec07164d6ea6" title="Memory&#45;related. " alt="" coords="397,1171,491,1197"/><area shape="rect" id="node28" href="memory_8c.html#adbbe5a57b4ed64564c887fb52d798c54" title="Set up pointers for integer working arrays. " alt="" coords="405,1019,483,1045"/><area shape="rect" id="node29" href="slu__util_8h.html#ab0dfb6551008bcad5e758defdbd13006" title="Fills an integer array with a given value. " alt="" coords="615,1095,654,1121"/><area shape="rect" id="node30" href="slu__sdefs_8h.html#ab5b2859bf1ef1900506dfa702574c6ad" title="Set up pointers for real working arrays. " alt="" coords="399,816,489,843"/><area shape="rect" id="node31" href="slu__cdefs_8h.html#a42361c3ce2ba81d149ffba01fbd6f138" title="floatMalloc" alt="" coords="401,1475,487,1501"/><area shape="rect" id="node32" href="ilu__heap__relax__snode_8c.html#aac1a978dda622cdb58c3c2eaee4b4030" title="ilu_heap_relax_snode" alt="" coords="371,1373,517,1400"/><area shape="rect" id="node33" href="ilu__relax__snode_8c.html#ae0e2bbb8507d800766030635a3bd5a7e" title="ilu_relax_snode" alt="" coords="388,1069,500,1096"/><area shape="rect" id="node34" href="mark__relax_8c.html#a5e85b0273eec011f0027d8506a20350e" title="mark_relax" alt="" coords="401,968,487,995"/><area shape="rect" id="node35" href="ilu__sdrop__row_8c.html#a0d9b169f47790d6eed41107efb445867" title="ilu_sdrop_row" alt="" coords="393,1221,495,1248"/><area shape="rect" id="node36" href="ilu__ssnode__dfs_8c.html#a510a9174e442a65aaa83f9ce97390f85" title="ilu_ssnode_dfs" alt="" coords="389,360,499,387"/><area shape="rect" id="node37" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7" title="Expand the data structures for L and U during the factorization. " alt="" coords="579,411,691,437"/><area shape="rect" id="node38" href="slu__sdefs_8h.html#a60e60255360fae0b1458da070690a3a2" title="Performs numeric block updates within the relaxed snode. " alt="" coords="393,1272,495,1299"/><area shape="rect" id="node39" href="ilu__spivotL_8c.html#a9da652b68b6ecee45919cf56f256b7e0" title="ilu_spivotL" alt="" coords="402,715,486,741"/><area shape="rect" id="node40" href="ilu__spanel__dfs_8c.html#afffee4e945eab223be6daa1759e98f60" title="ilu_spanel_dfs" alt="" coords="391,765,497,792"/><area shape="rect" id="node41" href="slu__sdefs_8h.html#a51486936a9ff5079afed80eb5bf8a3e0" title="spanel_bmod" alt="" coords="395,867,493,893"/><area shape="rect" id="node42" href="ilu__scolumn__dfs_8c.html#a7cca59251907bd7e1973d394487f74af" title="ilu_scolumn_dfs" alt="" coords="386,613,502,640"/><area shape="rect" id="node43" href="scolumn__bmod_8c.html#ac89043410fd16fe2b8d3b2c902fec9f7" title="scolumn_bmod" alt="" coords="389,563,499,589"/><area shape="rect" id="node44" href="ilu__scopy__to__ucol_8c.html#aac49754df15a9466857a0eca885f9444" title="ilu_scopy_to_ucol" alt="" coords="381,309,507,336"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="acaa9941535fb0b2fdbd7b3287da5f2a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgsitrf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>relax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>etree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>SGSITRF computes an ILU factorization of a general sparse m-by-n
matrix A using partial pivoting with row interchanges.
The factorization has the form
    Pr * A = L * U
where Pr is a row permutation matrix, L is lower triangular with unit
diagonal elements (lower trapezoidal if A-&gt;nrow &gt; A-&gt;ncol), and U is upper
triangular (upper trapezoidal if A-&gt;nrow &lt; A-&gt;ncol).</pre><pre>See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>options (input) superlu_options_t*
        The structure defines the input parameters to control
        how the ILU decomposition will be performed.</pre><pre>A           (input) SuperMatrix*
         Original matrix A, permuted by columns, of dimension
         (A-&gt;nrow, A-&gt;ncol). The type of A can be:
         Stype = SLU_NCP; Dtype = SLU_S; Mtype = SLU_GE.</pre><pre>relax    (input) int
         To control degree of relaxing supernodes. If the number
         of nodes (columns) in a subtree of the elimination tree is less
         than relax, this subtree is considered as one supernode,
         regardless of the row structures of those columns.</pre><pre>panel_size (input) int
         A panel consists of at most panel_size consecutive columns.</pre><pre>etree    (input) int*, dimension (A-&gt;ncol)
         Elimination tree of A'*A.
         Note: etree is a vector of parent pointers for a forest whose
         vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.
         On input, the columns of A should be permuted so that the
         etree is in a certain postorder.</pre><pre>work     (input/output) void*, size (lwork) (in bytes)
         User-supplied work space and space for the output data structures.
         Not referenced if lwork = 0;</pre><pre>lwork   (input) int
        Specifies the size of work array in bytes.
        = 0:  allocate space internally by system malloc;
        &gt; 0:  use user-supplied work array of length lwork in bytes,
         returns error if space runs out.
        = -1: the routine guesses the amount of space needed without
         performing the factorization, and returns it in
         *info; no other side effects.</pre><pre>perm_c   (input) int*, dimension (A-&gt;ncol)
         Column permutation vector, which defines the
         permutation matrix Pc; perm_c[i] = j means column i of A is
         in position j in A*Pc.
         When searching for diagonal, perm_c[*] is applied to the
         row subscripts of A, so that diagonal threshold pivoting
         can find the diagonal of A, rather than that of A*Pc.</pre><pre>perm_r   (input/output) int*, dimension (A-&gt;nrow)
         Row permutation vector which defines the permutation matrix Pr,
         perm_r[i] = j means row i of A is in position j in Pr*A.
         If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
            will try to use the input perm_r, unless a certain threshold
            criterion is violated. In that case, perm_r is overwritten by
            a new permutation determined by partial pivoting or diagonal
            threshold pivoting.
         Otherwise, perm_r is output argument;</pre><pre>L           (output) SuperMatrix*
         The factor L from the factorization Pr*A=L*U; use compressed row
         subscripts storage for supernodes, i.e., L has type:
         Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>U           (output) SuperMatrix*
         The factor U from the factorization Pr*A*Pc=L*U. Use column-wise
         storage scheme, i.e., U has types: Stype = SLU_NC,
         Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>Glu      (input/output) <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *
         If options-&gt;Fact == SamePattern_SameRowPerm, it is an input;
             The matrix A will be factorized assuming that a 
             factorization of a matrix with the same sparsity pattern
             and similar numerical values was performed prior to this one.
             Therefore, this factorization will reuse both row and column
        scaling factors R and C, both row and column permutation
        vectors perm_r and perm_c, and the L &amp; U data structures
        set up from the previous factorization.
         Otherwise, it is an output.</pre><pre>stat     (output) SuperLUStat_t*
         Record the statistics on runtime and floating-point operation count.
         See <a class="el" href="slu__util_8h.html" title="Utility header file. ">slu_util.h</a> for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>info     (output) int*
         = 0: successful exit
         &lt; 0: if info = -i, the i-th argument had an illegal value
         &gt; 0: if info = i, and i is
            &lt;= A-&gt;ncol: number of zero pivots. They are replaced by small
          entries according to options-&gt;ILU_FillTol.
            &gt; A-&gt;ncol: number of bytes allocated when memory allocation
          failure occurred, plus A-&gt;ncol. If lwork = -1, it is
          the estimated amount of space needed, plus A-&gt;ncol.
</p>
<hr/>
</pre><pre><h1>Local Working Arrays:
</h1>
</pre><pre>
  m = number of rows in the matrix
  n = number of columns in the matrix</pre><pre>  marker[0:3*m-1]: marker[i] = j means that node i has been
     reached when working on column j.
     Storage: relative to original row subscripts
     NOTE: There are 4 of them:
           marker/marker1 are used for panel dfs, see (ilu_)<a class="el" href="dpanel__dfs_8c.html" title="Peforms a symbolic factorization on a panel of symbols. ">dpanel_dfs.c</a>;
           marker2 is used for inner-factorization, see (ilu)_dcolumn_dfs.c;
           marker_relax(has its own space) is used for relaxed supernodes.</pre><pre>  parent[0:m-1]: parent vector used during dfs
     Storage: relative to new row subscripts</pre><pre>  xplore[0:m-1]: xplore[i] gives the location of the next (dfs)
     unexplored neighbor of i in lsub[*]</pre><pre>  segrep[0:nseg-1]: contains the list of supernodal representatives
     in topological order of the dfs. A supernode representative is the
     last column of a supernode.
     The maximum size of segrep[] is n.</pre><pre>  repfnz[0:W*m-1]: for a nonzero segment U[*,j] that ends at a
     supernodal representative r, repfnz[r] is the location of the first
     nonzero in this segment.  It is also used during the dfs: repfnz[r]&gt;0
     indicates the supernode r has been explored.
     NOTE: There are W of them, each used for one column of a panel.</pre><pre>  panel_lsub[0:W*m-1]: temporary for the nonzeros row indices below
     the panel diagonal. These are filled in during <a class="el" href="dpanel__dfs_8c.html#a2a809488b87d2c1a9b2a574b726e8517">dpanel_dfs()</a>, and are
     used later in the inner LU factorization within the panel.
     panel_lsub[]/dense[] pair forms the SPA data structure.
     NOTE: There are W of them.</pre><pre>  dense[0:W*m-1]: sparse accumulating (SPA) vector for intermediate values;
           NOTE: there are W of them.</pre><pre>  tempv[0:*]: real temporary used for dense numeric kernels;
     The size of this array is defined by <a class="el" href="slu__util_8h.html#a06193b28f40a4779ae7737711642eb45">NUM_TEMPV()</a> in <a class="el" href="slu__util_8h.html" title="Utility header file. ">slu_util.h</a>.
     It is also used by the dropping routine <a class="el" href="ilu__ddrop__row_8c.html#a380317801e05b11930fd1e094db34179">ilu_ddrop_row()</a>.
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_acaa9941535fb0b2fdbd7b3287da5f2a0_cgraph.png" border="0" usemap="#slu__sdefs_8h_acaa9941535fb0b2fdbd7b3287da5f2a0_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_acaa9941535fb0b2fdbd7b3287da5f2a0_cgraph" id="slu__sdefs_8h_acaa9941535fb0b2fdbd7b3287da5f2a0_cgraph">
<area shape="rect" id="node2" href="slu__sdefs_8h.html#af68715ec86cde90aa31fec07164d6ea6" title="Memory&#45;related. " alt="" coords="157,309,251,336"/><area shape="rect" id="node4" href="memory_8c.html#a49bbe20102e5b541c8e8963afa2bd46a" title="intMalloc" alt="" coords="363,56,437,83"/><area shape="rect" id="node10" href="slu__util_8h.html#a72be96e75e58564c4322ef9ef73ca65f" title="sp_ienv" alt="" coords="531,867,597,893"/><area shape="rect" id="node12" href="memory_8c.html#adbbe5a57b4ed64564c887fb52d798c54" title="Set up pointers for integer working arrays. " alt="" coords="165,157,243,184"/><area shape="rect" id="node13" href="slu__util_8h.html#ab0dfb6551008bcad5e758defdbd13006" title="Fills an integer array with a given value. " alt="" coords="381,107,419,133"/><area shape="rect" id="node14" href="slu__sdefs_8h.html#ab5b2859bf1ef1900506dfa702574c6ad" title="Set up pointers for real working arrays. " alt="" coords="159,968,249,995"/><area shape="rect" id="node16" href="slu__cdefs_8h.html#a42361c3ce2ba81d149ffba01fbd6f138" title="floatMalloc" alt="" coords="161,1069,247,1096"/><area shape="rect" id="node17" href="ilu__heap__relax__snode_8c.html#aac1a978dda622cdb58c3c2eaee4b4030" title="ilu_heap_relax_snode" alt="" coords="131,56,277,83"/><area shape="rect" id="node19" href="ilu__relax__snode_8c.html#ae0e2bbb8507d800766030635a3bd5a7e" title="ilu_relax_snode" alt="" coords="148,208,260,235"/><area shape="rect" id="node20" href="mark__relax_8c.html#a5e85b0273eec011f0027d8506a20350e" title="mark_relax" alt="" coords="161,1120,247,1147"/><area shape="rect" id="node21" href="ilu__sdrop__row_8c.html#a0d9b169f47790d6eed41107efb445867" title="ilu_sdrop_row" alt="" coords="153,1019,255,1045"/><area shape="rect" id="node30" href="ilu__ssnode__dfs_8c.html#a510a9174e442a65aaa83f9ce97390f85" title="ilu_ssnode_dfs" alt="" coords="149,512,259,539"/><area shape="rect" id="node31" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7" title="Expand the data structures for L and U during the factorization. " alt="" coords="344,461,456,488"/><area shape="rect" id="node32" href="slu__sdefs_8h.html#a60e60255360fae0b1458da070690a3a2" title="Performs numeric block updates within the relaxed snode. " alt="" coords="153,664,255,691"/><area shape="rect" id="node37" href="ilu__spivotL_8c.html#a9da652b68b6ecee45919cf56f256b7e0" title="ilu_spivotL" alt="" coords="162,1171,246,1197"/><area shape="rect" id="node38" href="ilu__spanel__dfs_8c.html#afffee4e945eab223be6daa1759e98f60" title="ilu_spanel_dfs" alt="" coords="151,1221,257,1248"/><area shape="rect" id="node39" href="slu__sdefs_8h.html#a51486936a9ff5079afed80eb5bf8a3e0" title="spanel_bmod" alt="" coords="155,791,253,817"/><area shape="rect" id="node42" href="ilu__scolumn__dfs_8c.html#a7cca59251907bd7e1973d394487f74af" title="ilu_scolumn_dfs" alt="" coords="146,563,262,589"/><area shape="rect" id="node43" href="scolumn__bmod_8c.html#ac89043410fd16fe2b8d3b2c902fec9f7" title="scolumn_bmod" alt="" coords="149,613,259,640"/><area shape="rect" id="node44" href="ilu__scopy__to__ucol_8c.html#aac49754df15a9466857a0eca885f9444" title="ilu_scopy_to_ucol" alt="" coords="141,867,267,893"/><area shape="rect" id="node45" href="slu__util_8h.html#ab71db926d60d7b8fd739df197b766366" title="Reset repfnz[] for the current column. " alt="" coords="157,1272,251,1299"/><area shape="rect" id="node46" href="slu__cdefs_8h.html#aae8eb367a0a2fcdf734738bc9630df85" title="Count the total number of nonzeros in factors L and U. " alt="" coords="160,1323,248,1349"/><area shape="rect" id="node47" href="slu__cdefs_8h.html#a7061332d759d7e4d73c1b2e5cb0bf2bf" title="Fix up the data storage lsub for L&#45;subscripts. It removes the subscript sets for structural pruning..." alt="" coords="175,1373,233,1400"/><area shape="rect" id="node48" href="slu__sdefs_8h.html#a9035f0d2a50cf5d8e29287572bd1be83" title="Free the working storage used by factor routines. " alt="" coords="153,1424,255,1451"/><area shape="rect" id="node49" href="slu__sdefs_8h.html#af4386b0d87e1c8886b58fcf9d243bc12" title="sCreate_SuperNode_Matrix" alt="" coords="113,1475,295,1501"/><area shape="rect" id="node50" href="slu__sdefs_8h.html#abb3d30eea43abc536793244e7564e70d" title="Supernodal LU factor related. " alt="" coords="117,1525,291,1552"/><area shape="rect" id="node3" href="smemory_8c.html#a146216d4543e94e7ec4783eada50bf4c" title="Setup the memory model to be used for factorization. " alt="" coords="350,208,450,235"/><area shape="rect" id="node5" href="smemory_8c.html#ad68adc1b6de3f821f9fb24cdcf24d281" title="suser_malloc" alt="" coords="672,309,771,336"/><area shape="rect" id="node6" href="smemory_8c.html#aa2862f14356be7d9f12bfdfc175137a1" title="Expand the existing storage to accommodate more fill&#45;ins. " alt="" coords="529,360,599,387"/><area shape="rect" id="node7" href="smemory_8c.html#a29f7485dd32f85e996e16f2a199b002d" title="suser_free" alt="" coords="359,157,441,184"/><area shape="rect" id="node8" href="smemory_8c.html#a658f955c5532813bd0490502efae563f" title="smemory_usage" alt="" coords="505,436,623,463"/><area shape="rect" id="node9" href="smemory_8c.html#abc603ef3859778fb5631cf3d3b951de6" title="Allocate known working storage. Returns 0 if success, otherwise returns the number of bytes allocated..." alt="" coords="353,309,447,336"/><area shape="rect" id="node11" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="680,867,763,893"/><area shape="rect" id="node15" href="slu__sdefs_8h.html#a2d734e40276e89a3ef04bf79bc21acb6" title="Fills a float precision array with a given value. " alt="" coords="379,968,421,995"/><area shape="rect" id="node18" href="slu__util_8h.html#a44084fde835d2ccaa25e9fd942a72b7a" title="TreePostorder" alt="" coords="348,5,452,32"/><area shape="rect" id="node22" href="ilu__sdrop__row_8c.html#a43ef780d8b669dc0b19d41fa6727124f" title="sasum_" alt="" coords="366,1323,434,1349"/><area shape="rect" id="node23" href="ilu__sdrop__row_8c.html#ac419c8b8797339212c62cd423e3e652c" title="snrm2_" alt="" coords="367,1373,433,1400"/><area shape="rect" id="node24" href="ilu__sdrop__row_8c.html#a18eff2aa758918dee76e31b812c88c9f" title="isamax_" alt="" coords="365,1424,435,1451"/><area shape="rect" id="node25" href="ilu__sdrop__row_8c.html#ade8ba65d9c44f41e97cf2c40a772cff7" title="saxpy_" alt="" coords="368,1120,432,1147"/><area shape="rect" id="node26" href="ilu__sdrop__row_8c.html#af839d60e0d4028df30ea1106ce429210" title="scopy_" alt="" coords="368,1171,432,1197"/><area shape="rect" id="node27" href="ilu__sdrop__row_8c.html#a2ea44e9849dcb189a4e81f09d97e3c95" title="sswap_" alt="" coords="367,1221,433,1248"/><area shape="rect" id="node28" href="qselect_8c.html#a5a36bc5d24fe074bc4f3cfb65d7f0ae8" title="sqselect" alt="" coords="365,1019,435,1045"/><area shape="rect" id="node29" href="ilu__sdrop__row_8c.html#a8ddf1742e9078a786574bb5aa80aed2a" title="_compare_" alt="" coords="357,1272,443,1299"/><area shape="rect" id="node33" href="slu__sdefs_8h.html#aab583b502d3953688a3fa27a9f4bbf1e" title="strsv_" alt="" coords="371,664,429,691"/><area shape="rect" id="node34" href="slu__sdefs_8h.html#ae29fbdb32369b70973b05d14fc3420c9" title="sgemv_" alt="" coords="366,715,434,741"/><area shape="rect" id="node35" href="scolumn__bmod_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="369,613,431,640"/><area shape="rect" id="node36" href="scolumn__bmod_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="364,563,436,589"/><area shape="rect" id="node40" href="spanel__bmod_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="369,816,431,843"/><area shape="rect" id="node41" href="spanel__bmod_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="364,765,436,792"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae824bcb507f76ad3053d845352fb6b3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgsrfs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose   
</h1>
</pre><pre></pre><pre>  SGSRFS improves the computed solution to a system of linear   
  equations and provides error bounds and backward error estimates for 
  the solution.</pre><pre>  If equilibration was performed, the system becomes:
          (diag(R)*A_original*diag(C)) * X = diag(R)*B_original.</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments   
</h1>
</pre><pre></pre><pre>trans   (input) trans_t
         Specifies the form of the system of equations:
         = NOTRANS: A * X = B  (No transpose)
         = TRANS:   A'* X = B  (Transpose)
         = CONJ:    A**H * X = B  (Conjugate transpose)</pre><pre>  A       (input) SuperMatrix*
          The original matrix A in the system, or the scaled A if
          equilibration was done. The type of A can be:
          Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_GE.</pre><pre>  L       (input) SuperMatrix*
          The factor L from the factorization Pr*A*Pc=L*U. Use
          compressed row subscripts storage for supernodes, 
          i.e., L has types: Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>  U       (input) SuperMatrix*
          The factor U from the factorization Pr*A*Pc=L*U as computed by
          <a class="el" href="sgstrf_8c.html#a7f9874cec10809f11998cc3d9cb88f8b">sgstrf()</a>. Use column-wise storage scheme, 
          i.e., U has types: Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>  perm_c  (input) int*, dimension (A-&gt;ncol)
          Column permutation vector, which defines the 
          permutation matrix Pc; perm_c[i] = j means column i of A is 
          in position j in A*Pc.</pre><pre>  perm_r  (input) int*, dimension (A-&gt;nrow)
          Row permutation vector, which defines the permutation matrix Pr;
          perm_r[i] = j means row i of A is in position j in Pr*A.</pre><pre>  equed   (input) Specifies the form of equilibration that was done.
          = 'N': No equilibration.
          = 'R': Row equilibration, i.e., A was premultiplied by diag(R).
          = 'C': Column equilibration, i.e., A was postmultiplied by
                 diag(C).
          = 'B': Both row and column equilibration, i.e., A was replaced 
                 by diag(R)*A*diag(C).</pre><pre>  R       (input) float*, dimension (A-&gt;nrow)
          The row scale factors for A.
          If equed = 'R' or 'B', A is premultiplied by diag(R).
          If equed = 'N' or 'C', R is not accessed.</pre><pre>  C       (input) float*, dimension (A-&gt;ncol)
          The column scale factors for A.
          If equed = 'C' or 'B', A is postmultiplied by diag(C).
          If equed = 'N' or 'R', C is not accessed.</pre><pre>  B       (input) SuperMatrix*
          B has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
          The right hand side matrix B.
          if equed = 'R' or 'B', B is premultiplied by diag(R).</pre><pre>  X       (input/output) SuperMatrix*
          X has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
          On entry, the solution matrix X, as computed by <a class="el" href="sgstrs_8c.html#a9b6e1e555af9cf109ef3a584054a91e2">sgstrs()</a>.
          On exit, the improved solution matrix X.
          if *equed = 'C' or 'B', X should be premultiplied by diag(C)
              in order to obtain the solution to the original system.</pre><pre>  FERR    (output) float*, dimension (B-&gt;ncol)   
          The estimated forward error bound for each solution vector   
          X(j) (the j-th column of the solution matrix X).   
          If XTRUE is the true solution corresponding to X(j), FERR(j) 
          is an estimated upper bound for the magnitude of the largest 
          element in (X(j) - XTRUE) divided by the magnitude of the   
          largest element in X(j).  The estimate is as reliable as   
          the estimate for RCOND, and is almost always a slight   
          overestimate of the true error.</pre><pre>  BERR    (output) float*, dimension (B-&gt;ncol)   
          The componentwise relative backward error of each solution   
          vector X(j) (i.e., the smallest relative change in   
          any element of A or B that makes X(j) an exact solution).</pre><pre>  stat     (output) SuperLUStat_t*
           Record the statistics on runtime and floating-point operation count.
           See util.h for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>  info    (output) int*   
          = 0:  successful exit   
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value</pre><pre><h1>Internal Parameters   
</h1>
</pre><pre></pre><pre>   ITMAX is the maximum number of steps of iterative refinement.</pre><pre></pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_ae824bcb507f76ad3053d845352fb6b3d_cgraph.png" border="0" usemap="#slu__sdefs_8h_ae824bcb507f76ad3053d845352fb6b3d_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_ae824bcb507f76ad3053d845352fb6b3d_cgraph" id="slu__sdefs_8h_ae824bcb507f76ad3053d845352fb6b3d_cgraph">
<area shape="rect" id="node2" href="slacon2_8c.html#ad34d61602254b2aad398e30cc3c5436d" title="slacon2_" alt="" coords="116,107,191,133"/><area shape="rect" id="node5" href="ilu__scopy__to__ucol_8c.html#af839d60e0d4028df30ea1106ce429210" title="scopy_" alt="" coords="253,157,317,184"/><area shape="rect" id="node7" href="ilu__sdrop__row_8c.html#ade8ba65d9c44f41e97cf2c40a772cff7" title="saxpy_" alt="" coords="121,208,185,235"/><area shape="rect" id="node8" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="377,309,460,336"/><area shape="rect" id="node9" href="slu__cdefs_8h.html#a42361c3ce2ba81d149ffba01fbd6f138" title="floatMalloc" alt="" coords="243,360,328,387"/><area shape="rect" id="node10" href="memory_8c.html#a49bbe20102e5b541c8e8963afa2bd46a" title="intMalloc" alt="" coords="116,563,191,589"/><area shape="rect" id="node11" href="slu__cdefs_8h.html#a1b49252f1cab66e35ac47ac1afb2adec" title="smach" alt="" coords="123,613,184,640"/><area shape="rect" id="node12" href="slu__sdefs_8h.html#a9e543b2d14781b56ef349114012b4fc9" title="Performs one of the matrix&#45;vector operations y := alpha*A*x + beta*y, or y := alpha*A&#39;*x + beta*y..." alt="" coords="112,309,195,336"/><area shape="rect" id="node13" href="sgstrs_8c.html#a9b6e1e555af9cf109ef3a584054a91e2" title="sgstrs" alt="" coords="124,512,183,539"/><area shape="rect" id="node3" href="ilu__sdrop__row_8c.html#a18eff2aa758918dee76e31b812c88c9f" title="isamax_" alt="" coords="250,5,321,32"/><area shape="rect" id="node4" href="ilu__sdrop__row_8c.html#a43ef780d8b669dc0b19d41fa6727124f" title="sasum_" alt="" coords="251,56,319,83"/><area shape="rect" id="node6" href="ilu__ddrop__row_8c.html#afdb24942915626f5de65c50cb31c267a" title="idamax_" alt="" coords="250,107,321,133"/><area shape="rect" id="node14" href="sgstrs_8c.html#ad582f185cce067a3f9dd4225248af758" title="sprint_soln" alt="" coords="243,512,328,539"/><area shape="rect" id="node15" href="slu__cdefs_8h.html#a3e1230bff11a9e47c35555299bcdcf1b" title="floatCalloc" alt="" coords="377,613,461,640"/><area shape="rect" id="node16" href="slu__sdefs_8h.html#a68de665c44346f6eacfe87e9f3c2a1e6" title="strsm_" alt="" coords="254,613,317,640"/><area shape="rect" id="node17" href="slu__sdefs_8h.html#ab822504d3d60a944da04997b4f91e067" title="BLAS. " alt="" coords="249,664,321,691"/><area shape="rect" id="node18" href="sgstrs_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="254,715,317,741"/><area shape="rect" id="node19" href="sgstrs_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="249,765,321,792"/><area shape="rect" id="node20" href="sgstrs_8c.html#a25ea48f4f948c68a423f5bd3929e3c1f" title="Solves a dense upper triangular system. " alt="" coords="252,816,319,843"/><area shape="rect" id="node21" href="slu__sdefs_8h.html#aa6d287b6b9bcaf72a692343e614c429c" title="Solves one of the systems of equations A*x = b, or A&#39;*x = b. " alt="" coords="249,461,321,488"/><area shape="rect" id="node22" href="slu__sdefs_8h.html#aab583b502d3953688a3fa27a9f4bbf1e" title="strsv_" alt="" coords="389,360,448,387"/><area shape="rect" id="node23" href="slu__sdefs_8h.html#ae29fbdb32369b70973b05d14fc3420c9" title="sgemv_" alt="" coords="385,411,453,437"/><area shape="rect" id="node24" href="ssp__blas2_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="387,461,450,488"/><area shape="rect" id="node25" href="ssp__blas2_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="383,512,455,539"/><area shape="rect" id="node26" href="ssp__blas2_8c.html#a25ea48f4f948c68a423f5bd3929e3c1f" title="Solves a dense upper triangular system. " alt="" coords="385,563,452,589"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a44bbae3b1218d951ed229c461a5f14b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgssv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>SGSSV solves the system of linear equations A*X=B, using the
LU factorization from SGSTRF. It performs the following steps:</pre><pre>  1. If A is stored column-wise (A-&gt;Stype = SLU_NC):</pre><pre>     1.1. Permute the columns of A, forming A*Pc, where Pc
          is a permutation matrix. For more details of this step, 
          see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix. ">sp_preorder.c</a>.</pre><pre>     1.2. Factor A as Pr*A*Pc=L*U with the permutation Pr determined
          by Gaussian elimination with partial pivoting.
          L is unit lower triangular with offdiagonal entries
          bounded by 1 in magnitude, and U is upper triangular.</pre><pre>     1.3. Solve the system of equations A*X=B using the factored
          form of A.</pre><pre>  2. If A is stored row-wise (A-&gt;Stype = SLU_NR), apply the
     above algorithm to the transpose of A:</pre><pre>     2.1. Permute columns of transpose(A) (rows of A),
          forming transpose(A)*Pc, where Pc is a permutation matrix. 
          For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix. ">sp_preorder.c</a>.</pre><pre>     2.2. Factor A as Pr*transpose(A)*Pc=L*U with the permutation Pr
          determined by Gaussian elimination with partial pivoting.
          L is unit lower triangular with offdiagonal entries
          bounded by 1 in magnitude, and U is upper triangular.</pre><pre>     2.3. Solve the system of equations A*X=B using the factored
          form of A.</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>options (input) superlu_options_t*
        The structure defines the input parameters to control
        how the LU decomposition will be performed and how the
        system will be solved.</pre><pre>A       (input) SuperMatrix*
        Matrix A in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol). The number
        of linear equations is A-&gt;nrow. Currently, the type of A can be:
        Stype = SLU_NC or SLU_NR; Dtype = SLU_S; Mtype = SLU_GE.
        In the future, more general A may be handled.</pre><pre>perm_c  (input/output) int*
        If A-&gt;Stype = SLU_NC, column permutation vector of size A-&gt;ncol
        which defines the permutation matrix Pc; perm_c[i] = j means 
        column i of A is in position j in A*Pc.
        If A-&gt;Stype = SLU_NR, column permutation vector of size A-&gt;nrow
        which describes permutation of columns of transpose(A) 
        (rows of A) as described above.</pre><pre>        If options-&gt;ColPerm = MY_PERMC or options-&gt;Fact = SamePattern or
           options-&gt;Fact = SamePattern_SameRowPerm, it is an input argument.
           On exit, perm_c may be overwritten by the product of the input
           perm_c and a permutation that postorders the elimination tree
           of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree
           is already in postorder.
        Otherwise, it is an output argument.</pre><pre>perm_r  (input/output) int*
        If A-&gt;Stype = SLU_NC, row permutation vector of size A-&gt;nrow, 
        which defines the permutation matrix Pr, and is determined 
        by partial pivoting.  perm_r[i] = j means row i of A is in 
        position j in Pr*A.
        If A-&gt;Stype = SLU_NR, permutation vector of size A-&gt;ncol, which
        determines permutation of rows of transpose(A)
        (columns of A) as described above.</pre><pre>        If options-&gt;RowPerm = MY_PERMR or
           options-&gt;Fact = SamePattern_SameRowPerm, perm_r is an
           input argument.
        otherwise it is an output argument.</pre><pre>L       (output) SuperMatrix*
        The factor L from the factorization 
            Pr*A*Pc=L*U              (if A-&gt;Stype = SLU_NC) or
            Pr*transpose(A)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
        Uses compressed row subscripts storage for supernodes, i.e.,
        L has types: Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>U       (output) SuperMatrix*
        The factor U from the factorization 
            Pr*A*Pc=L*U              (if A-&gt;Stype = SLU_NC) or
            Pr*transpose(A)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
        Uses column-wise storage scheme, i.e., U has types:
        Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>B       (input/output) SuperMatrix*
        B has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
        On entry, the right hand side matrix.
        On exit, the solution matrix if info = 0;</pre><pre>stat   (output) SuperLUStat_t*
       Record the statistics on runtime and floating-point operation count.
       See util.h for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>info    (output) int*
        = 0: successful exit
        &gt; 0: if info = i, and i is
            &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
               been completed, but the factor U is exactly singular,
               so the solution could not be computed.
            &gt; A-&gt;ncol: number of bytes allocated when memory allocation
               failure occurred, plus A-&gt;ncol.
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a44bbae3b1218d951ed229c461a5f14b6_cgraph.png" border="0" usemap="#slu__sdefs_8h_a44bbae3b1218d951ed229c461a5f14b6_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a44bbae3b1218d951ed229c461a5f14b6_cgraph" id="slu__sdefs_8h_a44bbae3b1218d951ed229c461a5f14b6_cgraph">
<area shape="rect" id="node2" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="747,1779,829,1805"/><area shape="rect" id="node3" href="slu__sdefs_8h.html#abb3d30eea43abc536793244e7564e70d" title="Supernodal LU factor related. " alt="" coords="360,563,533,589"/><area shape="rect" id="node4" href="slu__util_8h.html#a0c6777573bbfe81917cd381e0090d355" title="Timer function. " alt="" coords="389,5,505,32"/><area shape="rect" id="node5" href="get__perm__c_8c.html#aaecb6e6e7a3e97356050bcfdf2573796" title="get_perm_c" alt="" coords="164,132,255,159"/><area shape="rect" id="node10" href="memory_8c.html#a49bbe20102e5b541c8e8963afa2bd46a" title="intMalloc" alt="" coords="605,816,680,843"/><area shape="rect" id="node11" href="slu__util_8h.html#adf9c573cbfb4520a5ea820702d27cfa5" title="sp_preorder" alt="" coords="164,360,255,387"/><area shape="rect" id="node17" href="slu__util_8h.html#a72be96e75e58564c4322ef9ef73ca65f" title="sp_ienv" alt="" coords="609,1779,676,1805"/><area shape="rect" id="node18" href="sgstrf_8c.html#a7f9874cec10809f11998cc3d9cb88f8b" title="sgstrf" alt="" coords="182,1196,237,1223"/><area shape="rect" id="node41" href="sgstrs_8c.html#a9b6e1e555af9cf109ef3a584054a91e2" title="sgstrs" alt="" coords="180,2032,239,2059"/><area shape="rect" id="node49" href="slu__util_8h.html#a4de38e1c0ef18dd0791cb206c7f5348f" title="A is of type Stype==NCP. " alt="" coords="113,2083,306,2109"/><area shape="rect" id="node50" href="slu__util_8h.html#a2c43be55861c6e4ee5b806ac16cc382c" title="Deallocate the structure pointing to the actual storage of the matrix. " alt="" coords="137,2134,282,2175"/><area shape="rect" id="node6" href="get__perm__c_8c.html#a90f30e2b284864f6a800a98ceaff8fbc" title="getata" alt="" coords="417,107,476,133"/><area shape="rect" id="node7" href="get__perm__c_8c.html#a486ee50799ff66abe91efa46a5950a57" title="at_plus_a" alt="" coords="407,208,486,235"/><area shape="rect" id="node8" href="get__perm__c_8c.html#ae92c26cd488b7a86b8277cee2773d8ef" title="get_colamd" alt="" coords="402,157,491,184"/><area shape="rect" id="node9" href="get__perm__c_8c.html#a792508355b6bef974fcd9e214de40c8e" title="genmmd_" alt="" coords="407,56,486,83"/><area shape="rect" id="node12" href="slu__util_8h.html#a8a3ba6cbe163f9c12f6f10ee8ba98fc7" title="print_int_vec" alt="" coords="399,309,495,336"/><area shape="rect" id="node13" href="sp__preorder_8c.html#ac79059104ae6abf212c41986820d358c" title="check_perm" alt="" coords="400,360,493,387"/><area shape="rect" id="node14" href="sp__coletree_8c.html#a657d6b291654432e815392c2a00d2b84" title="sp_symetree" alt="" coords="398,411,495,437"/><area shape="rect" id="node15" href="slu__util_8h.html#af8198f26bef3c82fbb8601fc5a8e0d9e" title="sp_coletree" alt="" coords="402,461,491,488"/><area shape="rect" id="node16" href="slu__util_8h.html#a44084fde835d2ccaa25e9fd942a72b7a" title="TreePostorder" alt="" coords="591,588,695,615"/><area shape="rect" id="node19" href="slu__sdefs_8h.html#af68715ec86cde90aa31fec07164d6ea6" title="Memory&#45;related. " alt="" coords="400,867,493,893"/><area shape="rect" id="node20" href="memory_8c.html#adbbe5a57b4ed64564c887fb52d798c54" title="Set up pointers for integer working arrays. " alt="" coords="408,765,485,792"/><area shape="rect" id="node21" href="slu__util_8h.html#ab0dfb6551008bcad5e758defdbd13006" title="Fills an integer array with a given value. " alt="" coords="623,715,662,741"/><area shape="rect" id="node22" href="slu__sdefs_8h.html#ab5b2859bf1ef1900506dfa702574c6ad" title="Set up pointers for real working arrays. " alt="" coords="401,1779,492,1805"/><area shape="rect" id="node23" href="heap__relax__snode_8c.html#a059d36bb76b7562c9bb2cbd7870e7ffe" title="heap_relax_snode" alt="" coords="383,613,510,640"/><area shape="rect" id="node24" href="relax__snode_8c.html#ad70bc12cb9031ab8aba4a37a18be46e3" title="relax_snode" alt="" coords="401,664,493,691"/><area shape="rect" id="node25" href="slu__sdefs_8h.html#ad9d54c8dfc11f1e034b4b7175be60ffb" title="ssnode_dfs" alt="" coords="402,1019,491,1045"/><area shape="rect" id="node26" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7" title="Expand the data structures for L and U during the factorization. " alt="" coords="587,1272,699,1299"/><area shape="rect" id="node27" href="slu__sdefs_8h.html#a60e60255360fae0b1458da070690a3a2" title="Performs numeric block updates within the relaxed snode. " alt="" coords="395,1069,498,1096"/><area shape="rect" id="node28" href="slu__sdefs_8h.html#ad7ddf03faedae25b4d73e0b6b33bf50c" title="spivotL" alt="" coords="415,1120,479,1147"/><area shape="rect" id="node29" href="slu__sdefs_8h.html#a297455c494a78c098b2bf418edbc6b16" title="Diagnostic print of column &quot;jcol&quot; in the U/L factor. " alt="" coords="399,1171,494,1197"/><area shape="rect" id="node30" href="slu__sdefs_8h.html#a77baf210393e04fa71d4e73b5e60e556" title="spanel_dfs" alt="" coords="404,1221,489,1248"/><area shape="rect" id="node31" href="slu__sdefs_8h.html#a51486936a9ff5079afed80eb5bf8a3e0" title="spanel_bmod" alt="" coords="397,1829,496,1856"/><area shape="rect" id="node32" href="scolumn__dfs_8c.html#ac9a044320fe8bfbb051a344686a4cb7d" title="scolumn_dfs" alt="" coords="399,1373,495,1400"/><area shape="rect" id="node33" href="scolumn__bmod_8c.html#ac89043410fd16fe2b8d3b2c902fec9f7" title="scolumn_bmod" alt="" coords="391,1323,502,1349"/><area shape="rect" id="node34" href="scopy__to__ucol_8c.html#ab44d465713c602e68295999c003daf7d" title="scopy_to_ucol" alt="" coords="393,968,500,995"/><area shape="rect" id="node35" href="slu__sdefs_8h.html#acf9da2c45289246ef663fc4a96d1ad78" title="spruneL" alt="" coords="413,1475,481,1501"/><area shape="rect" id="node36" href="slu__util_8h.html#ab71db926d60d7b8fd739df197b766366" title="Reset repfnz[] for the current column. " alt="" coords="400,1525,493,1552"/><area shape="rect" id="node37" href="slu__cdefs_8h.html#a8086902aa8be3fc7d04c3c82ec3a79dc" title="Count the total number of nonzeros in factors L and U, and in the symmetrically reduced L..." alt="" coords="413,1576,481,1603"/><area shape="rect" id="node38" href="slu__cdefs_8h.html#a7061332d759d7e4d73c1b2e5cb0bf2bf" title="Fix up the data storage lsub for L&#45;subscripts. It removes the subscript sets for structural pruning..." alt="" coords="418,1627,475,1653"/><area shape="rect" id="node39" href="slu__sdefs_8h.html#a9035f0d2a50cf5d8e29287572bd1be83" title="Free the working storage used by factor routines. " alt="" coords="395,1677,498,1704"/><area shape="rect" id="node40" href="slu__sdefs_8h.html#af4386b0d87e1c8886b58fcf9d243bc12" title="sCreate_SuperNode_Matrix" alt="" coords="355,1728,538,1755"/><area shape="rect" id="node42" href="sgstrs_8c.html#ad582f185cce067a3f9dd4225248af758" title="sprint_soln" alt="" coords="404,2285,489,2312"/><area shape="rect" id="node43" href="slu__cdefs_8h.html#a3e1230bff11a9e47c35555299bcdcf1b" title="floatCalloc" alt="" coords="405,1981,489,2008"/><area shape="rect" id="node44" href="slu__cdefs_8h.html#a42361c3ce2ba81d149ffba01fbd6f138" title="floatMalloc" alt="" coords="404,2032,489,2059"/><area shape="rect" id="node45" href="slu__sdefs_8h.html#a68de665c44346f6eacfe87e9f3c2a1e6" title="strsm_" alt="" coords="415,2083,478,2109"/><area shape="rect" id="node46" href="slu__sdefs_8h.html#ab822504d3d60a944da04997b4f91e067" title="BLAS. " alt="" coords="411,2133,483,2160"/><area shape="rect" id="node47" href="sgstrs_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="415,2184,478,2211"/><area shape="rect" id="node48" href="sgstrs_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="411,2235,483,2261"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9e5f2ccee873d436a117b99b2bec60da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgssvx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>etree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>recip_pivot_growth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&#160;</td>
          <td class="paramname"><em>mem_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>SGSSVX solves the system of linear equations A*X=B or A'*X=B, using
the LU factorization from <a class="el" href="sgstrf_8c.html#a7f9874cec10809f11998cc3d9cb88f8b">sgstrf()</a>. Error bounds on the solution and
a condition estimate are also provided. It performs the following steps:</pre><pre>  1. If A is stored column-wise (A-&gt;Stype = SLU_NC):</pre><pre>     1.1. If options-&gt;Equil = YES, scaling factors are computed to
          equilibrate the system:
          options-&gt;Trans = NOTRANS:
              diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
          options-&gt;Trans = TRANS:
              (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
          options-&gt;Trans = CONJ:
              (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
          Whether or not the system will be equilibrated depends on the
          scaling of the matrix A, but if equilibration is used, A is
          overwritten by diag(R)*A*diag(C) and B by diag(R)*B
          (if options-&gt;Trans=NOTRANS) or diag(C)*B (if options-&gt;Trans
          = TRANS or CONJ).</pre><pre>     1.2. Permute columns of A, forming A*Pc, where Pc is a permutation
          matrix that usually preserves sparsity.
          For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix. ">sp_preorder.c</a>.</pre><pre>     1.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
          factor the matrix A (after equilibration if options-&gt;Equil = YES)
          as Pr*A*Pc = L*U, with Pr determined by partial pivoting.</pre><pre>     1.4. Compute the reciprocal pivot growth factor.</pre><pre>     1.5. If some U(i,i) = 0, so that U is exactly singular, then the
          routine returns with info = i. Otherwise, the factored form of 
          A is used to estimate the condition number of the matrix A. If
          the reciprocal of the condition number is less than machine
          precision, info = A-&gt;ncol+1 is returned as a warning, but the
          routine still goes on to solve for X and computes error bounds
          as described below.</pre><pre>     1.6. The system of equations is solved for X using the factored form
          of A.</pre><pre>     1.7. If options-&gt;IterRefine != NOREFINE, iterative refinement is
          applied to improve the computed solution matrix and calculate
          error bounds and backward error estimates for it.</pre><pre>     1.8. If equilibration was used, the matrix X is premultiplied by
          diag(C) (if options-&gt;Trans = NOTRANS) or diag(R)
          (if options-&gt;Trans = TRANS or CONJ) so that it solves the
          original system before equilibration.</pre><pre>  2. If A is stored row-wise (A-&gt;Stype = SLU_NR), apply the above algorithm
     to the transpose of A:</pre><pre>     2.1. If options-&gt;Equil = YES, scaling factors are computed to
          equilibrate the system:
          options-&gt;Trans = NOTRANS:
              diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
          options-&gt;Trans = TRANS:
              (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
          options-&gt;Trans = CONJ:
              (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
          Whether or not the system will be equilibrated depends on the
          scaling of the matrix A, but if equilibration is used, A' is
          overwritten by diag(R)*A'*diag(C) and B by diag(R)*B 
          (if trans='N') or diag(C)*B (if trans = 'T' or 'C').</pre><pre>     2.2. Permute columns of transpose(A) (rows of A), 
          forming transpose(A)*Pc, where Pc is a permutation matrix that 
          usually preserves sparsity.
          For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix. ">sp_preorder.c</a>.</pre><pre>     2.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
          factor the transpose(A) (after equilibration if 
          options-&gt;Fact = YES) as Pr*transpose(A)*Pc = L*U with the
          permutation Pr determined by partial pivoting.</pre><pre>     2.4. Compute the reciprocal pivot growth factor.</pre><pre>     2.5. If some U(i,i) = 0, so that U is exactly singular, then the
          routine returns with info = i. Otherwise, the factored form 
          of transpose(A) is used to estimate the condition number of the
          matrix A. If the reciprocal of the condition number
          is less than machine precision, info = A-&gt;nrow+1 is returned as
          a warning, but the routine still goes on to solve for X and
          computes error bounds as described below.</pre><pre>     2.6. The system of equations is solved for X using the factored form
          of transpose(A).</pre><pre>     2.7. If options-&gt;IterRefine != NOREFINE, iterative refinement is
          applied to improve the computed solution matrix and calculate
          error bounds and backward error estimates for it.</pre><pre>     2.8. If equilibration was used, the matrix X is premultiplied by
          diag(C) (if options-&gt;Trans = NOTRANS) or diag(R) 
          (if options-&gt;Trans = TRANS or CONJ) so that it solves the
          original system before equilibration.</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>options (input) superlu_options_t*
        The structure defines the input parameters to control
        how the LU decomposition will be performed and how the
        system will be solved.</pre><pre>A       (input/output) SuperMatrix*
        Matrix A in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol). The number
        of the linear equations is A-&gt;nrow. Currently, the type of A can be:
        Stype = SLU_NC or SLU_NR, Dtype = SLU_D, Mtype = SLU_GE.
        In the future, more general A may be handled.</pre><pre>        On entry, If options-&gt;Fact = FACTORED and equed is not 'N', 
        then A must have been equilibrated by the scaling factors in
        R and/or C.  
        On exit, A is not modified if options-&gt;Equil = NO, or if 
        options-&gt;Equil = YES but equed = 'N' on exit.
        Otherwise, if options-&gt;Equil = YES and equed is not 'N',
        A is scaled as follows:
        If A-&gt;Stype = SLU_NC:
          equed = 'R':  A := diag(R) * A
          equed = 'C':  A := A * diag(C)
          equed = 'B':  A := diag(R) * A * diag(C).
        If A-&gt;Stype = SLU_NR:
          equed = 'R':  transpose(A) := diag(R) * transpose(A)
          equed = 'C':  transpose(A) := transpose(A) * diag(C)
          equed = 'B':  transpose(A) := diag(R) * transpose(A) * diag(C).</pre><pre>perm_c  (input/output) int*
        If A-&gt;Stype = SLU_NC, Column permutation vector of size A-&gt;ncol,
        which defines the permutation matrix Pc; perm_c[i] = j means
        column i of A is in position j in A*Pc.
        On exit, perm_c may be overwritten by the product of the input
        perm_c and a permutation that postorders the elimination tree
        of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree
        is already in postorder.</pre><pre>        If A-&gt;Stype = SLU_NR, column permutation vector of size A-&gt;nrow,
        which describes permutation of columns of transpose(A) 
        (rows of A) as described above.</pre><pre>perm_r  (input/output) int*
        If A-&gt;Stype = SLU_NC, row permutation vector of size A-&gt;nrow, 
        which defines the permutation matrix Pr, and is determined
        by partial pivoting.  perm_r[i] = j means row i of A is in 
        position j in Pr*A.</pre><pre>        If A-&gt;Stype = SLU_NR, permutation vector of size A-&gt;ncol, which
        determines permutation of rows of transpose(A)
        (columns of A) as described above.</pre><pre>        If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
        will try to use the input perm_r, unless a certain threshold
        criterion is violated. In that case, perm_r is overwritten by a
        new permutation determined by partial pivoting or diagonal
        threshold pivoting.
        Otherwise, perm_r is output argument.</pre><pre>etree   (input/output) int*,  dimension (A-&gt;ncol)
        Elimination tree of Pc'*A'*A*Pc.
        If options-&gt;Fact != FACTORED and options-&gt;Fact != DOFACT,
        etree is an input argument, otherwise it is an output argument.
        Note: etree is a vector of parent pointers for a forest whose
        vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.</pre><pre>equed   (input/output) char*
        Specifies the form of equilibration that was done.
        = 'N': No equilibration.
        = 'R': Row equilibration, i.e., A was premultiplied by diag(R).
        = 'C': Column equilibration, i.e., A was postmultiplied by diag(C).
        = 'B': Both row and column equilibration, i.e., A was replaced 
               by diag(R)*A*diag(C).
        If options-&gt;Fact = FACTORED, equed is an input argument,
        otherwise it is an output argument.</pre><pre>R       (input/output) float*, dimension (A-&gt;nrow)
        The row scale factors for A or transpose(A).
        If equed = 'R' or 'B', A (if A-&gt;Stype = SLU_NC) or transpose(A)
            (if A-&gt;Stype = SLU_NR) is multiplied on the left by diag(R).
        If equed = 'N' or 'C', R is not accessed.
        If options-&gt;Fact = FACTORED, R is an input argument,
            otherwise, R is output.
        If options-&gt;zFact = FACTORED and equed = 'R' or 'B', each element
            of R must be positive.</pre><pre>C       (input/output) float*, dimension (A-&gt;ncol)
        The column scale factors for A or transpose(A).
        If equed = 'C' or 'B', A (if A-&gt;Stype = SLU_NC) or transpose(A)
            (if A-&gt;Stype = SLU_NR) is multiplied on the right by diag(C).
        If equed = 'N' or 'R', C is not accessed.
        If options-&gt;Fact = FACTORED, C is an input argument,
            otherwise, C is output.
        If options-&gt;Fact = FACTORED and equed = 'C' or 'B', each element
            of C must be positive.</pre><pre>L       (output) SuperMatrix*
        The factor L from the factorization
            Pr*A*Pc=L*U              (if A-&gt;Stype SLU_= NC) or
            Pr*transpose(A)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
        Uses compressed row subscripts storage for supernodes, i.e.,
        L has types: Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>U       (output) SuperMatrix*
        The factor U from the factorization
            Pr*A*Pc=L*U              (if A-&gt;Stype = SLU_NC) or
            Pr*transpose(A)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
        Uses column-wise storage scheme, i.e., U has types:
        Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>work    (workspace/output) void*, size (lwork) (in bytes)
        User supplied workspace, should be large enough
        to hold data structures for factors L and U.
        On exit, if fact is not 'F', L and U point to this array.</pre><pre>lwork   (input) int
        Specifies the size of work array in bytes.
        = 0:  allocate space internally by system malloc;
        &gt; 0:  use user-supplied work array of length lwork in bytes,
              returns error if space runs out.
        = -1: the routine guesses the amount of space needed without
              performing the factorization, and returns it in
              mem_usage-&gt;total_needed; no other side effects.</pre><pre>        See argument 'mem_usage' for memory usage statistics.</pre><pre>B       (input/output) SuperMatrix*
        B has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
        On entry, the right hand side matrix.
        If B-&gt;ncol = 0, only LU decomposition is performed, the triangular
                        solve is skipped.
        On exit,
           if equed = 'N', B is not modified; otherwise
           if A-&gt;Stype = SLU_NC:
              if options-&gt;Trans = NOTRANS and equed = 'R' or 'B',
                 B is overwritten by diag(R)*B;
              if options-&gt;Trans = TRANS or CONJ and equed = 'C' of 'B',
                 B is overwritten by diag(C)*B;
           if A-&gt;Stype = SLU_NR:
              if options-&gt;Trans = NOTRANS and equed = 'C' or 'B',
                 B is overwritten by diag(C)*B;
              if options-&gt;Trans = TRANS or CONJ and equed = 'R' of 'B',
                 B is overwritten by diag(R)*B.</pre><pre>X       (output) SuperMatrix*
        X has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE. 
        If info = 0 or info = A-&gt;ncol+1, X contains the solution matrix
        to the original system of equations. Note that A and B are modified
        on exit if equed is not 'N', and the solution to the equilibrated
        system is inv(diag(C))*X if options-&gt;Trans = NOTRANS and
        equed = 'C' or 'B', or inv(diag(R))*X if options-&gt;Trans = 'T' or 'C'
        and equed = 'R' or 'B'.</pre><pre>recip_pivot_growth (output) float*
        The reciprocal pivot growth factor max_j( norm(A_j)/norm(U_j) ).
        The infinity norm is used. If recip_pivot_growth is much less
        than 1, the stability of the LU factorization could be poor.</pre><pre>rcond   (output) float*
        The estimate of the reciprocal condition number of the matrix A
        after equilibration (if done). If rcond is less than the machine
        precision (in particular, if rcond = 0), the matrix is singular
        to working precision. This condition is indicated by a return
        code of info &gt; 0.</pre><pre>FERR    (output) float*, dimension (B-&gt;ncol)   
        The estimated forward error bound for each solution vector   
        X(j) (the j-th column of the solution matrix X).   
        If XTRUE is the true solution corresponding to X(j), FERR(j) 
        is an estimated upper bound for the magnitude of the largest 
        element in (X(j) - XTRUE) divided by the magnitude of the   
        largest element in X(j).  The estimate is as reliable as   
        the estimate for RCOND, and is almost always a slight   
        overestimate of the true error.
        If options-&gt;IterRefine = NOREFINE, ferr = 1.0.</pre><pre>BERR    (output) float*, dimension (B-&gt;ncol)
        The componentwise relative backward error of each solution   
        vector X(j) (i.e., the smallest relative change in   
        any element of A or B that makes X(j) an exact solution).
        If options-&gt;IterRefine = NOREFINE, berr = 1.0.</pre><pre>Glu      (input/output) <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *
         If options-&gt;Fact == SamePattern_SameRowPerm, it is an input;
             The matrix A will be factorized assuming that a 
             factorization of a matrix with the same sparsity pattern
             and similar numerical values was performed prior to this one.
             Therefore, this factorization will reuse both row and column
        scaling factors R and C, both row and column permutation
        vectors perm_r and perm_c, and the L &amp; U data structures
        set up from the previous factorization.
         Otherwise, it is an output.</pre><pre>mem_usage (output) mem_usage_t*
        Record the memory usage statistics, consisting of following fields:</p>
<ul>
<li>for_lu (float)
          The amount of space used in bytes for L data structures.</li>
<li>total_needed (float)
          The amount of space needed in bytes to perform factorization.</li>
<li>expansions (int)
          The number of memory expansions during the LU factorization.</li>
</ul>
</pre><pre>stat   (output) SuperLUStat_t*
       Record the statistics on runtime and floating-point operation count.
       See <a class="el" href="slu__util_8h.html" title="Utility header file. ">slu_util.h</a> for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>info    (output) int*
        = 0: successful exit   
        &lt; 0: if info = -i, the i-th argument had an illegal value   
        &gt; 0: if info = i, and i is   
             &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has   
                   been completed, but the factor U is exactly   
                   singular, so the solution and error bounds   
                   could not be computed.   
             = A-&gt;ncol+1: U is nonsingular, but RCOND is less than machine
                   precision, meaning that the matrix is singular to
                   working precision. Nevertheless, the solution and
                   error bounds are computed because there are a number
                   of situations where the computed solution can be more
                   accurate than the value of RCOND would suggest.   
             &gt; A-&gt;ncol+1: number of bytes allocated when memory allocation
                   failure occurred, plus A-&gt;ncol.
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a9e5f2ccee873d436a117b99b2bec60da_cgraph.png" border="0" usemap="#slu__sdefs_8h_a9e5f2ccee873d436a117b99b2bec60da_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a9e5f2ccee873d436a117b99b2bec60da_cgraph" id="slu__sdefs_8h_a9e5f2ccee873d436a117b99b2bec60da_cgraph">
<area shape="rect" id="node2" href="slangs_8c.html#a201bfd9f2017cf5904aada9f21f23ab2" title="slangs" alt="" coords="185,5,245,32"/><area shape="rect" id="node3" href="slu__cdefs_8h.html#a1b49252f1cab66e35ac47ac1afb2adec" title="smach" alt="" coords="416,107,477,133"/><area shape="rect" id="node4" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="741,284,824,311"/><area shape="rect" id="node5" href="slu__util_8h.html#a72be96e75e58564c4322ef9ef73ca65f" title="sp_ienv" alt="" coords="604,613,671,640"/><area shape="rect" id="node6" href="slu__sdefs_8h.html#abb3d30eea43abc536793244e7564e70d" title="Supernodal LU factor related. " alt="" coords="360,563,533,589"/><area shape="rect" id="node7" href="slu__util_8h.html#a0c6777573bbfe81917cd381e0090d355" title="Timer function. " alt="" coords="389,1779,505,1805"/><area shape="rect" id="node8" href="sgsequ_8c.html#ad8a808e807e38c32c08cfbeadb088f08" title="Driver related. " alt="" coords="183,208,247,235"/><area shape="rect" id="node9" href="slaqgs_8c.html#af44216962efdebc7e1117b273743e84f" title="slaqgs" alt="" coords="185,107,245,133"/><area shape="rect" id="node10" href="get__perm__c_8c.html#aaecb6e6e7a3e97356050bcfdf2573796" title="get_perm_c" alt="" coords="169,1855,260,1881"/><area shape="rect" id="node15" href="slu__util_8h.html#adf9c573cbfb4520a5ea820702d27cfa5" title="sp_preorder" alt="" coords="169,2032,260,2059"/><area shape="rect" id="node21" href="sgstrf_8c.html#a7f9874cec10809f11998cc3d9cb88f8b" title="sgstrf" alt="" coords="187,1120,242,1147"/><area shape="rect" id="node44" href="slu__sdefs_8h.html#acb8787465a6296109b9a306d5a315ff8" title="sPivotGrowth" alt="" coords="164,157,265,184"/><area shape="rect" id="node45" href="sgscon_8c.html#a76b21c7561d5bce81821a76c3465601b" title="sgscon" alt="" coords="415,360,479,387"/><area shape="rect" id="node46" href="sgstrs_8c.html#a9b6e1e555af9cf109ef3a584054a91e2" title="sgstrs" alt="" coords="417,208,476,235"/><area shape="rect" id="node47" href="sgsrfs_8c.html#aa619758588187cd5ad69a10a808d18f6" title="sgsrfs" alt="" coords="185,309,244,336"/><area shape="rect" id="node48" href="slu__sdefs_8h.html#a1357f9a3b2ffb9522883ad84affa63e3" title="sQuerySpace" alt="" coords="164,512,265,539"/><area shape="rect" id="node49" href="slu__util_8h.html#a4de38e1c0ef18dd0791cb206c7f5348f" title="A is of type Stype==NCP. " alt="" coords="118,2083,311,2109"/><area shape="rect" id="node50" href="slu__util_8h.html#a2c43be55861c6e4ee5b806ac16cc382c" title="Deallocate the structure pointing to the actual storage of the matrix. " alt="" coords="142,2134,287,2175"/><area shape="rect" id="node11" href="get__perm__c_8c.html#a90f30e2b284864f6a800a98ceaff8fbc" title="getata" alt="" coords="417,1829,476,1856"/><area shape="rect" id="node12" href="get__perm__c_8c.html#a486ee50799ff66abe91efa46a5950a57" title="at_plus_a" alt="" coords="407,1981,486,2008"/><area shape="rect" id="node13" href="get__perm__c_8c.html#ae92c26cd488b7a86b8277cee2773d8ef" title="get_colamd" alt="" coords="402,1880,491,1907"/><area shape="rect" id="node14" href="get__perm__c_8c.html#a792508355b6bef974fcd9e214de40c8e" title="genmmd_" alt="" coords="407,1931,486,1957"/><area shape="rect" id="node16" href="slu__util_8h.html#a8a3ba6cbe163f9c12f6f10ee8ba98fc7" title="print_int_vec" alt="" coords="399,2032,495,2059"/><area shape="rect" id="node17" href="sp__preorder_8c.html#ac79059104ae6abf212c41986820d358c" title="check_perm" alt="" coords="400,2083,493,2109"/><area shape="rect" id="node18" href="sp__coletree_8c.html#a657d6b291654432e815392c2a00d2b84" title="sp_symetree" alt="" coords="398,2133,495,2160"/><area shape="rect" id="node19" href="slu__util_8h.html#af8198f26bef3c82fbb8601fc5a8e0d9e" title="sp_coletree" alt="" coords="402,2235,491,2261"/><area shape="rect" id="node20" href="slu__util_8h.html#a44084fde835d2ccaa25e9fd942a72b7a" title="TreePostorder" alt="" coords="585,1931,689,1957"/><area shape="rect" id="node22" href="slu__sdefs_8h.html#af68715ec86cde90aa31fec07164d6ea6" title="Memory&#45;related. " alt="" coords="400,816,493,843"/><area shape="rect" id="node23" href="memory_8c.html#a49bbe20102e5b541c8e8963afa2bd46a" title="intMalloc" alt="" coords="600,816,675,843"/><area shape="rect" id="node24" href="memory_8c.html#adbbe5a57b4ed64564c887fb52d798c54" title="Set up pointers for integer working arrays. " alt="" coords="408,968,485,995"/><area shape="rect" id="node25" href="slu__util_8h.html#ab0dfb6551008bcad5e758defdbd13006" title="Fills an integer array with a given value. " alt="" coords="618,1069,657,1096"/><area shape="rect" id="node26" href="slu__sdefs_8h.html#ab5b2859bf1ef1900506dfa702574c6ad" title="Set up pointers for real working arrays. " alt="" coords="401,664,492,691"/><area shape="rect" id="node27" href="heap__relax__snode_8c.html#a059d36bb76b7562c9bb2cbd7870e7ffe" title="heap_relax_snode" alt="" coords="383,1171,510,1197"/><area shape="rect" id="node28" href="relax__snode_8c.html#ad70bc12cb9031ab8aba4a37a18be46e3" title="relax_snode" alt="" coords="401,1221,493,1248"/><area shape="rect" id="node29" href="slu__sdefs_8h.html#ad9d54c8dfc11f1e034b4b7175be60ffb" title="ssnode_dfs" alt="" coords="402,1677,491,1704"/><area shape="rect" id="node30" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7" title="Expand the data structures for L and U during the factorization. " alt="" coords="581,1627,693,1653"/><area shape="rect" id="node31" href="slu__sdefs_8h.html#a60e60255360fae0b1458da070690a3a2" title="Performs numeric block updates within the relaxed snode. " alt="" coords="395,1019,498,1045"/><area shape="rect" id="node32" href="slu__sdefs_8h.html#ad7ddf03faedae25b4d73e0b6b33bf50c" title="spivotL" alt="" coords="415,1069,479,1096"/><area shape="rect" id="node33" href="slu__sdefs_8h.html#a297455c494a78c098b2bf418edbc6b16" title="Diagnostic print of column &quot;jcol&quot; in the U/L factor. " alt="" coords="399,1120,494,1147"/><area shape="rect" id="node34" href="slu__sdefs_8h.html#a77baf210393e04fa71d4e73b5e60e556" title="spanel_dfs" alt="" coords="404,1272,489,1299"/><area shape="rect" id="node35" href="slu__sdefs_8h.html#a51486936a9ff5079afed80eb5bf8a3e0" title="spanel_bmod" alt="" coords="397,715,496,741"/><area shape="rect" id="node36" href="scolumn__dfs_8c.html#ac9a044320fe8bfbb051a344686a4cb7d" title="scolumn_dfs" alt="" coords="399,765,495,792"/><area shape="rect" id="node37" href="scolumn__bmod_8c.html#ac89043410fd16fe2b8d3b2c902fec9f7" title="scolumn_bmod" alt="" coords="391,1728,502,1755"/><area shape="rect" id="node38" href="scopy__to__ucol_8c.html#ab44d465713c602e68295999c003daf7d" title="scopy_to_ucol" alt="" coords="393,1627,500,1653"/><area shape="rect" id="node39" href="slu__sdefs_8h.html#acf9da2c45289246ef663fc4a96d1ad78" title="spruneL" alt="" coords="413,1323,481,1349"/><area shape="rect" id="node40" href="slu__util_8h.html#ab71db926d60d7b8fd739df197b766366" title="Reset repfnz[] for the current column. " alt="" coords="400,1373,493,1400"/><area shape="rect" id="node41" href="slu__cdefs_8h.html#a8086902aa8be3fc7d04c3c82ec3a79dc" title="Count the total number of nonzeros in factors L and U, and in the symmetrically reduced L..." alt="" coords="413,1424,481,1451"/><area shape="rect" id="node42" href="slu__cdefs_8h.html#a7061332d759d7e4d73c1b2e5cb0bf2bf" title="Fix up the data storage lsub for L&#45;subscripts. It removes the subscript sets for structural pruning..." alt="" coords="418,1475,475,1501"/><area shape="rect" id="node43" href="slu__sdefs_8h.html#a9035f0d2a50cf5d8e29287572bd1be83" title="Free the working storage used by factor routines. " alt="" coords="395,1525,498,1552"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a77f83568633bc0ce7ec5adcb351c1497"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgstrf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>relax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>etree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>SGSTRF computes an LU factorization of a general sparse m-by-n
matrix A using partial pivoting with row interchanges.
The factorization has the form
    Pr * A = L * U
where Pr is a row permutation matrix, L is lower triangular with unit
diagonal elements (lower trapezoidal if A-&gt;nrow &gt; A-&gt;ncol), and U is upper 
triangular (upper trapezoidal if A-&gt;nrow &lt; A-&gt;ncol).</pre><pre>See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>options (input) superlu_options_t*
        The structure defines the input parameters to control
        how the LU decomposition will be performed.</pre><pre>A        (input) SuperMatrix*
         Original matrix A, permuted by columns, of dimension
         (A-&gt;nrow, A-&gt;ncol). The type of A can be:
         Stype = SLU_NCP; Dtype = SLU_S; Mtype = SLU_GE.</pre><pre>relax    (input) int
         To control degree of relaxing supernodes. If the number
         of nodes (columns) in a subtree of the elimination tree is less
         than relax, this subtree is considered as one supernode,
         regardless of the row structures of those columns.</pre><pre>panel_size (input) int
         A panel consists of at most panel_size consecutive columns.</pre><pre>etree    (input) int*, dimension (A-&gt;ncol)
         Elimination tree of A'*A.
         Note: etree is a vector of parent pointers for a forest whose
         vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.
         On input, the columns of A should be permuted so that the
         etree is in a certain postorder.</pre><pre>work     (input/output) void*, size (lwork) (in bytes)
         User-supplied work space and space for the output data structures.
         Not referenced if lwork = 0;</pre><pre>lwork   (input) int
        Specifies the size of work array in bytes.
        = 0:  allocate space internally by system malloc;
        &gt; 0:  use user-supplied work array of length lwork in bytes,
              returns error if space runs out.
        = -1: the routine guesses the amount of space needed without
              performing the factorization, and returns it in
              *info; no other side effects.</pre><pre>perm_c   (input) int*, dimension (A-&gt;ncol)
         Column permutation vector, which defines the 
         permutation matrix Pc; perm_c[i] = j means column i of A is 
         in position j in A*Pc.
         When searching for diagonal, perm_c[*] is applied to the
         row subscripts of A, so that diagonal threshold pivoting
         can find the diagonal of A, rather than that of A*Pc.</pre><pre>perm_r   (input/output) int*, dimension (A-&gt;nrow)
         Row permutation vector which defines the permutation matrix Pr,
         perm_r[i] = j means row i of A is in position j in Pr*A.
         If options-&gt;Fact == SamePattern_SameRowPerm, the pivoting routine
            will try to use the input perm_r, unless a certain threshold
            criterion is violated. In that case, perm_r is overwritten by
            a new permutation determined by partial pivoting or diagonal
            threshold pivoting.
         Otherwise, perm_r is output argument;</pre><pre>L        (output) SuperMatrix*
         The factor L from the factorization Pr*A=L*U; use compressed row 
         subscripts storage for supernodes, i.e., L has type: 
         Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>U        (output) SuperMatrix*
         The factor U from the factorization Pr*A*Pc=L*U. Use column-wise
         storage scheme, i.e., U has types: Stype = SLU_NC, 
         Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>Glu      (input/output) <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *
         If options-&gt;Fact == SamePattern_SameRowPerm, it is an input;
             The matrix A will be factorized assuming that a 
             factorization of a matrix with the same sparsity pattern
             and similar numerical values was performed prior to this one.
             Therefore, this factorization will reuse both row and column
        scaling factors R and C, both row and column permutation
        vectors perm_r and perm_c, and the L &amp; U data structures
        set up from the previous factorization.
         Otherwise, it is an output.</pre><pre>stat     (output) SuperLUStat_t*
         Record the statistics on runtime and floating-point operation count.
         See <a class="el" href="slu__util_8h.html" title="Utility header file. ">slu_util.h</a> for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>info     (output) int*
         = 0: successful exit
         &lt; 0: if info = -i, the i-th argument had an illegal value
         &gt; 0: if info = i, and i is
            &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
               been completed, but the factor U is exactly singular,
               and division by zero will occur if it is used to solve a
               system of equations.
            &gt; A-&gt;ncol: number of bytes allocated when memory allocation
               failure occurred, plus A-&gt;ncol. If lwork = -1, it is
               the estimated amount of space needed, plus A-&gt;ncol.
</p>
<hr/>
</pre><pre><h1>Local Working Arrays: 
</h1>
</pre><pre>
  m = number of rows in the matrix
  n = number of columns in the matrix</pre><pre>  xprune[0:n-1]: xprune[*] points to locations in subscript 
     vector lsub[*]. For column i, xprune[i] denotes the point where 
     structural pruning begins. I.e. only xlsub[i],..,xprune[i]-1 need 
     to be traversed for symbolic factorization.</pre><pre>  marker[0:3*m-1]: marker[i] = j means that node i has been 
     reached when working on column j.
     Storage: relative to original row subscripts
     NOTE: There are 3 of them: marker/marker1 are used for panel dfs, 
           see <a class="el" href="spanel__dfs_8c.html" title="Peforms a symbolic factorization on a panel of symbols. ">spanel_dfs.c</a>; marker2 is used for inner-factorization,
           see <a class="el" href="scolumn__dfs_8c.html" title="Performs a symbolic factorization. ">scolumn_dfs.c</a>.</pre><pre>  parent[0:m-1]: parent vector used during dfs
     Storage: relative to new row subscripts</pre><pre>  xplore[0:m-1]: xplore[i] gives the location of the next (dfs) 
     unexplored neighbor of i in lsub[*]</pre><pre>  segrep[0:nseg-1]: contains the list of supernodal representatives
     in topological order of the dfs. A supernode representative is the 
     last column of a supernode.
     The maximum size of segrep[] is n.</pre><pre>  repfnz[0:W*m-1]: for a nonzero segment U[*,j] that ends at a 
     supernodal representative r, repfnz[r] is the location of the first 
     nonzero in this segment.  It is also used during the dfs: repfnz[r]&gt;0
     indicates the supernode r has been explored.
     NOTE: There are W of them, each used for one column of a panel.</pre><pre>  panel_lsub[0:W*m-1]: temporary for the nonzeros row indices below 
     the panel diagonal. These are filled in during <a class="el" href="slu__sdefs_8h.html#a77baf210393e04fa71d4e73b5e60e556">spanel_dfs()</a>, and are
     used later in the inner LU factorization within the panel.
     panel_lsub[]/dense[] pair forms the SPA data structure.
     NOTE: There are W of them.</pre><pre>  dense[0:W*m-1]: sparse accumulating (SPA) vector for intermediate values;
                   NOTE: there are W of them.</pre><pre>  tempv[0:*]: real temporary used for dense numeric kernels;
     The size of this array is defined by <a class="el" href="slu__util_8h.html#a06193b28f40a4779ae7737711642eb45">NUM_TEMPV()</a> in <a class="el" href="slu__sdefs_8h.html" title="Header file for real operations. ">slu_sdefs.h</a>.
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a77f83568633bc0ce7ec5adcb351c1497_cgraph.png" border="0" usemap="#slu__sdefs_8h_a77f83568633bc0ce7ec5adcb351c1497_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a77f83568633bc0ce7ec5adcb351c1497_cgraph" id="slu__sdefs_8h_a77f83568633bc0ce7ec5adcb351c1497_cgraph">
<area shape="rect" id="node2" href="slu__util_8h.html#a72be96e75e58564c4322ef9ef73ca65f" title="sp_ienv" alt="" coords="528,917,595,944"/><area shape="rect" id="node4" href="slu__sdefs_8h.html#af68715ec86cde90aa31fec07164d6ea6" title="Memory&#45;related. " alt="" coords="155,157,248,184"/><area shape="rect" id="node6" href="memory_8c.html#a49bbe20102e5b541c8e8963afa2bd46a" title="intMalloc" alt="" coords="360,208,435,235"/><area shape="rect" id="node16" href="memory_8c.html#adbbe5a57b4ed64564c887fb52d798c54" title="Set up pointers for integer working arrays. " alt="" coords="163,309,240,336"/><area shape="rect" id="node17" href="slu__util_8h.html#ab0dfb6551008bcad5e758defdbd13006" title="Fills an integer array with a given value. " alt="" coords="378,411,417,437"/><area shape="rect" id="node18" href="slu__sdefs_8h.html#ab5b2859bf1ef1900506dfa702574c6ad" title="Set up pointers for real working arrays. " alt="" coords="156,917,247,944"/><area shape="rect" id="node20" href="heap__relax__snode_8c.html#a059d36bb76b7562c9bb2cbd7870e7ffe" title="heap_relax_snode" alt="" coords="138,259,265,285"/><area shape="rect" id="node25" href="relax__snode_8c.html#ad70bc12cb9031ab8aba4a37a18be46e3" title="relax_snode" alt="" coords="155,411,247,437"/><area shape="rect" id="node26" href="slu__sdefs_8h.html#ad9d54c8dfc11f1e034b4b7175be60ffb" title="ssnode_dfs" alt="" coords="157,512,246,539"/><area shape="rect" id="node27" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7" title="Expand the data structures for L and U during the factorization. " alt="" coords="341,512,453,539"/><area shape="rect" id="node28" href="slu__sdefs_8h.html#a60e60255360fae0b1458da070690a3a2" title="Performs numeric block updates within the relaxed snode. " alt="" coords="150,867,253,893"/><area shape="rect" id="node33" href="slu__sdefs_8h.html#ad7ddf03faedae25b4d73e0b6b33bf50c" title="spivotL" alt="" coords="169,715,233,741"/><area shape="rect" id="node34" href="slu__sdefs_8h.html#a297455c494a78c098b2bf418edbc6b16" title="Diagnostic print of column &quot;jcol&quot; in the U/L factor. " alt="" coords="154,765,249,792"/><area shape="rect" id="node35" href="slu__sdefs_8h.html#a77baf210393e04fa71d4e73b5e60e556" title="spanel_dfs" alt="" coords="159,816,244,843"/><area shape="rect" id="node36" href="slu__sdefs_8h.html#a51486936a9ff5079afed80eb5bf8a3e0" title="spanel_bmod" alt="" coords="152,968,251,995"/><area shape="rect" id="node39" href="scolumn__dfs_8c.html#ac9a044320fe8bfbb051a344686a4cb7d" title="scolumn_dfs" alt="" coords="153,613,249,640"/><area shape="rect" id="node40" href="scolumn__bmod_8c.html#ac89043410fd16fe2b8d3b2c902fec9f7" title="scolumn_bmod" alt="" coords="146,664,257,691"/><area shape="rect" id="node41" href="scopy__to__ucol_8c.html#ab44d465713c602e68295999c003daf7d" title="scopy_to_ucol" alt="" coords="148,461,255,488"/><area shape="rect" id="node42" href="slu__sdefs_8h.html#acf9da2c45289246ef663fc4a96d1ad78" title="spruneL" alt="" coords="167,1069,235,1096"/><area shape="rect" id="node43" href="slu__util_8h.html#ab71db926d60d7b8fd739df197b766366" title="Reset repfnz[] for the current column. " alt="" coords="155,1120,248,1147"/><area shape="rect" id="node44" href="slu__cdefs_8h.html#a8086902aa8be3fc7d04c3c82ec3a79dc" title="Count the total number of nonzeros in factors L and U, and in the symmetrically reduced L..." alt="" coords="167,1171,235,1197"/><area shape="rect" id="node45" href="slu__cdefs_8h.html#a7061332d759d7e4d73c1b2e5cb0bf2bf" title="Fix up the data storage lsub for L&#45;subscripts. It removes the subscript sets for structural pruning..." alt="" coords="173,1221,230,1248"/><area shape="rect" id="node46" href="slu__sdefs_8h.html#a9035f0d2a50cf5d8e29287572bd1be83" title="Free the working storage used by factor routines. " alt="" coords="150,1272,253,1299"/><area shape="rect" id="node47" href="slu__sdefs_8h.html#af4386b0d87e1c8886b58fcf9d243bc12" title="sCreate_SuperNode_Matrix" alt="" coords="110,1323,293,1349"/><area shape="rect" id="node48" href="slu__sdefs_8h.html#abb3d30eea43abc536793244e7564e70d" title="Supernodal LU factor related. " alt="" coords="115,1373,288,1400"/><area shape="rect" id="node3" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="688,917,771,944"/><area shape="rect" id="node5" href="smemory_8c.html#a146216d4543e94e7ec4783eada50bf4c" title="Setup the memory model to be used for factorization. " alt="" coords="347,56,447,83"/><area shape="rect" id="node7" href="smemory_8c.html#ad68adc1b6de3f821f9fb24cdcf24d281" title="suser_malloc" alt="" coords="680,107,779,133"/><area shape="rect" id="node8" href="smemory_8c.html#aa2862f14356be7d9f12bfdfc175137a1" title="Expand the existing storage to accommodate more fill&#45;ins. " alt="" coords="526,335,597,361"/><area shape="rect" id="node12" href="smemory_8c.html#a29f7485dd32f85e996e16f2a199b002d" title="suser_free" alt="" coords="356,157,439,184"/><area shape="rect" id="node13" href="smemory_8c.html#a658f955c5532813bd0490502efae563f" title="smemory_usage" alt="" coords="502,449,621,476"/><area shape="rect" id="node14" href="smemory_8c.html#abc603ef3859778fb5631cf3d3b951de6" title="Allocate known working storage. Returns 0 if success, otherwise returns the number of bytes allocated..." alt="" coords="350,5,445,32"/><area shape="rect" id="node9" href="smemory_8c.html#ab59eea34474da95fb3dc125400a1287e" title="copy_mem_int" alt="" coords="676,385,783,412"/><area shape="rect" id="node10" href="smemory_8c.html#a00d00daa40d07c16e3ae6bfd87c70e3d" title="copy_mem_float" alt="" coords="670,284,789,311"/><area shape="rect" id="node11" href="smemory_8c.html#a4c226087c09a94ff40b92b14fa46fc53" title="user_bcopy" alt="" coords="685,335,774,361"/><area shape="rect" id="node15" href="memory_8c.html#aaf51f82a79c361236a2d825a59a63403" title="intCalloc" alt="" coords="525,56,598,83"/><area shape="rect" id="node19" href="slu__sdefs_8h.html#a2d734e40276e89a3ef04bf79bc21acb6" title="Fills a float precision array with a given value. " alt="" coords="376,867,419,893"/><area shape="rect" id="node21" href="slu__util_8h.html#a44084fde835d2ccaa25e9fd942a72b7a" title="TreePostorder" alt="" coords="345,259,449,285"/><area shape="rect" id="node22" href="sp__coletree_8c.html#a45fdfbf54106113728e1a036977ccf5b" title="mxCallocInt" alt="" coords="515,284,607,311"/><area shape="rect" id="node23" href="sp__coletree_8c.html#a9da0c72a7b8eaf7a2a69fb6c3340131a" title="etdfs" alt="" coords="536,183,587,209"/><area shape="rect" id="node24" href="sp__coletree_8c.html#a7fec305add1f9f4c611eacdb2b744bfd" title="nr_etdfs" alt="" coords="527,233,596,260"/><area shape="rect" id="node29" href="slu__sdefs_8h.html#aab583b502d3953688a3fa27a9f4bbf1e" title="strsv_" alt="" coords="368,765,427,792"/><area shape="rect" id="node30" href="slu__sdefs_8h.html#ae29fbdb32369b70973b05d14fc3420c9" title="sgemv_" alt="" coords="363,816,431,843"/><area shape="rect" id="node31" href="scolumn__bmod_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="366,664,429,691"/><area shape="rect" id="node32" href="scolumn__bmod_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="361,715,433,741"/><area shape="rect" id="node37" href="spanel__bmod_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="366,1019,429,1045"/><area shape="rect" id="node38" href="spanel__bmod_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="361,1069,433,1096"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aea450a9c52512127d6eaaebf0a65f9ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgstrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>SGSTRS solves a system of linear equations A*X=B or A'*X=B
with A sparse and B dense, using the LU factorization computed by
SGSTRF.</pre><pre>See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>trans   (input) trans_t
         Specifies the form of the system of equations:
         = NOTRANS: A * X = B  (No transpose)
         = TRANS:   A'* X = B  (Transpose)
         = CONJ:    A**H * X = B  (Conjugate transpose)</pre><pre>L       (input) SuperMatrix*
        The factor L from the factorization Pr*A*Pc=L*U as computed by
        <a class="el" href="sgstrf_8c.html#a7f9874cec10809f11998cc3d9cb88f8b">sgstrf()</a>. Use compressed row subscripts storage for supernodes,
        i.e., L has types: Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>U       (input) SuperMatrix*
        The factor U from the factorization Pr*A*Pc=L*U as computed by
        <a class="el" href="sgstrf_8c.html#a7f9874cec10809f11998cc3d9cb88f8b">sgstrf()</a>. Use column-wise storage scheme, i.e., U has types:
        Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>perm_c  (input) int*, dimension (L-&gt;ncol)
        Column permutation vector, which defines the 
        permutation matrix Pc; perm_c[i] = j means column i of A is 
        in position j in A*Pc.</pre><pre>perm_r  (input) int*, dimension (L-&gt;nrow)
        Row permutation vector, which defines the permutation matrix Pr; 
        perm_r[i] = j means row i of A is in position j in Pr*A.</pre><pre>B       (input/output) SuperMatrix*
        B has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
        On entry, the right hand side matrix.
        On exit, the solution matrix if info = 0;</pre><pre>stat     (output) SuperLUStat_t*
         Record the statistics on runtime and floating-point operation count.
         See util.h for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>info    (output) int*
           = 0: successful exit
        &lt; 0: if info = -i, the i-th argument had an illegal value
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_aea450a9c52512127d6eaaebf0a65f9ce_cgraph.png" border="0" usemap="#slu__sdefs_8h_aea450a9c52512127d6eaaebf0a65f9ce_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_aea450a9c52512127d6eaaebf0a65f9ce_cgraph" id="slu__sdefs_8h_aea450a9c52512127d6eaaebf0a65f9ce_cgraph">
<area shape="rect" id="node2" href="sgstrs_8c.html#ad582f185cce067a3f9dd4225248af758" title="sprint_soln" alt="" coords="112,5,197,32"/><area shape="rect" id="node3" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="247,56,329,83"/><area shape="rect" id="node4" href="slu__cdefs_8h.html#a3e1230bff11a9e47c35555299bcdcf1b" title="floatCalloc" alt="" coords="246,107,330,133"/><area shape="rect" id="node5" href="slu__cdefs_8h.html#a42361c3ce2ba81d149ffba01fbd6f138" title="floatMalloc" alt="" coords="112,208,197,235"/><area shape="rect" id="node6" href="slu__sdefs_8h.html#a68de665c44346f6eacfe87e9f3c2a1e6" title="strsm_" alt="" coords="123,259,186,285"/><area shape="rect" id="node7" href="slu__sdefs_8h.html#ab822504d3d60a944da04997b4f91e067" title="BLAS. " alt="" coords="119,309,191,336"/><area shape="rect" id="node8" href="sgstrs_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="123,360,186,387"/><area shape="rect" id="node9" href="sgstrs_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="119,411,191,437"/><area shape="rect" id="node10" href="sgstrs_8c.html#a25ea48f4f948c68a423f5bd3929e3c1f" title="Solves a dense upper triangular system. " alt="" coords="121,461,188,488"/><area shape="rect" id="node11" href="slu__sdefs_8h.html#aa6d287b6b9bcaf72a692343e614c429c" title="Solves one of the systems of equations A*x = b, or A&#39;*x = b. " alt="" coords="119,157,191,184"/><area shape="rect" id="node12" href="slu__sdefs_8h.html#aab583b502d3953688a3fa27a9f4bbf1e" title="strsv_" alt="" coords="259,208,317,235"/><area shape="rect" id="node13" href="slu__sdefs_8h.html#ae29fbdb32369b70973b05d14fc3420c9" title="sgemv_" alt="" coords="254,259,322,285"/><area shape="rect" id="node14" href="ssp__blas2_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="257,309,319,336"/><area shape="rect" id="node15" href="ssp__blas2_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="252,360,324,387"/><area shape="rect" id="node16" href="ssp__blas2_8c.html#a25ea48f4f948c68a423f5bd3929e3c1f" title="Solves a dense upper triangular system. " alt="" coords="255,157,321,184"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aba0eeda28d139bf88878880edd3cca5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sinf_norm_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afe4b556cd9d484f53606d114f83649d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void slaqgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rowcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>colcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>equed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose   
</h1>
</pre><pre></pre><pre>  SLAQGS equilibrates a general sparse M by N matrix A using the row and   
  scaling factors in the vectors R and C.</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments   
</h1>
</pre><pre></pre><pre>  A       (input/output) SuperMatrix*
          On exit, the equilibrated matrix.  See EQUED for the form of 
          the equilibrated matrix. The type of A can be:
         Stype = NC; Dtype = SLU_S; Mtype = GE.</pre><pre>  R       (input) float*, dimension (A-&gt;nrow)
          The row scale factors for A.</pre><pre>  C       (input) float*, dimension (A-&gt;ncol)
          The column scale factors for A.</pre><pre>  ROWCND  (input) float
          Ratio of the smallest R(i) to the largest R(i).</pre><pre>  COLCND  (input) float
          Ratio of the smallest C(i) to the largest C(i).</pre><pre>  AMAX    (input) float
          Absolute value of largest matrix entry.</pre><pre>  EQUED   (output) char*
          Specifies the form of equilibration that was done.   
          = 'N':  No equilibration   
          = 'R':  Row equilibration, i.e., A has been premultiplied by  
                  diag(R).   
          = 'C':  Column equilibration, i.e., A has been postmultiplied  
                  by diag(C).   
          = 'B':  Both row and column equilibration, i.e., A has been
                  replaced by diag(R) * A * diag(C).</pre><pre><h1>Internal Parameters   
</h1>
</pre><pre></pre><pre>  THRESH is a threshold value used to decide if row or column scaling   
  should be done based on the ratio of the row or column scaling   
  factors.  If ROWCND &lt; THRESH, row scaling is done, and if   
  COLCND &lt; THRESH, column scaling is done.</pre><pre>  LARGE and SMALL are threshold values used to decide if row scaling   
  should be done based on the absolute size of the largest matrix   
  element.  If AMAX &gt; LARGE or AMAX &lt; SMALL, row scaling is done.   
</p>
<hr/>

</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_afe4b556cd9d484f53606d114f83649d4_cgraph.png" border="0" usemap="#slu__sdefs_8h_afe4b556cd9d484f53606d114f83649d4_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_afe4b556cd9d484f53606d114f83649d4_cgraph" id="slu__sdefs_8h_afe4b556cd9d484f53606d114f83649d4_cgraph">
<area shape="rect" id="node2" href="slu__cdefs_8h.html#a1b49252f1cab66e35ac47ac1afb2adec" title="smach" alt="" coords="115,5,176,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a69557d06b4e300aa6aca944561f3bb32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sldperm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname">[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af68715ec86cde90aa31fec07164d6ea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sLUMemInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#ac785c8235480e5cfef9848d89c047c0a">fact_t</a>&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>annz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fill_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory-related.</p>
<pre>
For those unpredictable size, estimate as fill_ratio * nnz(A).
Return value:
    If lwork = -1, return the estimated amount of space required, plus n;
    otherwise, return the amount of space actually allocated when
    memory allocation failure occurred.
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_af68715ec86cde90aa31fec07164d6ea6_cgraph.png" border="0" usemap="#slu__sdefs_8h_af68715ec86cde90aa31fec07164d6ea6_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_af68715ec86cde90aa31fec07164d6ea6_cgraph" id="slu__sdefs_8h_af68715ec86cde90aa31fec07164d6ea6_cgraph">
<area shape="rect" id="node2" href="smemory_8c.html#a146216d4543e94e7ec4783eada50bf4c" title="Setup the memory model to be used for factorization. " alt="" coords="157,5,257,32"/><area shape="rect" id="node3" href="memory_8c.html#a49bbe20102e5b541c8e8963afa2bd46a" title="intMalloc" alt="" coords="169,56,244,83"/><area shape="rect" id="node4" href="smemory_8c.html#ad68adc1b6de3f821f9fb24cdcf24d281" title="suser_malloc" alt="" coords="325,183,424,209"/><area shape="rect" id="node5" href="smemory_8c.html#aa2862f14356be7d9f12bfdfc175137a1" title="Expand the existing storage to accommodate more fill&#45;ins. " alt="" coords="171,107,242,133"/><area shape="rect" id="node9" href="smemory_8c.html#a29f7485dd32f85e996e16f2a199b002d" title="suser_free" alt="" coords="165,208,248,235"/><area shape="rect" id="node10" href="smemory_8c.html#a658f955c5532813bd0490502efae563f" title="smemory_usage" alt="" coords="147,259,266,285"/><area shape="rect" id="node11" href="smemory_8c.html#abc603ef3859778fb5631cf3d3b951de6" title="Allocate known working storage. Returns 0 if success, otherwise returns the number of bytes allocated..." alt="" coords="159,309,254,336"/><area shape="rect" id="node6" href="smemory_8c.html#ab59eea34474da95fb3dc125400a1287e" title="copy_mem_int" alt="" coords="321,132,428,159"/><area shape="rect" id="node7" href="smemory_8c.html#a00d00daa40d07c16e3ae6bfd87c70e3d" title="copy_mem_float" alt="" coords="315,31,434,57"/><area shape="rect" id="node8" href="smemory_8c.html#a4c226087c09a94ff40b92b14fa46fc53" title="user_bcopy" alt="" coords="330,81,419,108"/><area shape="rect" id="node12" href="slu__util_8h.html#a72be96e75e58564c4322ef9ef73ca65f" title="sp_ienv" alt="" coords="341,284,408,311"/><area shape="rect" id="node14" href="memory_8c.html#aaf51f82a79c361236a2d825a59a63403" title="intCalloc" alt="" coords="338,335,411,361"/><area shape="rect" id="node13" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="483,284,565,311"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9af26d0426eb0bb63755880f2e67e7b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sLUMemXpand </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#abd31f838aefffa46191d0d7dc36a96b2">MemType</a>&#160;</td>
          <td class="paramname"><em>mem_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Return value:   0 - successful return
              &gt; 0 - number of bytes allocated when run out of space
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a9af26d0426eb0bb63755880f2e67e7b7_cgraph.png" border="0" usemap="#slu__sdefs_8h_a9af26d0426eb0bb63755880f2e67e7b7_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a9af26d0426eb0bb63755880f2e67e7b7_cgraph" id="slu__sdefs_8h_a9af26d0426eb0bb63755880f2e67e7b7_cgraph">
<area shape="rect" id="node2" href="smemory_8c.html#aa2862f14356be7d9f12bfdfc175137a1" title="Expand the existing storage to accommodate more fill&#45;ins. " alt="" coords="190,81,261,108"/><area shape="rect" id="node7" href="smemory_8c.html#a658f955c5532813bd0490502efae563f" title="smemory_usage" alt="" coords="166,132,285,159"/><area shape="rect" id="node3" href="smemory_8c.html#ab59eea34474da95fb3dc125400a1287e" title="copy_mem_int" alt="" coords="340,5,447,32"/><area shape="rect" id="node4" href="smemory_8c.html#a00d00daa40d07c16e3ae6bfd87c70e3d" title="copy_mem_float" alt="" coords="334,56,453,83"/><area shape="rect" id="node5" href="smemory_8c.html#ad68adc1b6de3f821f9fb24cdcf24d281" title="suser_malloc" alt="" coords="344,107,443,133"/><area shape="rect" id="node6" href="smemory_8c.html#a4c226087c09a94ff40b92b14fa46fc53" title="user_bcopy" alt="" coords="349,157,438,184"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9035f0d2a50cf5d8e29287572bd1be83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sLUWorkFree </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b49252f1cab66e35ac47ac1afb2adec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float smach </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab50ebebf3a620086366b6c310d52d681"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smemory_usage </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a35b4a0e44c32443df609069021d27812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sp_sgemm </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>transa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>transb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose   
</h1>
</pre><pre></pre><pre>  sp_s performs one of the matrix-matrix operations</pre><pre>     C := alpha*op( A )*op( B ) + beta*C,</pre><pre>  where  op( X ) is one of</pre><pre>     op( X ) = X   or   op( X ) = X'   or   op( X ) = conjg( X' ),</pre><pre>  alpha and beta are scalars, and A, B and C are matrices, with op( A ) 
  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</pre><pre><h1>Parameters   
</h1>
</pre><pre></pre><pre>  TRANSA - (input) char*
           On entry, TRANSA specifies the form of op( A ) to be used in 
           the matrix multiplication as follows:   
              TRANSA = 'N' or 'n',  op( A ) = A.   
              TRANSA = 'T' or 't',  op( A ) = A'.   
              TRANSA = 'C' or 'c',  op( A ) = conjg( A' ).   
           Unchanged on exit.</pre><pre>  TRANSB - (input) char*
           On entry, TRANSB specifies the form of op( B ) to be used in 
           the matrix multiplication as follows:   
              TRANSB = 'N' or 'n',  op( B ) = B.   
              TRANSB = 'T' or 't',  op( B ) = B'.   
              TRANSB = 'C' or 'c',  op( B ) = conjg( B' ).   
           Unchanged on exit.</pre><pre>  M      - (input) int   
           On entry,  M  specifies  the number of rows of the matrix 
          op( A ) and of the matrix C.  M must be at least zero. 
          Unchanged on exit.</pre><pre>  N      - (input) int
           On entry,  N specifies the number of columns of the matrix 
          op( B ) and the number of columns of the matrix C. N must be 
          at least zero.
          Unchanged on exit.</pre><pre>  K      - (input) int
           On entry, K specifies the number of columns of the matrix 
          op( A ) and the number of rows of the matrix op( B ). K must 
          be at least  zero.   
          Unchanged on exit.</pre><pre>  ALPHA  - (input) float
           On entry, ALPHA specifies the scalar alpha.</pre><pre>  A      - (input) SuperMatrix*
           Matrix A with a sparse format, of dimension (A-&gt;nrow, A-&gt;ncol).
           Currently, the type of A can be:
               Stype = NC or NCP; Dtype = SLU_S; Mtype = GE. 
           In the future, more general A can be handled.</pre><pre>  B      - FLOAT PRECISION array of DIMENSION ( LDB, kb ), where kb is 
           n when TRANSB = 'N' or 'n',  and is  k otherwise.   
           Before entry with  TRANSB = 'N' or 'n',  the leading k by n 
           part of the array B must contain the matrix B, otherwise 
           the leading n by k part of the array B must contain the 
           matrix B.   
           Unchanged on exit.</pre><pre>  LDB    - (input) int
           On entry, LDB specifies the first dimension of B as declared 
           in the calling (sub) program. LDB must be at least max( 1, n ).  
           Unchanged on exit.</pre><pre>  BETA   - (input) float
           On entry, BETA specifies the scalar beta. When BETA is   
           supplied as zero then C need not be set on input.</pre><pre>  C      - FLOAT PRECISION array of DIMENSION ( LDC, n ).   
           Before entry, the leading m by n part of the array C must 
           contain the matrix C,  except when beta is zero, in which 
           case C need not be set on entry.   
           On exit, the array C is overwritten by the m by n matrix 
          ( alpha*op( A )*B + beta*C ).</pre><pre>  LDC    - (input) int
           On entry, LDC specifies the first dimension of C as declared 
           in the calling (sub)program. LDC must be at least max(1,m).   
           Unchanged on exit.</pre><pre>  ==== Sparse Level 3 Blas routine.   
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a35b4a0e44c32443df609069021d27812_cgraph.png" border="0" usemap="#slu__sdefs_8h_a35b4a0e44c32443df609069021d27812_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a35b4a0e44c32443df609069021d27812_cgraph" id="slu__sdefs_8h_a35b4a0e44c32443df609069021d27812_cgraph">
<area shape="rect" id="node2" href="slu__sdefs_8h.html#a9e543b2d14781b56ef349114012b4fc9" title="Performs one of the matrix&#45;vector operations y := alpha*A*x + beta*y, or y := alpha*A&#39;*x + beta*y..." alt="" coords="141,5,224,32"/><area shape="rect" id="node3" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="272,5,355,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9e543b2d14781b56ef349114012b4fc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sp_sgemv </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose   
</h1>
</pre><pre></pre><pre>  <a class="el" href="ssp__blas2_8c.html#a3a14fab0d3fc42c621199aed6962ab3e" title="Performs one of the matrix-vector operations y := alpha*A*x + beta*y, or y := alpha*A&#39;*x + beta*y...">sp_sgemv()</a>  performs one of the matrix-vector operations   
     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   
  where alpha and beta are scalars, x and y are vectors and A is a
  sparse A-&gt;nrow by A-&gt;ncol matrix.</pre><pre><h1>Parameters   
</h1>
</pre><pre></pre><pre>  TRANS  - (input) char*
           On entry, TRANS specifies the operation to be performed as   
           follows:   
              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.   
              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.   
              TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.</pre><pre>  ALPHA  - (input) float
           On entry, ALPHA specifies the scalar alpha.</pre><pre>  A      - (input) SuperMatrix*
           Matrix A with a sparse format, of dimension (A-&gt;nrow, A-&gt;ncol).
           Currently, the type of A can be:
               Stype = NC or NCP; Dtype = SLU_S; Mtype = GE. 
           In the future, more general A can be handled.</pre><pre>  X      - (input) float*, array of DIMENSION at least   
           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'   
           and at least   
           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.   
           Before entry, the incremented array X must contain the   
           vector x.</pre><pre>  INCX   - (input) int
           On entry, INCX specifies the increment for the elements of   
           X. INCX must not be zero.</pre><pre>  BETA   - (input) float
           On entry, BETA specifies the scalar beta. When BETA is   
           supplied as zero then Y need not be set on input.</pre><pre>  Y      - (output) float*,  array of DIMENSION at least   
           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'   
           and at least   
           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.   
           Before entry with BETA non-zero, the incremented array Y   
           must contain the vector y. On exit, Y is overwritten by the 
           updated vector y.</pre><pre>  INCY   - (input) int
           On entry, INCY specifies the increment for the elements of   
           Y. INCY must not be zero.</pre><pre>  ==== Sparse Level 2 Blas routine.   
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a9e543b2d14781b56ef349114012b4fc9_cgraph.png" border="0" usemap="#slu__sdefs_8h_a9e543b2d14781b56ef349114012b4fc9_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a9e543b2d14781b56ef349114012b4fc9_cgraph" id="slu__sdefs_8h_a9e543b2d14781b56ef349114012b4fc9_cgraph">
<area shape="rect" id="node2" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="136,5,219,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa6d287b6b9bcaf72a692343e614c429c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sp_strsv </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>  <a class="el" href="ssp__blas2_8c.html#ab9e8302d09840e67df27ddd4defaa621" title="Solves one of the systems of equations A*x = b, or A&#39;*x = b. ">sp_strsv()</a> solves one of the systems of equations   
      A*x = b,   or   A'*x = b,
  where b and x are n element vectors and A is a sparse unit , or   
  non-unit, upper or lower triangular matrix.   
  No test for singularity or near-singularity is included in this   
  routine. Such tests must be performed before calling this routine.</pre><pre><h1>Parameters   
</h1>
</pre><pre></pre><pre>  uplo   - (input) char*
           On entry, uplo specifies whether the matrix is an upper or   
            lower triangular matrix as follows:   
               uplo = 'U' or 'u'   A is an upper triangular matrix.   
               uplo = 'L' or 'l'   A is a lower triangular matrix.</pre><pre>  trans  - (input) char*
            On entry, trans specifies the equations to be solved as   
            follows:   
               trans = 'N' or 'n'   A*x = b.   
               trans = 'T' or 't'   A'*x = b.
               trans = 'C' or 'c'   A'*x = b.</pre><pre>  diag   - (input) char*
            On entry, diag specifies whether or not A is unit   
            triangular as follows:   
               diag = 'U' or 'u'   A is assumed to be unit triangular.   
               diag = 'N' or 'n'   A is not assumed to be unit   
                                   triangular.</pre><pre>  L       - (input) SuperMatrix*
            The factor L from the factorization Pr*A*Pc=L*U. Use
            compressed row subscripts storage for supernodes,
            i.e., L has types: Stype = SC, Dtype = SLU_S, Mtype = TRLU.</pre><pre>  U       - (input) SuperMatrix*
             The factor U from the factorization Pr*A*Pc=L*U.
             U has types: Stype = NC, Dtype = SLU_S, Mtype = TRU.</pre><pre>  x       - (input/output) float*
            Before entry, the incremented array X must contain the n   
            element right-hand side vector b. On exit, X is overwritten 
            with the solution vector x.</pre><pre>  info    - (output) int*
            If *info = -i, the i-th argument had an illegal value.
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_aa6d287b6b9bcaf72a692343e614c429c_cgraph.png" border="0" usemap="#slu__sdefs_8h_aa6d287b6b9bcaf72a692343e614c429c_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_aa6d287b6b9bcaf72a692343e614c429c_cgraph" id="slu__sdefs_8h_aa6d287b6b9bcaf72a692343e614c429c_cgraph">
<area shape="rect" id="node2" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="127,5,209,32"/><area shape="rect" id="node3" href="slu__cdefs_8h.html#a3e1230bff11a9e47c35555299bcdcf1b" title="floatCalloc" alt="" coords="126,56,210,83"/><area shape="rect" id="node4" href="slu__sdefs_8h.html#aab583b502d3953688a3fa27a9f4bbf1e" title="strsv_" alt="" coords="139,107,197,133"/><area shape="rect" id="node5" href="slu__sdefs_8h.html#ae29fbdb32369b70973b05d14fc3420c9" title="sgemv_" alt="" coords="134,157,202,184"/><area shape="rect" id="node6" href="ssp__blas2_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="137,208,199,235"/><area shape="rect" id="node7" href="ssp__blas2_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="132,259,204,285"/><area shape="rect" id="node8" href="ssp__blas2_8c.html#a25ea48f4f948c68a423f5bd3929e3c1f" title="Solves a dense upper triangular system. " alt="" coords="135,309,201,336"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a51486936a9ff5079afed80eb5bf8a3e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spanel_bmod </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>tempv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>   Performs numeric block updates (sup-panel) in topological order.
   It features: col-col, 2cols-col, 3cols-col, and sup-col updates.
   Special processing on the supernodal portion of L[*,j]</pre><pre>   Before entering this routine, the original nonzeros in the panel 
   were already copied into the spa[m,w].</pre><pre>   Updated/Output parameters-
   dense[0:m-1,w]: L[*,j:j+w-1] and U[*,j:j+w-1] are returned 
   collectively in the m-by-w vector dense[*]. 
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a51486936a9ff5079afed80eb5bf8a3e0_cgraph.png" border="0" usemap="#slu__sdefs_8h_a51486936a9ff5079afed80eb5bf8a3e0_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a51486936a9ff5079afed80eb5bf8a3e0_cgraph" id="slu__sdefs_8h_a51486936a9ff5079afed80eb5bf8a3e0_cgraph">
<area shape="rect" id="node2" href="slu__util_8h.html#a72be96e75e58564c4322ef9ef73ca65f" title="sp_ienv" alt="" coords="155,5,221,32"/><area shape="rect" id="node4" href="slu__sdefs_8h.html#aab583b502d3953688a3fa27a9f4bbf1e" title="strsv_" alt="" coords="159,56,217,83"/><area shape="rect" id="node5" href="spanel__bmod_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="157,107,219,133"/><area shape="rect" id="node6" href="slu__sdefs_8h.html#ae29fbdb32369b70973b05d14fc3420c9" title="sgemv_" alt="" coords="154,157,222,184"/><area shape="rect" id="node7" href="spanel__bmod_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="152,208,224,235"/><area shape="rect" id="node3" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="272,5,355,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a77baf210393e04fa71d4e73b5e60e556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spanel_dfs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panel_lsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>  Performs a symbolic factorization on a panel of columns [jcol, jcol+w).</pre><pre>  A supernode representative is the last column of a supernode.
  The nonzeros in U[*,j] are segments that end at supernodal
  representatives.</pre><pre>  The routine returns one list of the supernodal representatives
  in topological order of the dfs that generates them. This list is
  a superset of the topological order of each individual column within
  the panel. 
  The location of the first nonzero in each supernodal segment
  (supernodal entry location) is also returned. Each column has a 
  separate list for this purpose.</pre><pre>  Two marker arrays are used for dfs:
    marker[i] == jj, if i was visited during dfs of current column jj;
    marker1[i] &gt;= jcol, if i was visited by earlier columns in this panel;</pre><pre>  marker: A-row &ndash;&gt; A-row/col (0/1)
  repfnz: SuperA-col &ndash;&gt; PA-row
  parent: SuperA-col &ndash;&gt; SuperA-col
  xplore: SuperA-col &ndash;&gt; index to L-structure
</pre> 
</div>
</div>
<a class="anchor" id="acb8787465a6296109b9a306d5a315ff8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sPivotGrowth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>Compute the reciprocal pivot growth factor of the leading ncols columns
of the matrix, using the formula:
    min_j ( max_i(abs(A_ij)) / max_i(abs(U_ij)) )</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>ncols    (input) int
         The number of columns of matrices A, L and U.</pre><pre>A        (input) SuperMatrix*
         Original matrix A, permuted by columns, of dimension
         (A-&gt;nrow, A-&gt;ncol). The type of A can be:
         Stype = NC; Dtype = SLU_S; Mtype = GE.</pre><pre>L        (output) SuperMatrix*
         The factor L from the factorization Pr*A=L*U; use compressed row 
         subscripts storage for supernodes, i.e., L has type: 
         Stype = SC; Dtype = SLU_S; Mtype = TRLU.</pre><pre>U        (output) SuperMatrix*
         The factor U from the factorization Pr*A*Pc=L*U. Use column-wise
         storage scheme, i.e., U has types: Stype = NC;
         Dtype = SLU_S; Mtype = TRU.
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_acb8787465a6296109b9a306d5a315ff8_cgraph.png" border="0" usemap="#slu__sdefs_8h_acb8787465a6296109b9a306d5a315ff8_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_acb8787465a6296109b9a306d5a315ff8_cgraph" id="slu__sdefs_8h_acb8787465a6296109b9a306d5a315ff8_cgraph">
<area shape="rect" id="node2" href="slu__cdefs_8h.html#a1b49252f1cab66e35ac47ac1afb2adec" title="smach" alt="" coords="155,5,216,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad7ddf03faedae25b4d73e0b6b33bf50c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spivotL </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>usepr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iperm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iperm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
  Performs the numerical pivoting on the current column of L,
  and the CDIV operation.</pre><pre>  Pivot policy:
  (1) Compute thresh = u * max_(i&gt;=j) <a class="el" href="mc64ad_8c.html#a6a010865b10e541735fa2da8f3cd062d">abs(A_ij)</a>;
  (2) IF user specifies pivot row k and <a class="el" href="mc64ad_8c.html#a6a010865b10e541735fa2da8f3cd062d">abs(A_kj)</a> &gt;= thresh THEN
          pivot row = k;
      ELSE IF <a class="el" href="mc64ad_8c.html#a6a010865b10e541735fa2da8f3cd062d">abs(A_jj)</a> &gt;= thresh THEN
          pivot row = j;
      ELSE
          pivot row = m;</pre><pre>  Note: If you absolutely want to use a given pivot order, then set u=0.0.</pre><pre>  Return value: 0      success;
                i &gt; 0  U(i,i) is exactly zero.
</pre> 
</div>
</div>
<a class="anchor" id="a5cd6efad9d9fb7aef8a984f5e3cff66b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sPrint_CompCol_Matrix </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a25b29c47333295f4aa744e541e277ea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sPrint_Dense_Matrix </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a297455c494a78c098b2bf418edbc6b16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sprint_lu_col </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeb289a84407c9cbbb33cdf3dbb1dacbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sPrint_SuperNode_Matrix </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf9da2c45289246ef663fc4a96d1ad78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spruneL </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
  Prunes the L-structure of supernodes whose L-structure
  contains the current pivot row "pivrow"
</pre> 
</div>
</div>
<a class="anchor" id="a98d44fe59660f87330b0172151a76141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sqselect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1357f9a3b2ffb9522883ad84affa63e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sQuerySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&#160;</td>
          <td class="paramname"><em>mem_usage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
mem_usage consists of the following fields:</p>
<ul>
<li>for_lu (float)
     The amount of space used in bytes for the L data structures.</li>
<li>total_needed (float)
     The amount of space needed in bytes to perform factorization.

</li>
</ul>
</pre>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a1357f9a3b2ffb9522883ad84affa63e3_cgraph.png" border="0" usemap="#slu__sdefs_8h_a1357f9a3b2ffb9522883ad84affa63e3_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a1357f9a3b2ffb9522883ad84affa63e3_cgraph" id="slu__sdefs_8h_a1357f9a3b2ffb9522883ad84affa63e3_cgraph">
<area shape="rect" id="node2" href="slu__util_8h.html#a72be96e75e58564c4322ef9ef73ca65f" title="sp_ienv" alt="" coords="155,5,221,32"/><area shape="rect" id="node3" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="269,5,352,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6ad9d9454734717431356db0e8eb5deb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sreadhb </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a6ad9d9454734717431356db0e8eb5deb_cgraph.png" border="0" usemap="#slu__sdefs_8h_a6ad9d9454734717431356db0e8eb5deb_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a6ad9d9454734717431356db0e8eb5deb_cgraph" id="slu__sdefs_8h_a6ad9d9454734717431356db0e8eb5deb_cgraph">
<area shape="rect" id="node2" href="sreadhb_8c.html#a752858dee322b95e4175c3f5d42ad6cd" title="Eat up the rest of the current line. " alt="" coords="145,5,233,32"/><area shape="rect" id="node3" href="slu__sdefs_8h.html#aaef6f98786d0bd76103237385ddbeb9f" title="Allocate storage for original matrix A. " alt="" coords="148,56,231,83"/><area shape="rect" id="node6" href="sreadhb_8c.html#ab0bd0cdb6d30a7cb74e401aa6ac3bce1" title="sParseIntFormat" alt="" coords="130,107,249,133"/><area shape="rect" id="node7" href="sreadhb_8c.html#a97275461fb2f2435189f35f5dd7c3fce" title="sParseFloatFormat" alt="" coords="123,157,256,184"/><area shape="rect" id="node8" href="sreadhb_8c.html#afbec2a501b92e7e7bb13af2e21520522" title="ReadVector" alt="" coords="144,208,235,235"/><area shape="rect" id="node9" href="sreadhb_8c.html#ad90abece4b82f3f44fdefa92c28bda09" title="sReadValues" alt="" coords="139,259,239,285"/><area shape="rect" id="node10" href="sreadhb_8c.html#a3bae90f1a092dc5ebe39a5649809a9b7" title="FormFullA" alt="" coords="148,309,231,336"/><area shape="rect" id="node4" href="smemory_8c.html#a4a866452c5dcba66083ef463662955ee" title="floatMalloc" alt="" coords="304,31,389,57"/><area shape="rect" id="node5" href="memory_8c.html#a49bbe20102e5b541c8e8963afa2bd46a" title="intMalloc" alt="" coords="309,81,384,108"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab345670a95db3f9c4b9c451224db8227"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sreadmt </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad992a573876b4abfe192ec2bc207f6b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sreadrb </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_ad992a573876b4abfe192ec2bc207f6b0_cgraph.png" border="0" usemap="#slu__sdefs_8h_ad992a573876b4abfe192ec2bc207f6b0_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_ad992a573876b4abfe192ec2bc207f6b0_cgraph" id="slu__sdefs_8h_ad992a573876b4abfe192ec2bc207f6b0_cgraph">
<area shape="rect" id="node2" href="sreadrb_8c.html#ad40eef9e3223cc000a38a8fb326f1dd1" title="Eat up the rest of the current line. " alt="" coords="143,5,231,32"/><area shape="rect" id="node3" href="slu__sdefs_8h.html#aaef6f98786d0bd76103237385ddbeb9f" title="Allocate storage for original matrix A. " alt="" coords="145,56,228,83"/><area shape="rect" id="node6" href="sreadrb_8c.html#a3ff3c5edc1cf7301cff66260418cac52" title="sParseIntFormat" alt="" coords="127,107,246,133"/><area shape="rect" id="node7" href="sreadrb_8c.html#a40bcf62d1e9ac32095b5868b35cef780" title="sParseFloatFormat" alt="" coords="120,157,253,184"/><area shape="rect" id="node8" href="sreadrb_8c.html#afbec2a501b92e7e7bb13af2e21520522" title="ReadVector" alt="" coords="141,208,232,235"/><area shape="rect" id="node9" href="sreadrb_8c.html#a43a5fc149958a15cd7e3a30b2a1411cf" title="sReadValues" alt="" coords="137,259,237,285"/><area shape="rect" id="node10" href="sreadrb_8c.html#a3bae90f1a092dc5ebe39a5649809a9b7" title="FormFullA" alt="" coords="145,309,228,336"/><area shape="rect" id="node4" href="smemory_8c.html#a4a866452c5dcba66083ef463662955ee" title="floatMalloc" alt="" coords="301,31,387,57"/><area shape="rect" id="node5" href="memory_8c.html#a49bbe20102e5b541c8e8963afa2bd46a" title="intMalloc" alt="" coords="307,81,381,108"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae99cb18465c8992235a7bc003237f692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sreadtriple </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_ae99cb18465c8992235a7bc003237f692_cgraph.png" border="0" usemap="#slu__sdefs_8h_ae99cb18465c8992235a7bc003237f692_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_ae99cb18465c8992235a7bc003237f692_cgraph" id="slu__sdefs_8h_ae99cb18465c8992235a7bc003237f692_cgraph">
<area shape="rect" id="node2" href="slu__sdefs_8h.html#aaef6f98786d0bd76103237385ddbeb9f" title="Allocate storage for original matrix A. " alt="" coords="136,31,219,57"/><area shape="rect" id="node3" href="smemory_8c.html#a4a866452c5dcba66083ef463662955ee" title="floatMalloc" alt="" coords="267,5,352,32"/><area shape="rect" id="node4" href="memory_8c.html#a49bbe20102e5b541c8e8963afa2bd46a" title="intMalloc" alt="" coords="272,56,347,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab5b2859bf1ef1900506dfa702574c6ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sSetRWork </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_ab5b2859bf1ef1900506dfa702574c6ad_cgraph.png" border="0" usemap="#slu__sdefs_8h_ab5b2859bf1ef1900506dfa702574c6ad_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_ab5b2859bf1ef1900506dfa702574c6ad_cgraph" id="slu__sdefs_8h_ab5b2859bf1ef1900506dfa702574c6ad_cgraph">
<area shape="rect" id="node2" href="slu__util_8h.html#a72be96e75e58564c4322ef9ef73ca65f" title="sp_ienv" alt="" coords="144,5,211,32"/><area shape="rect" id="node4" href="slu__sdefs_8h.html#a2d734e40276e89a3ef04bf79bc21acb6" title="Fills a float precision array with a given value. " alt="" coords="156,56,199,83"/><area shape="rect" id="node3" href="input__error_8c.html#a5832852b8f6777484b6f55dd79e67d86" title="input_error" alt="" coords="259,5,341,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a60e60255360fae0b1458da070690a3a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ssnode_bmod </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_a60e60255360fae0b1458da070690a3a2_cgraph.png" border="0" usemap="#slu__sdefs_8h_a60e60255360fae0b1458da070690a3a2_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_a60e60255360fae0b1458da070690a3a2_cgraph" id="slu__sdefs_8h_a60e60255360fae0b1458da070690a3a2_cgraph">
<area shape="rect" id="node2" href="slu__sdefs_8h.html#aab583b502d3953688a3fa27a9f4bbf1e" title="strsv_" alt="" coords="164,5,223,32"/><area shape="rect" id="node3" href="slu__sdefs_8h.html#ae29fbdb32369b70973b05d14fc3420c9" title="sgemv_" alt="" coords="159,56,227,83"/><area shape="rect" id="node4" href="scolumn__bmod_8c.html#aa8bbeb2abbd5a10ac13fa9b48504691c" title="Solves a dense UNIT lower triangular system. " alt="" coords="162,107,225,133"/><area shape="rect" id="node5" href="scolumn__bmod_8c.html#ab452e957171a4d0d9cfe6abb3d8a950c" title="Performs a dense matrix&#45;vector multiply: Mxvec = Mxvec + M * vec. " alt="" coords="157,157,229,184"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad9d54c8dfc11f1e034b4b7175be60ffb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ssnode_dfs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>kcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>asub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>xa_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>xa_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
   <a class="el" href="ssnode__dfs_8c.html#a5b66817c89ddf9f74e4773b49dc72872">ssnode_dfs()</a> - Determine the union of the row structures of those 
   columns within the relaxed snode.
   Note: The relaxed snodes are leaves of the supernodal etree, therefore, 
   the portion outside the rectangular supernode must be zero.</pre><pre><h1>Return value
</h1>
</pre><pre>
    0   success;
   &gt;0   number of bytes allocated when run out of memory.
</pre> 
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="slu__sdefs_8h_ad9d54c8dfc11f1e034b4b7175be60ffb_cgraph.png" border="0" usemap="#slu__sdefs_8h_ad9d54c8dfc11f1e034b4b7175be60ffb_cgraph" alt=""/></div>
<map name="slu__sdefs_8h_ad9d54c8dfc11f1e034b4b7175be60ffb_cgraph" id="slu__sdefs_8h_ad9d54c8dfc11f1e034b4b7175be60ffb_cgraph">
<area shape="rect" id="node2" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7" title="Expand the data structures for L and U during the factorization. " alt="" coords="144,107,256,133"/><area shape="rect" id="node3" href="smemory_8c.html#aa2862f14356be7d9f12bfdfc175137a1" title="Expand the existing storage to accommodate more fill&#45;ins. " alt="" coords="329,81,399,108"/><area shape="rect" id="node8" href="smemory_8c.html#a658f955c5532813bd0490502efae563f" title="smemory_usage" alt="" coords="305,132,423,159"/><area shape="rect" id="node4" href="smemory_8c.html#ab59eea34474da95fb3dc125400a1287e" title="copy_mem_int" alt="" coords="479,5,585,32"/><area shape="rect" id="node5" href="smemory_8c.html#a00d00daa40d07c16e3ae6bfd87c70e3d" title="copy_mem_float" alt="" coords="473,56,591,83"/><area shape="rect" id="node6" href="smemory_8c.html#ad68adc1b6de3f821f9fb24cdcf24d281" title="suser_malloc" alt="" coords="483,107,581,133"/><area shape="rect" id="node7" href="smemory_8c.html#a4c226087c09a94ff40b92b14fa46fc53" title="user_bcopy" alt="" coords="487,157,577,184"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a68de665c44346f6eacfe87e9f3c2a1e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strsm_ </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aab583b502d3953688a3fa27a9f4bbf1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strsv_ </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 8 2016 18:40:07 for SuperLU by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>

"//\n"
"//   Copyright 2013-2018 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Common\n"
"//----------------------------------------------------------\n"
"\n"
"// XXXdyu all handling of varying data can be managed by client code\n"
"#ifndef OSD_USER_VARYING_DECLARE\n"
"#define OSD_USER_VARYING_DECLARE\n"
"// type var;\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"#define OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"// layout(location = loc) in type var;\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_VERTEX\n"
"#define OSD_USER_VARYING_PER_VERTEX()\n"
"// output.var = var;\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_CONTROL_POINT\n"
"#define OSD_USER_VARYING_PER_CONTROL_POINT(ID_OUT, ID_IN)\n"
"// output[ID_OUT].var = input[ID_IN].var\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_EVAL_POINT\n"
"#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d)\n"
"// output.var =\n"
"//     mix(mix(input[a].var, input[b].var, UV.x),\n"
"//         mix(input[c].var, input[d].var, UV.x), UV.y)\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_EVAL_POINT_TRIANGLE\n"
"#define OSD_USER_VARYING_PER_EVAL_POINT_TRIANGLE(UV, a, b, c)\n"
"// output.var =\n"
"//     input[a].var * (1.0f-UV.x-UV.y) +\n"
"//     input[b].var * UV.x +\n"
"//     input[c].var * UV.y;\n"
"#endif\n"
"\n"
"#if __VERSION__ < 420\n"
"    #define centroid\n"
"#endif\n"
"\n"
"struct ControlVertex {\n"
"    vec4 position;\n"
"#ifdef OSD_ENABLE_PATCH_CULL\n"
"    ivec3 clipFlag;\n"
"#endif\n"
"};\n"
"\n"
"// XXXdyu all downstream data can be handled by client code\n"
"struct OutputVertex {\n"
"    vec4 position;\n"
"    vec3 normal;\n"
"    vec3 tangent;\n"
"    vec3 bitangent;\n"
"    vec4 patchCoord; // u, v, faceLevel, faceId\n"
"    vec2 tessCoord; // tesscoord.st\n"
"#if defined OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    vec3 Nu;\n"
"    vec3 Nv;\n"
"#endif\n"
"};\n"
"\n"
"mat4 OsdModelViewProjectionMatrix();\n"
"int OsdGregoryQuadOffsetBase();\n"
"int OsdPrimitiveIdBase();\n"
"int OsdBaseVertex();\n"
"\n"
"#ifndef OSD_DISPLACEMENT_CALLBACK\n"
"#define OSD_DISPLACEMENT_CALLBACK\n"
"#endif\n"
"\n"
"// These are stored in OsdPatchParamBuffer indexed by the value returned\n"
"// from OsdGetPatchIndex() which is a function of the current PrimitiveID\n"
"// along with an optional client provided offset.\n"
"\n"
"uniform isamplerBuffer OsdPatchParamBuffer;\n"
"\n"
"int OsdGetPatchIndex(int primitiveId)\n"
"{\n"
"    return (primitiveId + OsdPrimitiveIdBase());\n"
"}\n"
"\n"
"ivec3 OsdGetPatchParam(int patchIndex)\n"
"{\n"
"    return texelFetch(OsdPatchParamBuffer, patchIndex).xyz;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// patch culling\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"#ifdef OSD_ENABLE_PATCH_CULL\n"
"\n"
"#define OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(P)                     "
"    vec4 clipPos = OsdModelViewProjectionMatrix() * P;          "
"    bvec3 clip0 = lessThan(clipPos.xyz, vec3(clipPos.w));       "
"    bvec3 clip1 = greaterThan(clipPos.xyz, -vec3(clipPos.w));   "
"    outpt.v.clipFlag = ivec3(clip0) + 2*ivec3(clip1);           "
"\n"
"#define OSD_PATCH_CULL(N)                            "
"    ivec3 clipFlag = ivec3(0);                       "
"    for(int i = 0; i < N; ++i) {                     "
"        clipFlag |= inpt[i].v.clipFlag;              "
"    }                                                "
"    if (clipFlag != ivec3(3) ) {                     "
"        gl_TessLevelInner[0] = 0;                    "
"        gl_TessLevelInner[1] = 0;                    "
"        gl_TessLevelOuter[0] = 0;                    "
"        gl_TessLevelOuter[1] = 0;                    "
"        gl_TessLevelOuter[2] = 0;                    "
"        gl_TessLevelOuter[3] = 0;                    "
"        return;                                      "
"    }\n"
"\n"
"#else\n"
"#define OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(P)\n"
"#define OSD_PATCH_CULL(N)\n"
"#endif\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Legacy Gregory\n"
"// ----------------------------------------------------------------------------\n"
"#if defined(OSD_PATCH_GREGORY) || defined(OSD_PATCH_GREGORY_BOUNDARY)\n"
"\n"
"#define M_PI 3.14159265359f\n"
"\n"
"// precomputed catmark coefficient table up to valence 29\n"
"uniform float OsdCatmarkCoefficient[30] = float[](\n"
"    0, 0, 0, 0.812816, 0.500000, 0.363644, 0.287514,\n"
"    0.238688, 0.204544, 0.179229, 0.159657,\n"
"    0.144042, 0.131276, 0.120632, 0.111614,\n"
"    0.103872, 0.09715, 0.0912559, 0.0860444,\n"
"    0.0814022, 0.0772401, 0.0734867, 0.0700842,\n"
"    0.0669851, 0.0641504, 0.0615475, 0.0591488,\n"
"    0.0569311, 0.0548745, 0.0529621\n"
"    );\n"
"\n"
"float\n"
"OsdComputeCatmarkCoefficient(int valence)\n"
"{\n"
"#if OSD_MAX_VALENCE < 30\n"
"    return OsdCatmarkCoefficient[valence];\n"
"#else\n"
"    if (valence < 30) {\n"
"        return OsdCatmarkCoefficient[valence];\n"
"    } else {\n"
"        float t = 2.0f * float(M_PI) / float(valence);\n"
"        return 1.0f / (valence * (cos(t) + 5.0f +\n"
"                                  sqrt((cos(t) + 9) * (cos(t) + 1)))/16.0f);\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"float cosfn(int n, int j) {\n"
"    return cos((2.0f * M_PI * j)/float(n));\n"
"}\n"
"\n"
"float sinfn(int n, int j) {\n"
"    return sin((2.0f * M_PI * j)/float(n));\n"
"}\n"
"\n"
"#if !defined OSD_MAX_VALENCE || OSD_MAX_VALENCE < 1\n"
"#undef OSD_MAX_VALENCE\n"
"#define OSD_MAX_VALENCE 4\n"
"#endif\n"
"\n"
"struct OsdPerVertexGregory {\n"
"    vec3 P;\n"
"    ivec3 clipFlag;\n"
"    int  valence;\n"
"    vec3 e0;\n"
"    vec3 e1;\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    int zerothNeighbor;\n"
"    vec3 org;\n"
"#endif\n"
"    vec3 r[OSD_MAX_VALENCE];\n"
"};\n"
"\n"
"struct OsdPerPatchVertexGregory {\n"
"    ivec3 patchParam;\n"
"    vec3 P;\n"
"    vec3 Ep;\n"
"    vec3 Em;\n"
"    vec3 Fp;\n"
"    vec3 Fm;\n"
"};\n"
"\n"
"#ifndef OSD_NUM_ELEMENTS\n"
"#define OSD_NUM_ELEMENTS 3\n"
"#endif\n"
"\n"
"uniform samplerBuffer OsdVertexBuffer;\n"
"uniform isamplerBuffer OsdValenceBuffer;\n"
"\n"
"vec3 OsdReadVertex(int vertexIndex)\n"
"{\n"
"    int index = int(OSD_NUM_ELEMENTS * (vertexIndex + OsdBaseVertex()));\n"
"    return vec3(texelFetch(OsdVertexBuffer, index).x,\n"
"                texelFetch(OsdVertexBuffer, index+1).x,\n"
"                texelFetch(OsdVertexBuffer, index+2).x);\n"
"}\n"
"\n"
"int OsdReadVertexValence(int vertexID)\n"
"{\n"
"    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1));\n"
"    return texelFetch(OsdValenceBuffer, index).x;\n"
"}\n"
"\n"
"int OsdReadVertexIndex(int vertexID, int valenceVertex)\n"
"{\n"
"    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1) + 1 + valenceVertex);\n"
"    return texelFetch(OsdValenceBuffer, index).x;\n"
"}\n"
"\n"
"uniform isamplerBuffer OsdQuadOffsetBuffer;\n"
"\n"
"int OsdReadQuadOffset(int primitiveID, int offsetVertex)\n"
"{\n"
"    int index = int(4*primitiveID+OsdGregoryQuadOffsetBase() + offsetVertex);\n"
"    return texelFetch(OsdQuadOffsetBuffer, index).x;\n"
"}\n"
"\n"
"void\n"
"OsdComputePerVertexGregory(int vID, vec3 P, out OsdPerVertexGregory v)\n"
"{\n"
"    v.clipFlag = ivec3(0);\n"
"\n"
"    int ivalence = OsdReadVertexValence(vID);\n"
"    v.valence = ivalence;\n"
"    int valence = abs(ivalence);\n"
"\n"
"    vec3 f[OSD_MAX_VALENCE];\n"
"    vec3 pos = P;\n"
"    vec3 opos = vec3(0);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    v.org = pos;\n"
"    int boundaryEdgeNeighbors[2];\n"
"    int currNeighbor = 0;\n"
"    int ibefore = 0;\n"
"    int zerothNeighbor = 0;\n"
"#endif\n"
"\n"
"    for (int i=0; i<valence; ++i) {\n"
"        int im = (i+valence-1)%valence;\n"
"        int ip = (i+1)%valence;\n"
"\n"
"        int idx_neighbor = OsdReadVertexIndex(vID, 2*i);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"        bool isBoundaryNeighbor = false;\n"
"        int valenceNeighbor = OsdReadVertexValence(idx_neighbor);\n"
"\n"
"        if (valenceNeighbor < 0) {\n"
"            isBoundaryNeighbor = true;\n"
"            if (currNeighbor<2) {\n"
"                boundaryEdgeNeighbors[currNeighbor] = idx_neighbor;\n"
"            }\n"
"            currNeighbor++;\n"
"            if (currNeighbor == 1) {\n"
"                ibefore = i;\n"
"                zerothNeighbor = i;\n"
"            } else {\n"
"                if (i-ibefore == 1) {\n"
"                    int tmp = boundaryEdgeNeighbors[0];\n"
"                    boundaryEdgeNeighbors[0] = boundaryEdgeNeighbors[1];\n"
"                    boundaryEdgeNeighbors[1] = tmp;\n"
"                    zerothNeighbor = i;\n"
"                }\n"
"            }\n"
"        }\n"
"#endif\n"
"\n"
"        vec3 neighbor = OsdReadVertex(idx_neighbor);\n"
"\n"
"        int idx_diagonal = OsdReadVertexIndex(vID, 2*i + 1);\n"
"        vec3 diagonal = OsdReadVertex(idx_diagonal);\n"
"\n"
"        int idx_neighbor_p = OsdReadVertexIndex(vID, 2*ip);\n"
"        vec3 neighbor_p = OsdReadVertex(idx_neighbor_p);\n"
"\n"
"        int idx_neighbor_m = OsdReadVertexIndex(vID, 2*im);\n"
"        vec3 neighbor_m = OsdReadVertex(idx_neighbor_m);\n"
"\n"
"        int idx_diagonal_m = OsdReadVertexIndex(vID, 2*im + 1);\n"
"        vec3 diagonal_m = OsdReadVertex(idx_diagonal_m);\n"
"\n"
"        f[i] = (pos * float(valence) + (neighbor_p + neighbor)*2.0f + diagonal) / (float(valence)+5.0f);\n"
"\n"
"        opos += f[i];\n"
"        v.r[i] = (neighbor_p-neighbor_m)/3.0f + (diagonal - diagonal_m)/6.0f;\n"
"    }\n"
"\n"
"    opos /= valence;\n"
"    v.P = vec4(opos, 1.0f).xyz;\n"
"\n"
"    vec3 e;\n"
"    v.e0 = vec3(0);\n"
"    v.e1 = vec3(0);\n"
"\n"
"    for(int i=0; i<valence; ++i) {\n"
"        int im = (i + valence -1) % valence;\n"
"        e = 0.5f * (f[i] + f[im]);\n"
"        v.e0 += cosfn(valence, i)*e;\n"
"        v.e1 += sinfn(valence, i)*e;\n"
"    }\n"
"    float ef = OsdComputeCatmarkCoefficient(valence);\n"
"    v.e0 *= ef;\n"
"    v.e1 *= ef;\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    v.zerothNeighbor = zerothNeighbor;\n"
"    if (currNeighbor == 1) {\n"
"        boundaryEdgeNeighbors[1] = boundaryEdgeNeighbors[0];\n"
"    }\n"
"\n"
"    if (ivalence < 0) {\n"
"        if (valence > 2) {\n"
"            v.P = (OsdReadVertex(boundaryEdgeNeighbors[0]) +\n"
"                   OsdReadVertex(boundaryEdgeNeighbors[1]) +\n"
"                   4.0f * pos)/6.0f;\n"
"        } else {\n"
"            v.P = pos;\n"
"        }\n"
"\n"
"        v.e0 = (OsdReadVertex(boundaryEdgeNeighbors[0]) -\n"
"                OsdReadVertex(boundaryEdgeNeighbors[1]))/6.0;\n"
"\n"
"        float k = float(float(valence) - 1.0f);    //k is the number of faces\n"
"        float c = cos(M_PI/k);\n"
"        float s = sin(M_PI/k);\n"
"        float gamma = -(4.0f*s)/(3.0f*k+c);\n"
"        float alpha_0k = -((1.0f+2.0f*c)*sqrt(1.0f+c))/((3.0f*k+c)*sqrt(1.0f-c));\n"
"        float beta_0 = s/(3.0f*k + c);\n"
"\n"
"        int idx_diagonal = OsdReadVertexIndex(vID, 2*zerothNeighbor + 1);\n"
"        vec3 diagonal = OsdReadVertex(idx_diagonal);\n"
"\n"
"        v.e1 = gamma * pos +\n"
"            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[0]) +\n"
"            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[1]) +\n"
"            beta_0 * diagonal;\n"
"\n"
"        for (int x=1; x<valence - 1; ++x) {\n"
"            int curri = ((x + zerothNeighbor)%valence);\n"
"            float alpha = (4.0f*sin((M_PI * float(x))/k))/(3.0f*k+c);\n"
"            float beta = (sin((M_PI * float(x))/k) + sin((M_PI * float(x+1))/k))/(3.0f*k+c);\n"
"\n"
"            int idx_neighbor = OsdReadVertexIndex(vID, 2*curri);\n"
"            vec3 neighbor = OsdReadVertex(idx_neighbor);\n"
"\n"
"            idx_diagonal = OsdReadVertexIndex(vID, 2*curri + 1);\n"
"            diagonal = OsdReadVertex(idx_diagonal);\n"
"\n"
"            v.e1 += alpha * neighbor + beta * diagonal;\n"
"        }\n"
"\n"
"        v.e1 /= 3.0f;\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void\n"
"OsdComputePerPatchVertexGregory(ivec3 patchParam, int ID, int primitiveID,\n"
"                                in OsdPerVertexGregory v[4],\n"
"                                out OsdPerPatchVertexGregory result)\n"
"{\n"
"    result.patchParam = patchParam;\n"
"    result.P = v[ID].P;\n"
"\n"
"    int i = ID;\n"
"    int ip = (i+1)%4;\n"
"    int im = (i+3)%4;\n"
"    int valence = abs(v[i].valence);\n"
"    int n = valence;\n"
"\n"
"    int start = OsdReadQuadOffset(primitiveID, i) & 0xff;\n"
"    int prev = (OsdReadQuadOffset(primitiveID, i) >> 8) & 0xff;\n"
"\n"
"    int start_m = OsdReadQuadOffset(primitiveID, im) & 0xff;\n"
"    int prev_p = (OsdReadQuadOffset(primitiveID, ip) >> 8) & 0xff;\n"
"\n"
"    int np = abs(v[ip].valence);\n"
"    int nm = abs(v[im].valence);\n"
"\n"
"    // Control Vertices based on :\n"
"    // \"Approximating Subdivision Surfaces with Gregory Patches\n"
"    //  for Hardware Tessellation\"\n"
"    // Loop, Schaefer, Ni, Castano (ACM ToG Siggraph Asia 2009)\n"
"    //\n"
"    //  P3         e3-      e2+         P2\n"
"    //     O--------O--------O--------O\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     |        | f3-    | f2+    |\n"
"    //     |        O        O        |\n"
"    // e3+ O------O            O------O e2-\n"
"    //     |     f3+          f2-     |\n"
"    //     |                          |\n"
"    //     |                          |\n"
"    //     |      f0-         f1+     |\n"
"    // e0- O------O            O------O e1+\n"
"    //     |        O        O        |\n"
"    //     |        | f0+    | f1-    |\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     O--------O--------O--------O\n"
"    //  P0         e0+      e1-         P1\n"
"    //\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    vec3 Em_ip;\n"
"    if (v[ip].valence < -2) {\n"
"        int j = (np + prev_p - v[ip].zerothNeighbor) % np;\n"
"        Em_ip = v[ip].P + cos((M_PI*j)/float(np-1))*v[ip].e0 + sin((M_PI*j)/float(np-1))*v[ip].e1;\n"
"    } else {\n"
"        Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p ) + v[ip].e1*sinfn(np, prev_p);\n"
"    }\n"
"\n"
"    vec3 Ep_im;\n"
"    if (v[im].valence < -2) {\n"
"        int j = (nm + start_m - v[im].zerothNeighbor) % nm;\n"
"        Ep_im = v[im].P + cos((M_PI*j)/float(nm-1))*v[im].e0 + sin((M_PI*j)/float(nm-1))*v[im].e1;\n"
"    } else {\n"
"        Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);\n"
"    }\n"
"\n"
"    if (v[i].valence < 0) {\n"
"        n = (n-1)*2;\n"
"    }\n"
"    if (v[im].valence < 0) {\n"
"        nm = (nm-1)*2;\n"
"    }\n"
"    if (v[ip].valence < 0) {\n"
"        np = (np-1)*2;\n"
"    }\n"
"\n"
"    if (v[i].valence > 2) {\n"
"        result.Ep = v[i].P + v[i].e0*cosfn(n, start) + v[i].e1*sinfn(n, start);\n"
"        result.Em = v[i].P + v[i].e0*cosfn(n, prev ) + v[i].e1*sinfn(n, prev);\n"
"\n"
"        float s1=3-2*cosfn(n,1)-cosfn(np,1);\n"
"        float s2=2*cosfn(n,1);\n"
"\n"
"        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"\n"
"    } else if (v[i].valence < -2) {\n"
"        int j = (valence + start - v[i].zerothNeighbor) % valence;\n"
"\n"
"        result.Ep = v[i].P + cos((M_PI*j)/float(valence-1))*v[i].e0 + sin((M_PI*j)/float(valence-1))*v[i].e1;\n"
"        j = (valence + prev - v[i].zerothNeighbor) % valence;\n"
"        result.Em = v[i].P + cos((M_PI*j)/float(valence-1))*v[i].e0 + sin((M_PI*j)/float(valence-1))*v[i].e1;\n"
"\n"
"        vec3 Rp = ((-2.0f * v[i].org - 1.0f * v[im].org) + (2.0f * v[ip].org + 1.0f * v[(i+2)%4].org))/3.0f;\n"
"        vec3 Rm = ((-2.0f * v[i].org - 1.0f * v[ip].org) + (2.0f * v[im].org + 1.0f * v[(i+2)%4].org))/3.0f;\n"
"\n"
"        float s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"        float s2 = 2*cosfn(n,1);\n"
"\n"
"        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"\n"
"        if (v[im].valence < 0) {\n"
"            s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"            result.Fp = result.Fm = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        } else if (v[ip].valence < 0) {\n"
"            s1 = 3.0f-2.0f*cos(2.0f*M_PI/n)-cos(2.0f*M_PI/nm);\n"
"            result.Fm = result.Fp = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"        }\n"
"\n"
"    } else if (v[i].valence == -2) {\n"
"        result.Ep = (2.0f * v[i].org + v[ip].org)/3.0f;\n"
"        result.Em = (2.0f * v[i].org + v[im].org)/3.0f;\n"
"        result.Fp = result.Fm = (4.0f * v[i].org + v[(i+2)%n].org + 2.0f * v[ip].org + 2.0f * v[im].org)/9.0f;\n"
"    }\n"
"\n"
"#else // not OSD_PATCH_GREGORY_BOUNDARY\n"
"\n"
"    result.Ep = v[i].P + v[i].e0 * cosfn(n, start) + v[i].e1*sinfn(n, start);\n"
"    result.Em = v[i].P + v[i].e0 * cosfn(n, prev ) + v[i].e1*sinfn(n, prev);\n"
"\n"
"    vec3 Em_ip = v[ip].P + v[ip].e0 * cosfn(np, prev_p ) + v[ip].e1*sinfn(np, prev_p);\n"
"    vec3 Ep_im = v[im].P + v[im].e0 * cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);\n"
"\n"
"    float s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"    float s2 = 2*cosfn(n,1);\n"
"\n"
"    result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"    s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"    result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"#endif\n"
"}\n"
"\n"
"#endif  // OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Legacy Face-varying\n"
"// ----------------------------------------------------------------------------\n"
"uniform samplerBuffer OsdFVarDataBuffer;\n"
"\n"
"#ifndef OSD_FVAR_WIDTH\n"
"#define OSD_FVAR_WIDTH 0\n"
"#endif\n"
"\n"
"// ------ extract from quads (catmark, bilinear) ---------\n"
"// XXX: only linear interpolation is supported\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_1(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        float v[4];                                                     "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 4;          "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = texelFetch(OsdFVarDataBuffer, index).s               "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_2(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        vec2 v[4];                                                      "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 4;          "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = vec2(texelFetch(OsdFVarDataBuffer, index).s,         "
"                        texelFetch(OsdFVarDataBuffer, index + 1).s);    "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_3(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        vec3 v[4];                                                      "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 4;          "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = vec3(texelFetch(OsdFVarDataBuffer, index).s,         "
"                        texelFetch(OsdFVarDataBuffer, index + 1).s,     "
"                        texelFetch(OsdFVarDataBuffer, index + 2).s);    "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_4(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        vec4 v[4];                                                      "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 4;          "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = vec4(texelFetch(OsdFVarDataBuffer, index).s,         "
"                        texelFetch(OsdFVarDataBuffer, index + 1).s,     "
"                        texelFetch(OsdFVarDataBuffer, index + 2).s,     "
"                        texelFetch(OsdFVarDataBuffer, index + 3).s);    "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"// ------ extract from triangles barycentric (loop) ---------\n"
"// XXX: no interpolation supported\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_1(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 3;          "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = texelFetch(OsdFVarDataBuffer, index).s;                "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_2(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 3;          "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = vec2(texelFetch(OsdFVarDataBuffer, index).s,           "
"                      texelFetch(OsdFVarDataBuffer, index + 1).s);      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_3(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 3;          "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = vec3(texelFetch(OsdFVarDataBuffer, index).s,           "
"                      texelFetch(OsdFVarDataBuffer, index + 1).s,       "
"                      texelFetch(OsdFVarDataBuffer, index + 2).s);      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_4(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 3;          "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = vec4(texelFetch(OsdFVarDataBuffer, index).s,           "
"                      texelFetch(OsdFVarDataBuffer, index + 1).s,       "
"                      texelFetch(OsdFVarDataBuffer, index + 2).s,       "
"                      texelFetch(OsdFVarDataBuffer, index + 3).s);      "
"    }\n"
"\n"
"\n"

"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"\n"
"layout(local_size_x=WORK_GROUP_SIZE, local_size_y=1, local_size_z=1) in;\n"
"layout(std430) buffer;\n"
"\n"
"// source and destination buffers\n"
"\n"
"uniform int srcOffset = 0;\n"
"uniform int dstOffset = 0;\n"
"layout(binding=0) buffer src_buffer      { float    srcVertexBuffer[]; };\n"
"layout(binding=1) buffer dst_buffer      { float    dstVertexBuffer[]; };\n"
"\n"
"// derivative buffers (if needed)\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_1ST_DERIVATIVES)\n"
"uniform ivec3 duDesc;\n"
"uniform ivec3 dvDesc;\n"
"layout(binding=2) buffer du_buffer   { float duBuffer[]; };\n"
"layout(binding=3) buffer dv_buffer   { float dvBuffer[]; };\n"
"#endif\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_2ND_DERIVATIVES)\n"
"uniform ivec3 duuDesc;\n"
"uniform ivec3 duvDesc;\n"
"uniform ivec3 dvvDesc;\n"
"layout(binding=10) buffer duu_buffer   { float duuBuffer[]; };\n"
"layout(binding=11) buffer duv_buffer   { float duvBuffer[]; };\n"
"layout(binding=12) buffer dvv_buffer   { float dvvBuffer[]; };\n"
"#endif\n"
"\n"
"// stencil buffers\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_KERNEL_EVAL_STENCILS)\n"
"\n"
"uniform int batchStart = 0;\n"
"uniform int batchEnd = 0;\n"
"layout(binding=4) buffer stencilSizes    { int      _sizes[];   };\n"
"layout(binding=5) buffer stencilOffsets  { int      _offsets[]; };\n"
"layout(binding=6) buffer stencilIndices  { int      _indices[]; };\n"
"layout(binding=7) buffer stencilWeights  { float    _weights[]; };\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_1ST_DERIVATIVES)\n"
"layout(binding=8) buffer stencilDuWeights { float  _duWeights[]; };\n"
"layout(binding=9) buffer stencilDvWeights { float  _dvWeights[]; };\n"
"#endif\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_2ND_DERIVATIVES)\n"
"layout(binding=13) buffer stencilDuuWeights { float  _duuWeights[]; };\n"
"layout(binding=14) buffer stencilDuvWeights { float  _duvWeights[]; };\n"
"layout(binding=15) buffer stencilDvvWeights { float  _dvvWeights[]; };\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"// patch buffers\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_KERNEL_EVAL_PATCHES)\n"
"\n"
"layout(binding=4) buffer patchArray_buffer { OsdPatchArray patchArrayBuffer[]; };\n"
"layout(binding=5) buffer patchCoord_buffer { OsdPatchCoord patchCoords[]; };\n"
"layout(binding=6) buffer patchIndex_buffer { int patchIndexBuffer[]; };\n"
"layout(binding=7) buffer patchParam_buffer { OsdPatchParam patchParamBuffer[]; };\n"
"\n"
"OsdPatchCoord GetPatchCoord(int coordIndex)\n"
"{\n"
"    return patchCoords[coordIndex];\n"
"}\n"
"\n"
"OsdPatchArray GetPatchArray(int arrayIndex)\n"
"{\n"
"    return patchArrayBuffer[arrayIndex];\n"
"}\n"
"\n"
"OsdPatchParam GetPatchParam(int patchIndex)\n"
"{\n"
"    return patchParamBuffer[patchIndex];\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"struct Vertex {\n"
"    float vertexData[LENGTH];\n"
"};\n"
"\n"
"void clear(out Vertex v) {\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        v.vertexData[i] = 0;\n"
"    }\n"
"}\n"
"\n"
"Vertex readVertex(int index) {\n"
"    Vertex v;\n"
"    int vertexIndex = srcOffset + index * SRC_STRIDE;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        v.vertexData[i] = srcVertexBuffer[vertexIndex + i];\n"
"    }\n"
"    return v;\n"
"}\n"
"\n"
"void writeVertex(int index, Vertex v) {\n"
"    int vertexIndex = dstOffset + index * DST_STRIDE;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        dstVertexBuffer[vertexIndex + i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void addWithWeight(inout Vertex v, const Vertex src, float weight) {\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        v.vertexData[i] += weight * src.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_1ST_DERIVATIVES)\n"
"void writeDu(int index, Vertex du) {\n"
"    int duIndex = duDesc.x + index * duDesc.z;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        duBuffer[duIndex + i] = du.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDv(int index, Vertex dv) {\n"
"    int dvIndex = dvDesc.x + index * dvDesc.z;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        dvBuffer[dvIndex + i] = dv.vertexData[i];\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_2ND_DERIVATIVES)\n"
"void writeDuu(int index, Vertex duu) {\n"
"    int duuIndex = duuDesc.x + index * duuDesc.z;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        duuBuffer[duuIndex + i] = duu.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDuv(int index, Vertex duv) {\n"
"    int duvIndex = duvDesc.x + index * duvDesc.z;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        duvBuffer[duvIndex + i] = duv.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDvv(int index, Vertex dvv) {\n"
"    int dvvIndex = dvvDesc.x + index * dvvDesc.z;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        dvvBuffer[dvvIndex + i] = dvv.vertexData[i];\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_KERNEL_EVAL_STENCILS)\n"
"\n"
"void main() {\n"
"\n"
"    int current = int(gl_GlobalInvocationID.x) + batchStart;\n"
"\n"
"    if (current>=batchEnd) {\n"
"        return;\n"
"    }\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    int offset = _offsets[current],\n"
"        size   = _sizes[current];\n"
"\n"
"    for (int stencil = 0; stencil < size; ++stencil) {\n"
"        int vindex = offset + stencil;\n"
"        addWithWeight(\n"
"            dst, readVertex(_indices[vindex]), _weights[vindex]);\n"
"    }\n"
"\n"
"    writeVertex(current, dst);\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_1ST_DERIVATIVES)\n"
"    Vertex du, dv;\n"
"    clear(du);\n"
"    clear(dv);\n"
"    for (int i=0; i<size; ++i) {\n"
"        // expects the compiler optimizes readVertex out here.\n"
"        Vertex src = readVertex(_indices[offset+i]);\n"
"        addWithWeight(du, src, _duWeights[offset+i]);\n"
"        addWithWeight(dv, src, _dvWeights[offset+i]);\n"
"    }\n"
"\n"
"    if (duDesc.y > 0) { // length\n"
"        writeDu(current, du);\n"
"    }\n"
"    if (dvDesc.y > 0) {\n"
"        writeDv(current, dv);\n"
"    }\n"
"#endif\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_2ND_DERIVATIVES)\n"
"    Vertex duu, duv, dvv;\n"
"    clear(duu);\n"
"    clear(duv);\n"
"    clear(dvv);\n"
"    for (int i=0; i<size; ++i) {\n"
"        // expects the compiler optimizes readVertex out here.\n"
"        Vertex src = readVertex(_indices[offset+i]);\n"
"        addWithWeight(duu, src, _duuWeights[offset+i]);\n"
"        addWithWeight(duv, src, _duvWeights[offset+i]);\n"
"        addWithWeight(dvv, src, _dvvWeights[offset+i]);\n"
"    }\n"
"\n"
"    if (duuDesc.y > 0) { // length\n"
"        writeDuu(current, duu);\n"
"    }\n"
"    if (duvDesc.y > 0) {\n"
"        writeDuv(current, duv);\n"
"    }\n"
"    if (dvvDesc.y > 0) {\n"
"        writeDvv(current, dvv);\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_KERNEL_EVAL_PATCHES)\n"
"\n"
"// PERFORMANCE: stride could be constant, but not as significant as length\n"
"\n"
"void main() {\n"
"\n"
"    int current = int(gl_GlobalInvocationID.x);\n"
"\n"
"    OsdPatchCoord coord = GetPatchCoord(current);\n"
"    OsdPatchArray array = GetPatchArray(coord.arrayIndex);\n"
"    OsdPatchParam param = GetPatchParam(coord.patchIndex);\n"
"\n"
"    int patchType = OsdPatchParamIsRegular(param) ? array.regDesc : array.desc;\n"
"\n"
"    float wP[20], wDu[20], wDv[20], wDuu[20], wDuv[20], wDvv[20];\n"
"    int nPoints = OsdEvaluatePatchBasis(patchType, param,\n"
"        coord.s, coord.t, wP, wDu, wDv, wDuu, wDuv, wDvv);\n"
"\n"
"    Vertex dst, du, dv, duu, duv, dvv;\n"
"    clear(dst);\n"
"    clear(du);\n"
"    clear(dv);\n"
"    clear(duu);\n"
"    clear(duv);\n"
"    clear(dvv);\n"
"\n"
"    int indexBase = array.indexBase + array.stride *\n"
"                (coord.patchIndex - array.primitiveIdBase);\n"
"\n"
"    for (int cv = 0; cv < nPoints; ++cv) {\n"
"        int index = patchIndexBuffer[indexBase + cv];\n"
"        addWithWeight(dst, readVertex(index), wP[cv]);\n"
"        addWithWeight(du, readVertex(index), wDu[cv]);\n"
"        addWithWeight(dv, readVertex(index), wDv[cv]);\n"
"        addWithWeight(duu, readVertex(index), wDuu[cv]);\n"
"        addWithWeight(duv, readVertex(index), wDuv[cv]);\n"
"        addWithWeight(dvv, readVertex(index), wDvv[cv]);\n"
"    }\n"
"    writeVertex(current, dst);\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_1ST_DERIVATIVES)\n"
"    if (duDesc.y > 0) { // length\n"
"        writeDu(current, du);\n"
"    }\n"
"    if (dvDesc.y > 0) {\n"
"        writeDv(current, dv);\n"
"    }\n"
"#endif\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_2ND_DERIVATIVES)\n"
"    if (duuDesc.y > 0) { // length\n"
"        writeDuu(current, duu);\n"
"    }\n"
"    if (duvDesc.y > 0) { // length\n"
"        writeDuv(current, duv);\n"
"    }\n"
"    if (dvvDesc.y > 0) {\n"
"        writeDvv(current, dvv);\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"#endif\n"
"\n"

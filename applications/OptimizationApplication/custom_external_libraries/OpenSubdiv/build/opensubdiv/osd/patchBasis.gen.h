"//\n"
"//   Copyright 2016-2018 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"#ifndef OPENSUBDIV3_OSD_PATCH_BASIS_H\n"
"#define OPENSUBDIV3_OSD_PATCH_BASIS_H\n"
"\n"
"/// This is an implementation of the functionality from far/patchBasis.h\n"
"/// which can be used from client shader and kernel code, i.e for\n"
"/// GLSL, HLSL, CUDA, OpenCL, Metal, and C++ shaders and kernels.\n"
"///\n"
"/// This is defined within the OpenSubdiv::Osd namespace for C++, but\n"
"/// the methods and types also have an Osd prefix for consistency with\n"
"/// environments (e.g. GLSL, etc.) where C++ namespaces are not available.\n"
"\n"
"#if !defined(OSD_PATCH_BASIS_GLSL) && "
"    !defined(OSD_PATCH_BASIS_HLSL) && "
"    !defined(OSD_PATCH_BASIS_CUDA) && "
"    !defined(OSD_PATCH_BASIS_OPENCL) && "
"    !defined(OSD_PATCH_BASIS_METAL)\n"
"\n"
"#include \"../version.h\"\n"
"\n"
"#include \"../osd/patchBasisTypes.h\"\n"
"\n"
"namespace OpenSubdiv {\n"
"namespace OPENSUBDIV_VERSION {\n"
"\n"
"namespace Osd {\n"
"\n"
"#endif\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisLinear(OSD_REAL s, OSD_REAL t,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDs, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDt, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDss, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDst, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDtt, 4)) {\n"
"\n"
"    OSD_REAL sC = 1.0f - s;\n"
"    OSD_REAL tC = 1.0f - t;\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        wP[0] = sC * tC;\n"
"        wP[1] =  s * tC;\n"
"        wP[2] =  s * t;\n"
"        wP[3] = sC * t;\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        wDs[0] = -tC;\n"
"        wDs[1] =  tC;\n"
"        wDs[2] =   t;\n"
"        wDs[3] =  -t;\n"
"\n"
"        wDt[0] = -sC;\n"
"        wDt[1] =  -s;\n"
"        wDt[2] =   s;\n"
"        wDt[3] =  sC;\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            for(int i = 0; i < 4; ++i) {\n"
"                wDss[i] = 0.0f;\n"
"                wDtt[i] = 0.0f;\n"
"            }\n"
"\n"
"            wDst[0] =  1.0f;\n"
"            wDst[1] = -1.0f;\n"
"            wDst[2] =  1.0f;\n"
"            wDst[3] = -1.0f;\n"
"        }\n"
"    }\n"
"    return 4;\n"
"}\n"
"\n"
"// namespace {\n"
"    //\n"
"    //  Cubic BSpline curve basis evaluation:\n"
"    //\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBSplineCurve(OSD_REAL t,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDP2, 4)) {\n"
"\n"
"        const OSD_REAL one6th = OSD_REAL_CAST(1.0f / 6.0f);\n"
"\n"
"        OSD_REAL t2 = t * t;\n"
"        OSD_REAL t3 = t * t2;\n"
"\n"
"        wP[0] = one6th * (1.0f - 3.0f*(t -      t2) -      t3);\n"
"        wP[1] = one6th * (4.0f           - 6.0f*t2  + 3.0f*t3);\n"
"        wP[2] = one6th * (1.0f + 3.0f*(t +      t2  -      t3));\n"
"        wP[3] = one6th * (                                 t3);\n"
"\n"
"        if (OSD_OPTIONAL(wDP)) {\n"
"            wDP[0] = -0.5f*t2 +      t - 0.5f;\n"
"            wDP[1] =  1.5f*t2 - 2.0f*t;\n"
"            wDP[2] = -1.5f*t2 +      t + 0.5f;\n"
"            wDP[3] =  0.5f*t2;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDP2)) {\n"
"            wDP2[0] = -       t + 1.0f;\n"
"            wDP2[1] =  3.0f * t - 2.0f;\n"
"            wDP2[2] = -3.0f * t + 1.0f;\n"
"            wDP2[3] =         t;\n"
"        }\n"
"    }\n"
"\n"
"    //\n"
"    //  Weight adjustments to account for phantom end points:\n"
"    //\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_adjustBSplineBoundaryWeights(\n"
"            int boundary,\n"
"            OSD_INOUT_ARRAY(OSD_REAL, w, 16)) {\n"
"\n"
"        if ((boundary & 1) != 0) {\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                w[i + 8] -= w[i + 0];\n"
"                w[i + 4] += w[i + 0] * 2.0f;\n"
"                w[i + 0]  = 0.0f;\n"
"            }\n"
"        }\n"
"        if ((boundary & 2) != 0) {\n"
"            for (int i = 0; i < 16; i += 4) {\n"
"                w[i + 1] -= w[i + 3];\n"
"                w[i + 2] += w[i + 3] * 2.0f;\n"
"                w[i + 3]  = 0.0f;\n"
"            }\n"
"        }\n"
"        if ((boundary & 4) != 0) {\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                w[i +  4] -= w[i + 12];\n"
"                w[i +  8] += w[i + 12] * 2.0f;\n"
"                w[i + 12]  = 0.0f;\n"
"            }\n"
"        }\n"
"        if ((boundary & 8) != 0) {\n"
"            for (int i = 0; i < 16; i += 4) {\n"
"                w[i + 2] -= w[i + 0];\n"
"                w[i + 1] += w[i + 0] * 2.0f;\n"
"                w[i + 0]  = 0.0f;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_boundBasisBSpline(\n"
"            int boundary,\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wP, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDs, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDt, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDss, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDst, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"\n"
"        if (OSD_OPTIONAL(wP)) {\n"
"            Osd_adjustBSplineBoundaryWeights(boundary, wP);\n"
"        }\n"
"        if (OSD_OPTIONAL(wDs && wDt)) {\n"
"            Osd_adjustBSplineBoundaryWeights(boundary, wDs);\n"
"            Osd_adjustBSplineBoundaryWeights(boundary, wDt);\n"
"\n"
"            if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"                Osd_adjustBSplineBoundaryWeights(boundary, wDss);\n"
"                Osd_adjustBSplineBoundaryWeights(boundary, wDst);\n"
"                Osd_adjustBSplineBoundaryWeights(boundary, wDtt);\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"// } // end namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"Osd_EvalBasisBSpline(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"\n"
"    OSD_REAL sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];\n"
"\n"
"    Osd_evalBSplineCurve(s, sWeights, OSD_OPTIONAL_INIT(wDs, dsWeights), OSD_OPTIONAL_INIT(wDss, dssWeights));\n"
"    Osd_evalBSplineCurve(t, tWeights, OSD_OPTIONAL_INIT(wDt, dtWeights), OSD_OPTIONAL_INIT(wDtt, dttWeights));\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wP[4*i+j] = sWeights[j] * tWeights[i];\n"
"            }\n"
"        }\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wDs[4*i+j] = dsWeights[j] * tWeights[i];\n"
"                wDt[4*i+j] = sWeights[j] * dtWeights[i];\n"
"            }\n"
"        }\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                for (int j = 0; j < 4; ++j) {\n"
"                    wDss[4*i+j] = dssWeights[j] * tWeights[i];\n"
"                    wDst[4*i+j] = dsWeights[j] * dtWeights[i];\n"
"                    wDtt[4*i+j] = sWeights[j] * dttWeights[i];\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"    return 16;\n"
"}\n"
"\n"
"// namespace {\n"
"    //\n"
"    //  Cubic Bezier curve basis evaluation:\n"
"    //\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBezierCurve(\n"
"        OSD_REAL t,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDP2, 4)) {\n"
"\n"
"        // The four uniform cubic Bezier basis functions (in terms of t and its\n"
"        // complement tC) evaluated at t:\n"
"        OSD_REAL t2 = t*t;\n"
"        OSD_REAL tC = 1.0f - t;\n"
"        OSD_REAL tC2 = tC * tC;\n"
"\n"
"        wP[0] = tC2 * tC;\n"
"        wP[1] = tC2 * t * 3.0f;\n"
"        wP[2] = t2 * tC * 3.0f;\n"
"        wP[3] = t2 * t;\n"
"\n"
"        // Derivatives of the above four basis functions at t:\n"
"        if (OSD_OPTIONAL(wDP)) {\n"
"           wDP[0] = -3.0f * tC2;\n"
"           wDP[1] =  9.0f * t2 - 12.0f * t + 3.0f;\n"
"           wDP[2] = -9.0f * t2 +  6.0f * t;\n"
"           wDP[3] =  3.0f * t2;\n"
"        }\n"
"\n"
"        // Second derivatives of the basis functions at t:\n"
"        if (OSD_OPTIONAL(wDP2)) {\n"
"            wDP2[0] =   6.0f * tC;\n"
"            wDP2[1] =  18.0f * t - 12.0f;\n"
"            wDP2[2] = -18.0f * t +  6.0f;\n"
"            wDP2[3] =   6.0f * t;\n"
"        }\n"
"    }\n"
"// } // end namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"Osd_EvalBasisBezier(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"\n"
"    OSD_REAL sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];\n"
"\n"
"    Osd_evalBezierCurve(s, OSD_OPTIONAL_INIT(wP, sWeights), OSD_OPTIONAL_INIT(wDs, dsWeights), OSD_OPTIONAL_INIT(wDss, dssWeights));\n"
"    Osd_evalBezierCurve(t, OSD_OPTIONAL_INIT(wP, tWeights), OSD_OPTIONAL_INIT(wDt, dtWeights), OSD_OPTIONAL_INIT(wDtt, dttWeights));\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wP[4*i+j] = sWeights[j] * tWeights[i];\n"
"            }\n"
"        }\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wDs[4*i+j] = dsWeights[j] * tWeights[i];\n"
"                wDt[4*i+j] = sWeights[j] * dtWeights[i];\n"
"            }\n"
"        }\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                for (int j = 0; j < 4; ++j) {\n"
"                    wDss[4*i+j] = dssWeights[j] * tWeights[i];\n"
"                    wDst[4*i+j] = dsWeights[j] * dtWeights[i];\n"
"                    wDtt[4*i+j] = sWeights[j] * dttWeights[i];\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"    return 16;\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"Osd_EvalBasisGregory(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 20)) {\n"
"\n"
"    //  Indices of boundary and interior points and their corresponding Bezier points\n"
"    //  (this can be reduced with more direct indexing and unrolling of loops):\n"
"    //\n"
"    OSD_DATA_STORAGE_CLASS const int boundaryGregory[12] = OSD_ARRAY_12(int, 0, 1, 7, 5, 2, 6, 16, 12, 15, 17, 11, 10 );\n"
"    OSD_DATA_STORAGE_CLASS const int boundaryBezSCol[12] = OSD_ARRAY_12(int, 0, 1, 2, 3, 0, 3,  0,  3,  0,  1,  2,  3 );\n"
"    OSD_DATA_STORAGE_CLASS const int boundaryBezTRow[12] = OSD_ARRAY_12(int, 0, 0, 0, 0, 1, 1,  2,  2,  3,  3,  3,  3 );\n"
"\n"
"    OSD_DATA_STORAGE_CLASS const int interiorGregory[8] = OSD_ARRAY_8(int, 3, 4,  8, 9,  13, 14,  18, 19 );\n"
"    OSD_DATA_STORAGE_CLASS const int interiorBezSCol[8] = OSD_ARRAY_8(int, 1, 1,  2, 2,   2,  2,   1,  1 );\n"
"    OSD_DATA_STORAGE_CLASS const int interiorBezTRow[8] = OSD_ARRAY_8(int, 1, 1,  1, 1,   2,  2,   2,  2 );\n"
"\n"
"    //\n"
"    //  Bezier basis functions are denoted with B while the rational multipliers for the\n"
"    //  interior points will be denoted G -- so we have B(s), B(t) and G(s,t):\n"
"    //\n"
"    //  Directional Bezier basis functions B at s and t:\n"
"    OSD_REAL Bs[4], Bds[4], Bdss[4];\n"
"    OSD_REAL Bt[4], Bdt[4], Bdtt[4];\n"
"\n"
"    Osd_evalBezierCurve(s, Bs, OSD_OPTIONAL_INIT(wDs, Bds), OSD_OPTIONAL_INIT(wDss, Bdss));\n"
"    Osd_evalBezierCurve(t, Bt, OSD_OPTIONAL_INIT(wDt, Bdt), OSD_OPTIONAL_INIT(wDtt, Bdtt));\n"
"\n"
"    //  Rational multipliers G at s and t:\n"
"    OSD_REAL sC = 1.0f - s;\n"
"    OSD_REAL tC = 1.0f - t;\n"
"\n"
"    //  Use <= here to avoid compiler warnings -- the sums should always be non-negative:\n"
"    OSD_REAL df0 = s  + t;   df0 = (df0 <= 0.0f) ? 1.0f : (1.0f / df0);\n"
"    OSD_REAL df1 = sC + t;   df1 = (df1 <= 0.0f) ? 1.0f : (1.0f / df1);\n"
"    OSD_REAL df2 = sC + tC;  df2 = (df2 <= 0.0f) ? 1.0f : (1.0f / df2);\n"
"    OSD_REAL df3 = s  + tC;  df3 = (df3 <= 0.0f) ? 1.0f : (1.0f / df3);\n"
"\n"
"    //  Make sure the G[i] for pairs of interior points sum to 1 in all cases:\n"
"    OSD_REAL G[8] = OSD_ARRAY_8(OSD_REAL,  s*df0, (1.0f -  s*df0),\n"
"                                           t*df1, (1.0f -  t*df1),\n"
"                                          sC*df2, (1.0f - sC*df2),\n"
"                                          tC*df3, (1.0f - tC*df3) );\n"
"\n"
"    //  Combined weights for boundary and interior points:\n"
"    for (int i = 0; i < 12; ++i) {\n"
"        wP[boundaryGregory[i]] = Bs[boundaryBezSCol[i]] * Bt[boundaryBezTRow[i]];\n"
"    }\n"
"    for (int j = 0; j < 8; ++j) {\n"
"        wP[interiorGregory[j]] = Bs[interiorBezSCol[j]] * Bt[interiorBezTRow[j]] * G[j];\n"
"    }\n"
"\n"
"    //\n"
"    //  For derivatives, the basis functions for the interior points are rational and ideally\n"
"    //  require appropriate differentiation, i.e. product rule for the combination of B and G\n"
"    //  and the quotient rule for the rational G itself.  As initially proposed by Loop et al\n"
"    //  though, the approximation using the 16 Bezier points arising from the G(s,t) has\n"
"    //  proved adequate (and is what the GPU shaders use) so we continue to use that here.\n"
"    //\n"
"    //  An implementation of the true derivatives is provided and conditionally compiled for\n"
"    //  those that require it, e.g.:\n"
"    //\n"
"    //    dclyde's note: skipping half of the product rule like this does seem to change the\n"
"    //    result a lot in my tests.  This is not a runtime bottleneck for cloth sims anyway\n"
"    //    so I'm just using the accurate version.\n"
"    //\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        bool find_second_partials = OSD_OPTIONAL(wDs && wDst && wDtt);\n"
"\n"
"        //  Combined weights for boundary points -- simple tensor products:\n"
"        for (int i = 0; i < 12; ++i) {\n"
"            int iDst = boundaryGregory[i];\n"
"            int tRow = boundaryBezTRow[i];\n"
"            int sCol = boundaryBezSCol[i];\n"
"\n"
"            wDs[iDst] = Bds[sCol] * Bt[tRow];\n"
"            wDt[iDst] = Bdt[tRow] * Bs[sCol];\n"
"\n"
"            if (find_second_partials) {\n"
"                wDss[iDst] = Bdss[sCol] * Bt[tRow];\n"
"                wDst[iDst] = Bds[sCol] * Bdt[tRow];\n"
"                wDtt[iDst] = Bs[sCol] * Bdtt[tRow];\n"
"            }\n"
"        }\n"
"\n"
"#ifndef OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES\n"
"        //  Approximation to the true Gregory derivatives by differentiating the Bezier patch\n"
"        //  unique to the given (s,t), i.e. having F = (g^+ * f^+) + (g^- * f^-) as its four\n"
"        //  interior points:\n"
"        //\n"
"        //  Combined weights for interior points -- tensor products with G+ or G-:\n"
"        for (int j = 0; j < 8; ++j) {\n"
"            int iDst = interiorGregory[j];\n"
"            int tRow = interiorBezTRow[j];\n"
"            int sCol = interiorBezSCol[j];\n"
"\n"
"            wDs[iDst] = Bds[sCol] * Bt[tRow] * G[j];\n"
"            wDt[iDst] = Bdt[tRow] * Bs[sCol] * G[j];\n"
"\n"
"            if (find_second_partials) {\n"
"                wDss[iDst] = Bdss[sCol] * Bt[tRow] * G[j];\n"
"                wDst[iDst] = Bds[sCol] * Bdt[tRow] * G[j];\n"
"                wDtt[iDst] = Bs[sCol] * Bdtt[tRow] * G[j];\n"
"            }\n"
"        }\n"
"#else\n"
"        //  True Gregory derivatives using appropriate differentiation of composite functions:\n"
"        //\n"
"        //  Note that for G(s,t) = N(s,t) / D(s,t), all N' and D' are trivial constants (which\n"
"        //  simplifies things for higher order derivatives).  And while each pair of functions\n"
"        //  G (i.e. the G+ and G- corresponding to points f+ and f-) must sum to 1 to ensure\n"
"        //  Bezier equivalence (when f+ = f-), the pairs of G' must similarly sum to 0.  So we\n"
"        //  can potentially compute only one of the pair and negate the result for the other\n"
"        //  (and with 4 or 8 computations involving these constants, this is all very SIMD\n"
"        //  friendly...) but for now we treat all 8 independently for simplicity.\n"
"        //\n"
"        //float N[8] = OSD_ARRAY_8(float,    s,     t,      t,     sC,      sC,     tC,      tC,     s );\n"
"        OSD_REAL D[8] = OSD_ARRAY_8(OSD_REAL,  df0,   df0,    df1,    df1,     df2,    df2,     df3,   df3 );\n"
"\n"
"        OSD_DATA_STORAGE_CLASS const OSD_REAL Nds[8] = OSD_ARRAY_8(OSD_REAL, 1.0f, 0.0f,  0.0f, -1.0f, -1.0f,  0.0f,  0.0f,  1.0f );\n"
"        OSD_DATA_STORAGE_CLASS const OSD_REAL Ndt[8] = OSD_ARRAY_8(OSD_REAL, 0.0f, 1.0f,  1.0f,  0.0f,  0.0f, -1.0f, -1.0f,  0.0f );\n"
"\n"
"        OSD_DATA_STORAGE_CLASS const OSD_REAL Dds[8] = OSD_ARRAY_8(OSD_REAL, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f );\n"
"        OSD_DATA_STORAGE_CLASS const OSD_REAL Ddt[8] = OSD_ARRAY_8(OSD_REAL, 1.0f, 1.0f,  1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f );\n"
"        //  Combined weights for interior points -- (scaled) combinations of B, B', G and G':\n"
"        for (int k = 0; k < 8; ++k) {\n"
"            int iDst = interiorGregory[k];\n"
"            int tRow = interiorBezTRow[k];\n"
"            int sCol = interiorBezSCol[k];\n"
"\n"
"            //  Quotient rule for G' (re-expressed in terms of G to simplify (and D = 1/D)):\n"
"            OSD_REAL Gds = (Nds[k] - Dds[k] * G[k]) * D[k];\n"
"            OSD_REAL Gdt = (Ndt[k] - Ddt[k] * G[k]) * D[k];\n"
"\n"
"            //  Product rule combining B and B' with G and G':\n"
"            wDs[iDst] = (Bds[sCol] * G[k] + Bs[sCol] * Gds) * Bt[tRow];\n"
"            wDt[iDst] = (Bdt[tRow] * G[k] + Bt[tRow] * Gdt) * Bs[sCol];\n"
"\n"
"            if (find_second_partials) {\n"
"                OSD_REAL Dsqr_inv = D[k]*D[k];\n"
"\n"
"                OSD_REAL Gdss = 2.0f * Dds[k] * Dsqr_inv * (G[k] * Dds[k] - Nds[k]);\n"
"                OSD_REAL Gdst = Dsqr_inv * (2.0f * G[k] * Dds[k] * Ddt[k] - Nds[k] * Ddt[k] - Ndt[k] * Dds[k]);\n"
"                OSD_REAL Gdtt = 2.0f * Ddt[k] * Dsqr_inv * (G[k] * Ddt[k] - Ndt[k]);\n"
"\n"
"                wDss[iDst] = (Bdss[sCol] * G[k] + 2.0f * Bds[sCol] * Gds + Bs[sCol] * Gdss) * Bt[tRow];\n"
"                wDst[iDst] =  Bt[tRow] * (Bs[sCol] * Gdst + Bds[sCol] * Gdt) +\n"
"                             Bdt[tRow] * (Bds[sCol] * G[k] + Bs[sCol] * Gds);\n"
"                wDtt[iDst] = (Bdtt[tRow] * G[k] + 2.0f * Bdt[tRow] * Gdt + Bt[tRow] * Gdtt) * Bs[sCol];\n"
"            }\n"
"        }\n"
"#endif\n"
"    }\n"
"    return 20;\n"
"}\n"
"\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisLinearTri(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 3)) {\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        wP[0] = 1.0f - s - t;\n"
"        wP[1] = s;\n"
"        wP[2] = t;\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        wDs[0] = -1.0f;\n"
"        wDs[1] =  1.0f;\n"
"        wDs[2] =  0.0f;\n"
"\n"
"        wDt[0] = -1.0f;\n"
"        wDt[1] =  0.0f;\n"
"        wDt[2] =  1.0f;\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            wDss[0] = wDss[1] = wDss[2] = 0.0f;\n"
"            wDst[0] = wDst[1] = wDst[2] = 0.0f;\n"
"            wDtt[0] = wDtt[1] = wDtt[2] = 0.0f;\n"
"        }\n"
"    }\n"
"    return 3;\n"
"}\n"
"\n"
"\n"
"// namespace {\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBivariateMonomialsQuartic(\n"
"        OSD_REAL s, OSD_REAL t,\n"
"        OSD_OUT_ARRAY(OSD_REAL, M, 15)) {\n"
"\n"
"        M[0] = 1.0;\n"
"\n"
"        M[1] = s;\n"
"        M[2] = t;\n"
"\n"
"        M[3] = s * s;\n"
"        M[4] = s * t;\n"
"        M[5] = t * t;\n"
"\n"
"        M[6] = M[3] * s;\n"
"        M[7] = M[4] * s;\n"
"        M[8] = M[4] * t;\n"
"        M[9] = M[5] * t;\n"
"\n"
"        M[10] = M[6] * s;\n"
"        M[11] = M[7] * s;\n"
"        M[12] = M[3] * M[5];\n"
"        M[13] = M[8] * t;\n"
"        M[14] = M[9] * t;\n"
"    }\n"
"\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBoxSplineTriDerivWeights(\n"
"        OSD_INOUT_ARRAY(OSD_REAL, /*stMonomials*/M, 15),\n"
"        int ds, int dt,\n"
"        OSD_OUT_ARRAY(OSD_REAL, w, 12)) {\n"
"\n"
"        // const OSD_REAL M[15] = stMonomials;\n"
"\n"
"        OSD_REAL S = 1.0f;\n"
"\n"
"        int totalOrder = ds + dt;\n"
"        if (totalOrder == 0) {\n"
"            S *= OSD_REAL_CAST(1.0f / 12.0f);\n"
"\n"
"            w[0]  = S * (1 - 2*M[1] - 4*M[2]          + 6*M[4] + 6*M[5] + 2*M[6]          - 6*M[8] - 4*M[9] -   M[10] - 2*M[11] + 2*M[13] +   M[14]);\n"
"            w[1]  = S * (1 + 2*M[1] - 2*M[2]          - 6*M[4]          - 4*M[6]          + 6*M[8] + 2*M[9] + 2*M[10] + 4*M[11] - 2*M[13] -   M[14]);\n"
"            w[2]  = S * (                                                 2*M[6]                            -   M[10] - 2*M[11]                    );\n"
"            w[3]  = S * (1 - 4*M[1] - 2*M[2] + 6*M[3] + 6*M[4]          - 4*M[6] - 6*M[7]          + 2*M[9] +   M[10] + 2*M[11] - 2*M[13] -   M[14]);\n"
"            w[4]  = S * (6                   -12*M[3] -12*M[4] -12*M[5] + 8*M[6] +12*M[7] +12*M[8] + 8*M[9] -   M[10] - 2*M[11] - 2*M[13] -   M[14]);\n"
"            w[5]  = S * (1 + 4*M[1] + 2*M[2] + 6*M[3] + 6*M[4]          - 4*M[6] - 6*M[7] -12*M[8] - 4*M[9] -   M[10] - 2*M[11] + 4*M[13] + 2*M[14]);\n"
"            w[6]  = S * (                                                                                       M[10] + 2*M[11]                    );\n"
"            w[7]  = S * (1 - 2*M[1] + 2*M[2]          - 6*M[4]          + 2*M[6] + 6*M[7]          - 4*M[9] -   M[10] - 2*M[11] + 4*M[13] + 2*M[14]);\n"
"            w[8]  = S * (1 + 2*M[1] + 4*M[2]          + 6*M[4] + 6*M[5] - 4*M[6] -12*M[7] - 6*M[8] - 4*M[9] + 2*M[10] + 4*M[11] - 2*M[13] -   M[14]);\n"
"            w[9]  = S * (                                                 2*M[6] + 6*M[7] + 6*M[8] + 2*M[9] -   M[10] - 2*M[11] - 2*M[13] -   M[14]);\n"
"            w[10] = S * (                                                                            2*M[9]                     - 2*M[13] -   M[14]);\n"
"            w[11] = S * (                                                                                                         2*M[13] +   M[14]);\n"
"        } else if (totalOrder == 1) {\n"
"            S *= OSD_REAL_CAST(1.0f / 6.0f);\n"
"\n"
"            if (ds != 0) {\n"
"                w[0]  = S * (-1          + 3*M[2] + 3*M[3]          - 3*M[5] - 2*M[6] - 3*M[7] +   M[9]);\n"
"                w[1]  = S * ( 1          - 3*M[2] - 6*M[3]          + 3*M[5] + 4*M[6] + 6*M[7] -   M[9]);\n"
"                w[2]  = S * (                       3*M[3]                   - 2*M[6] - 3*M[7]         );\n"
"                w[3]  = S * (-2 + 6*M[1] + 3*M[2] - 6*M[3] - 6*M[4]          + 2*M[6] + 3*M[7] -   M[9]);\n"
"                w[4]  = S * (   -12*M[1] - 6*M[2] +12*M[3] +12*M[4] + 6*M[5] - 2*M[6] - 3*M[7] -   M[9]);\n"
"                w[5]  = S * ( 2 + 6*M[1] + 3*M[2] - 6*M[3] - 6*M[4] - 6*M[5] - 2*M[6] - 3*M[7] + 2*M[9]);\n"
"                w[6]  = S * (                                                  2*M[6] + 3*M[7]         );\n"
"                w[7]  = S * (-1          - 3*M[2] + 3*M[3] + 6*M[4]          - 2*M[6] - 3*M[7] + 2*M[9]);\n"
"                w[8]  = S * ( 1          + 3*M[2] - 6*M[3] -12*M[4] - 3*M[5] + 4*M[6] + 6*M[7] -   M[9]);\n"
"                w[9]  = S * (                       3*M[3] + 6*M[4] + 3*M[5] - 2*M[6] - 3*M[7] -   M[9]);\n"
"                w[10] = S * (                                                                  -   M[9]);\n"
"                w[11] = S * (                                                                      M[9]);\n"
"            } else {\n"
"                w[0]  = S * (-2 + 3*M[1] + 6*M[2]          - 6*M[4] - 6*M[5]  -   M[6] + 3*M[8] + 2*M[9]);\n"
"                w[1]  = S * (-1 - 3*M[1]                   + 6*M[4] + 3*M[5]  + 2*M[6] - 3*M[8] - 2*M[9]);\n"
"                w[2]  = S * (                                                 -   M[6]                  );\n"
"                w[3]  = S * (-1 + 3*M[1]          - 3*M[3]          + 3*M[5]  +   M[6] - 3*M[8] - 2*M[9]);\n"
"                w[4]  = S * (   - 6*M[1] -12*M[2] + 6*M[3] +12*M[4] +12*M[5]  -   M[6] - 3*M[8] - 2*M[9]);\n"
"                w[5]  = S * ( 1 + 3*M[1]          - 3*M[3] -12*M[4] - 6*M[5]  -   M[6] + 6*M[8] + 4*M[9]);\n"
"                w[6]  = S * (                                                 +   M[6]                  );\n"
"                w[7]  = S * ( 1 - 3*M[1]          + 3*M[3]          - 6*M[5]  -   M[6] + 6*M[8] + 4*M[9]);\n"
"                w[8]  = S * ( 2 + 3*M[1] + 6*M[2] - 6*M[3] - 6*M[4] - 6*M[5]  + 2*M[6] - 3*M[8] - 2*M[9]);\n"
"                w[9]  = S * (                     + 3*M[3] + 6*M[4] + 3*M[5]  -   M[6] - 3*M[8] - 2*M[9]);\n"
"                w[10] = S * (                                         3*M[5]           - 3*M[8] - 2*M[9]);\n"
"                w[11] = S * (                                                            3*M[8] + 2*M[9]);\n"
"            }\n"
"        } else if (totalOrder == 2) {\n"
"            if (ds == 2) {\n"
"                w[0]  = S * (   +   M[1]          -   M[3] -   M[4]);\n"
"                w[1]  = S * (   - 2*M[1]          + 2*M[3] + 2*M[4]);\n"
"                w[2]  = S * (       M[1]          -   M[3] -   M[4]);\n"
"                w[3]  = S * ( 1 - 2*M[1] -   M[2] +   M[3] +   M[4]);\n"
"                w[4]  = S * (-2 + 4*M[1] + 2*M[2] -   M[3] -   M[4]);\n"
"                w[5]  = S * ( 1 - 2*M[1] -   M[2] -   M[3] -   M[4]);\n"
"                w[6]  = S * (                         M[3] +   M[4]);\n"
"                w[7]  = S * (   +   M[1] +   M[2] -   M[3] -   M[4]);\n"
"                w[8]  = S * (   - 2*M[1] - 2*M[2] + 2*M[3] + 2*M[4]);\n"
"                w[9]  = S * (       M[1] +   M[2] -   M[3] -   M[4]);\n"
"                w[10] =     0;\n"
"                w[11] =     0;\n"
"            } else if (dt == 2) {\n"
"                w[0]  = S * ( 1 -   M[1] - 2*M[2] +   M[4] +   M[5]);\n"
"                w[1]  = S * (   +   M[1] +   M[2] -   M[4] -   M[5]);\n"
"                w[2]  =     0;\n"
"                w[3]  = S * (            +   M[2] -   M[4] -   M[5]);\n"
"                w[4]  = S * (-2 + 2*M[1] + 4*M[2] -   M[4] -   M[5]);\n"
"                w[5]  = S * (   - 2*M[1] - 2*M[2] + 2*M[4] + 2*M[5]);\n"
"                w[6]  =     0;\n"
"                w[7]  = S * (            - 2*M[2] + 2*M[4] + 2*M[5]);\n"
"                w[8]  = S * ( 1 -   M[1] - 2*M[2] -   M[4] -   M[5]);\n"
"                w[9]  = S * (   +   M[1] +   M[2] -   M[4] -   M[5]);\n"
"                w[10] = S * (                M[2] -   M[4] -   M[5]);\n"
"                w[11] = S * (                         M[4] +   M[5]);\n"
"            } else {\n"
"                S *= OSD_REAL_CAST(1.0f / 2.0f);\n"
"\n"
"                w[0]  = S * ( 1          - 2*M[2] -   M[3] +   M[5]);\n"
"                w[1]  = S * (-1          + 2*M[2] + 2*M[3] -   M[5]);\n"
"                w[2]  = S * (                     -   M[3]         );\n"
"                w[3]  = S * ( 1 - 2*M[1]          +   M[3] -   M[5]);\n"
"                w[4]  = S * (-2 + 4*M[1] + 4*M[2] -   M[3] -   M[5]);\n"
"                w[5]  = S * ( 1 - 2*M[1] - 4*M[2] -   M[3] + 2*M[5]);\n"
"                w[6]  = S * (                     +   M[3]         );\n"
"                w[7]  = S * (-1 + 2*M[1]          -   M[3] + 2*M[5]);\n"
"                w[8]  = S * ( 1 - 4*M[1] - 2*M[2] + 2*M[3] -   M[5]);\n"
"                w[9]  = S * (   + 2*M[1] + 2*M[2] -   M[3] -   M[5]);\n"
"                w[10] = S * (                              -   M[5]);\n"
"                w[11] = S * (                                  M[5]);\n"
"            }\n"
"        } else {\n"
"            // assert(totalOrder <= 2);\n"
"        }\n"
"    }\n"
"\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_adjustBoxSplineTriBoundaryWeights(\n"
"        int boundaryMask,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, weights, 12)) {\n"
"\n"
"        if (boundaryMask == 0) return;\n"
"\n"
"        //\n"
"        //  Determine boundary edges and vertices from the lower 3 and upper\n"
"        //  2 bits of the 5-bit mask:\n"
"        //\n"
"        int upperBits = (boundaryMask >> 3) & 0x3;\n"
"        int lowerBits = boundaryMask & 7;\n"
"\n"
"        int eBits = lowerBits;\n"
"        int vBits = 0;\n"
"\n"
"        if (upperBits == 1) {\n"
"            //  Boundary vertices only:\n"
"            vBits = eBits;\n"
"            eBits = 0;\n"
"        } else if (upperBits == 2) {\n"
"            //  Opposite vertex bit is edge bit rotated one to the right:\n"
"            vBits = ((eBits & 1) << 2) | (eBits >> 1);\n"
"        }\n"
"\n"
"        bool edge0IsBoundary = (eBits & 1) != 0;\n"
"        bool edge1IsBoundary = (eBits & 2) != 0;\n"
"        bool edge2IsBoundary = (eBits & 4) != 0;\n"
"\n"
"        //\n"
"        //  Adjust weights for the 4 boundary points and 3 interior points\n"
"        //  to account for the 3 phantom points adjacent to each\n"
"        //  boundary edge:\n"
"        //\n"
"        if (edge0IsBoundary) {\n"
"            OSD_REAL w0 = weights[0];\n"
"            if (edge2IsBoundary) {\n"
"                //  P0 = B1 + (B1 - I1)\n"
"                weights[4] += w0;\n"
"                weights[4] += w0;\n"
"                weights[8] -= w0;\n"
"            } else {\n"
"                //  P0 = B1 + (B0 - I0)\n"
"                weights[4] += w0;\n"
"                weights[3] += w0;\n"
"                weights[7] -= w0;\n"
"            }\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[1];\n"
"            weights[4] += w1;\n"
"            weights[5] += w1;\n"
"            weights[8] -= w1;\n"
"\n"
"            OSD_REAL w2 = weights[2];\n"
"            if (edge1IsBoundary) {\n"
"                //  P2 = B2 + (B2 - I1)\n"
"                weights[5] += w2;\n"
"                weights[5] += w2;\n"
"                weights[8] -= w2;\n"
"            } else {\n"
"                //  P2 = B2 + (B3 - I2)\n"
"                weights[5] += w2;\n"
"                weights[6] += w2;\n"
"                weights[9] -= w2;\n"
"            }\n"
"            //  Clear weights for the phantom points:\n"
"            weights[0] = weights[1] = weights[2] = 0.0f;\n"
"        }\n"
"        if (edge1IsBoundary) {\n"
"            OSD_REAL w0 = weights[6];\n"
"            if (edge0IsBoundary) {\n"
"                //  P0 = B1 + (B1 - I1)\n"
"                weights[5] += w0;\n"
"                weights[5] += w0;\n"
"                weights[4] -= w0;\n"
"            } else {\n"
"                //  P0 = B1 + (B0 - I0)\n"
"                weights[5] += w0;\n"
"                weights[2] += w0;\n"
"                weights[1] -= w0;\n"
"            }\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[9];\n"
"            weights[5] += w1;\n"
"            weights[8] += w1;\n"
"            weights[4] -= w1;\n"
"\n"
"            OSD_REAL w2 = weights[11];\n"
"            if (edge2IsBoundary) {\n"
"                //  P2 = B2 + (B2 - I1)\n"
"                weights[8] += w2;\n"
"                weights[8] += w2;\n"
"                weights[4] -= w2;\n"
"            } else {\n"
"                //  P2 = B2 + (B3 - I2)\n"
"                weights[8]  += w2;\n"
"                weights[10] += w2;\n"
"                weights[7]  -= w2;\n"
"            }\n"
"            //  Clear weights for the phantom points:\n"
"            weights[6] = weights[9] = weights[11] = 0.0f;\n"
"        }\n"
"        if (edge2IsBoundary) {\n"
"            OSD_REAL w0 = weights[10];\n"
"            if (edge1IsBoundary) {\n"
"                //  P0 = B1 + (B1 - I1)\n"
"                weights[8] += w0;\n"
"                weights[8] += w0;\n"
"                weights[5] -= w0;\n"
"            } else {\n"
"                //  P0 = B1 + (B0 - I0)\n"
"                weights[8]  += w0;\n"
"                weights[11] += w0;\n"
"                weights[9]  -= w0;\n"
"            }\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[7];\n"
"            weights[8] += w1;\n"
"            weights[4] += w1;\n"
"            weights[5] -= w1;\n"
"\n"
"            OSD_REAL w2 = weights[3];\n"
"            if (edge0IsBoundary) {\n"
"                //  P2 = B2 + (B2 - I1)\n"
"                weights[4] += w2;\n"
"                weights[4] += w2;\n"
"                weights[5] -= w2;\n"
"            } else {\n"
"                //  P2 = B2 + (B3 - I2)\n"
"                weights[4] += w2;\n"
"                weights[0] += w2;\n"
"                weights[1] -= w2;\n"
"            }\n"
"            //  Clear weights for the phantom points:\n"
"            weights[10] = weights[7] = weights[3] = 0.0f;\n"
"        }\n"
"\n"
"        //\n"
"        //  Adjust weights for the 3 boundary points and the 2 interior\n"
"        //  points to account for the 2 phantom points adjacent to\n"
"        //  each boundary vertex:\n"
"        //\n"
"        if ((vBits & 1) != 0) {\n"
"            //  P0 = B1 + (B0 - I0)\n"
"            OSD_REAL w0 = weights[3];\n"
"            weights[4] += w0;\n"
"            weights[7] += w0;\n"
"            weights[8] -= w0;\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[0];\n"
"            weights[4] += w1;\n"
"            weights[1] += w1;\n"
"            weights[5] -= w1;\n"
"\n"
"            //  Clear weights for the phantom points:\n"
"            weights[3] = weights[0] = 0.0f;\n"
"        }\n"
"        if ((vBits & 2) != 0) {\n"
"            //  P0 = B1 + (B0 - I0)\n"
"            OSD_REAL w0 = weights[2];\n"
"            weights[5] += w0;\n"
"            weights[1] += w0;\n"
"            weights[4] -= w0;\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[6];\n"
"            weights[5] += w1;\n"
"            weights[9] += w1;\n"
"            weights[8] -= w1;\n"
"\n"
"            //  Clear weights for the phantom points:\n"
"            weights[2] = weights[6] = 0.0f;\n"
"        }\n"
"        if ((vBits & 4) != 0) {\n"
"            //  P0 = B1 + (B0 - I0)\n"
"            OSD_REAL w0 = weights[11];\n"
"            weights[8] += w0;\n"
"            weights[9] += w0;\n"
"            weights[5] -= w0;\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[10];\n"
"            weights[8] += w1;\n"
"            weights[7] += w1;\n"
"            weights[4] -= w1;\n"
"\n"
"            //  Clear weights for the phantom points:\n"
"            weights[11] = weights[10] = 0.0f;\n"
"        }\n"
"    }\n"
"\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_boundBasisBoxSplineTri(\n"
"            int boundary,\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wP, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDs, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDt, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDss, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDst, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDtt, 12)) {\n"
"\n"
"        if (OSD_OPTIONAL(wP)) {\n"
"            Osd_adjustBoxSplineTriBoundaryWeights(boundary, wP);\n"
"        }\n"
"        if (OSD_OPTIONAL(wDs && wDt)) {\n"
"            Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDs);\n"
"            Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDt);\n"
"\n"
"            if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"                Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDss);\n"
"                Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDst);\n"
"                Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDtt);\n"
"            }\n"
"        }\n"
"    }\n"
"// }  // namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisBoxSplineTri(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 12)) {\n"
"\n"
"    OSD_REAL stMonomials[15];\n"
"    Osd_evalBivariateMonomialsQuartic(s, t, stMonomials);\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        Osd_evalBoxSplineTriDerivWeights(stMonomials, 0, 0, wP);\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        Osd_evalBoxSplineTriDerivWeights(stMonomials, 1, 0, wDs);\n"
"        Osd_evalBoxSplineTriDerivWeights(stMonomials, 0, 1, wDt);\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            Osd_evalBoxSplineTriDerivWeights(stMonomials, 2, 0, wDss);\n"
"            Osd_evalBoxSplineTriDerivWeights(stMonomials, 1, 1, wDst);\n"
"            Osd_evalBoxSplineTriDerivWeights(stMonomials, 0, 2, wDtt);\n"
"        }\n"
"    }\n"
"    return 12;\n"
"}\n"
"\n"
"\n"
"// namespace {\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBezierTriDerivWeights(\n"
"        OSD_REAL s, OSD_REAL t, int ds, int dt,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wB, 15)) {\n"
"\n"
"        OSD_REAL u  = s;\n"
"        OSD_REAL v  = t;\n"
"        OSD_REAL w  = 1 - u - v;\n"
"\n"
"        OSD_REAL uu = u * u;\n"
"        OSD_REAL vv = v * v;\n"
"        OSD_REAL ww = w * w;\n"
"\n"
"        OSD_REAL uv = u * v;\n"
"        OSD_REAL vw = v * w;\n"
"        OSD_REAL uw = u * w;\n"
"\n"
"        int totalOrder = ds + dt;\n"
"        if (totalOrder == 0) {\n"
"            wB[0]  =      ww * ww;\n"
"            wB[1]  =  4 * uw * ww;\n"
"            wB[2]  =  6 * uw * uw;\n"
"            wB[3]  =  4 * uw * uu;\n"
"            wB[4]  =      uu * uu;\n"
"            wB[5]  =  4 * vw * ww;\n"
"            wB[6]  = 12 * ww * uv;\n"
"            wB[7]  = 12 * uu * vw;\n"
"            wB[8]  =  4 * uv * uu;\n"
"            wB[9]  =  6 * vw * vw;\n"
"            wB[10] = 12 * vv * uw;\n"
"            wB[11] =  6 * uv * uv;\n"
"            wB[12] =  4 * vw * vv;\n"
"            wB[13] =  4 * uv * vv;\n"
"            wB[14] =      vv * vv;\n"
"        } else if (totalOrder == 1) {\n"
"            if (ds == 1) {\n"
"                wB[0]  =  -4 * ww * w;\n"
"                wB[1]  =   4 * ww * (w - 3 * u);\n"
"                wB[2]  =  12 * uw * (w - u);\n"
"                wB[3]  =   4 * uu * (3 * w - u);\n"
"                wB[4]  =   4 * uu * u;\n"
"                wB[5]  = -12 * vw * w;\n"
"                wB[6]  =  12 * vw * (w - 2 * u);\n"
"                wB[7]  =  12 * uv * (2 * w - u);\n"
"                wB[8]  =  12 * uv * u;\n"
"                wB[9]  = -12 * vv * w;\n"
"                wB[10] =  12 * vv * (w - u);\n"
"                wB[11] =  12 * vv * u;\n"
"                wB[12] =  -4 * vv * v;\n"
"                wB[13] =   4 * vv * v;\n"
"                wB[14] =   0;\n"
"            } else {\n"
"                wB[0]  =  -4 * ww * w;\n"
"                wB[1]  = -12 * ww * u;\n"
"                wB[2]  = -12 * uu * w;\n"
"                wB[3]  =  -4 * uu * u;\n"
"                wB[4]  =   0;\n"
"                wB[5]  =   4 * ww * (w - 3 * v);\n"
"                wB[6]  =  12 * uw * (w - 2 * v);\n"
"                wB[7]  =  12 * uu * (w - v);\n"
"                wB[8]  =   4 * uu * u;\n"
"                wB[9]  =  12 * vw * (w - v);\n"
"                wB[10] =  12 * uv * (2 * w - v);\n"
"                wB[11] =  12 * uv * u;;\n"
"                wB[12] =   4 * vv * (3 * w - v);\n"
"                wB[13] =  12 * vv * u;\n"
"                wB[14] =   4 * vv * v;\n"
"            }\n"
"        } else if (totalOrder == 2) {\n"
"            if (ds == 2) {\n"
"                wB[0]  =  12 * ww;\n"
"                wB[1]  =  24 * (uw - ww);\n"
"                wB[2]  =  12 * (uu - 4 * uw + ww);\n"
"                wB[3]  =  24 * (uw - uu);\n"
"                wB[4]  =  12 * uu;\n"
"                wB[5]  =  24 * vw;\n"
"                wB[6]  =  24 * (uv - 2 * vw);\n"
"                wB[7]  =  24 * (vw - 2 * uv);\n"
"                wB[8]  =  24 * uv;\n"
"                wB[9]  =  12 * vv;\n"
"                wB[10] = -24 * vv;\n"
"                wB[11] =  12 * vv;\n"
"                wB[12] =   0;\n"
"                wB[13] =   0;\n"
"                wB[14] =   0;\n"
"            } else if (dt == 2) {\n"
"                wB[0]  =  12 * ww;\n"
"                wB[1]  =  24 * uw;\n"
"                wB[2]  =  12 * uu;\n"
"                wB[3]  =   0;\n"
"                wB[4]  =   0;\n"
"                wB[5]  =  24 * (vw - ww);\n"
"                wB[6]  =  24 * (uv - 2 * uw);\n"
"                wB[7]  = -24 * uu;\n"
"                wB[8]  =   0;\n"
"                wB[9]  =  12 * (vv - 4 * vw + ww);\n"
"                wB[10] =  24 * (uw - 2 * uv);\n"
"                wB[11] =  12 * uu;\n"
"                wB[12] =  24 * (vw - vv);\n"
"                wB[13] =  24 * uv;\n"
"                wB[14] =  12 * vv;\n"
"            } else {\n"
"                wB[0]  =  12 * ww;\n"
"                wB[3]  = -12 * uu;\n"
"                wB[13] =  12 * vv;\n"
"                wB[11] =  24 * uv;\n"
"                wB[1]  =  24 * uw - wB[0];\n"
"                wB[2]  = -24 * uw - wB[3];\n"
"                wB[5]  =  24 * vw - wB[0];\n"
"                wB[6]  = -24 * vw + wB[11] - wB[1];\n"
"                wB[8]  = - wB[3];\n"
"                wB[7]  = -(wB[11] + wB[2]);\n"
"                wB[9]  =   wB[13] - wB[5] - wB[0];\n"
"                wB[10] = -(wB[9] + wB[11]);\n"
"                wB[12] = - wB[13];\n"
"                wB[4]  =   0;\n"
"                wB[14] =   0;\n"
"            }\n"
"        } else {\n"
"            // assert(totalOrder <= 2);\n"
"        }\n"
"    }\n"
"// } // end namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisBezierTri(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 15)) {\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        Osd_evalBezierTriDerivWeights(s, t, 0, 0, wP);\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        Osd_evalBezierTriDerivWeights(s, t, 1, 0, wDs);\n"
"        Osd_evalBezierTriDerivWeights(s, t, 0, 1, wDt);\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            Osd_evalBezierTriDerivWeights(s, t, 2, 0, wDss);\n"
"            Osd_evalBezierTriDerivWeights(s, t, 1, 1, wDst);\n"
"            Osd_evalBezierTriDerivWeights(s, t, 0, 2, wDtt);\n"
"        }\n"
"    }\n"
"    return 15;\n"
"}\n"
"\n"
"\n"
"// namespace {\n"
"    //\n"
"    //  Expanding a set of 15 Bezier basis functions for the 6 (3 pairs) of\n"
"    //  rational weights for the 18 Gregory basis functions:\n"
"    //\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_convertBezierWeightsToGregory(\n"
"        OSD_INOUT_ARRAY(OSD_REAL, wB, 15),\n"
"        OSD_INOUT_ARRAY(OSD_REAL, rG,  6),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wG, 18)) {\n"
"\n"
"        wG[0]  = wB[0];\n"
"        wG[1]  = wB[1];\n"
"        wG[2]  = wB[5];\n"
"        wG[3]  = wB[6] * rG[0];\n"
"        wG[4]  = wB[6] * rG[1];\n"
"\n"
"        wG[5]  = wB[4];\n"
"        wG[6]  = wB[8];\n"
"        wG[7]  = wB[3];\n"
"        wG[8]  = wB[7] * rG[2];\n"
"        wG[9]  = wB[7] * rG[3];\n"
"\n"
"        wG[10] = wB[14];\n"
"        wG[11] = wB[12];\n"
"        wG[12] = wB[13];\n"
"        wG[13] = wB[10] * rG[4];\n"
"        wG[14] = wB[10] * rG[5];\n"
"\n"
"        wG[15] = wB[2];\n"
"        wG[16] = wB[11];\n"
"        wG[17] = wB[9];\n"
"    }\n"
"// } // end namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisGregoryTri(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 18)) {\n"
"\n"
"    //\n"
"    //  Bezier basis functions are denoted with B while the rational multipliers for the\n"
"    //  interior points will be denoted G -- so we have B(s,t) and G(s,t) (though we\n"
"    //  switch to barycentric (u,v,w) briefly to compute G)\n"
"    //\n"
"    OSD_REAL BP[15], BDs[15], BDt[15], BDss[15], BDst[15], BDtt[15];\n"
"\n"
"    OSD_REAL G[6] = OSD_ARRAY_6(OSD_REAL, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f );\n"
"    OSD_REAL u = s;\n"
"    OSD_REAL v = t;\n"
"    OSD_REAL w = 1 - u - v;\n"
"\n"
"    if ((u + v) > 0) {\n"
"        G[0]  = u / (u + v);\n"
"        G[1]  = v / (u + v);\n"
"    }\n"
"    if ((v + w) > 0) {\n"
"        G[2] = v / (v + w);\n"
"        G[3] = w / (v + w);\n"
"    }\n"
"    if ((w + u) > 0) {\n"
"        G[4] = w / (w + u);\n"
"        G[5] = u / (w + u);\n"
"    }\n"
"\n"
"    //\n"
"    //  Compute Bezier basis functions and convert, adjusting interior points:\n"
"    //\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        Osd_evalBezierTriDerivWeights(s, t, 0, 0, BP);\n"
"        Osd_convertBezierWeightsToGregory(BP, G, wP);\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        //  TBD -- ifdef OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES\n"
"\n"
"        Osd_evalBezierTriDerivWeights(s, t, 1, 0, BDs);\n"
"        Osd_evalBezierTriDerivWeights(s, t, 0, 1, BDt);\n"
"\n"
"        Osd_convertBezierWeightsToGregory(BDs, G, wDs);\n"
"        Osd_convertBezierWeightsToGregory(BDt, G, wDt);\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            Osd_evalBezierTriDerivWeights(s, t, 2, 0, BDss);\n"
"            Osd_evalBezierTriDerivWeights(s, t, 1, 1, BDst);\n"
"            Osd_evalBezierTriDerivWeights(s, t, 0, 2, BDtt);\n"
"\n"
"            Osd_convertBezierWeightsToGregory(BDss, G, wDss);\n"
"            Osd_convertBezierWeightsToGregory(BDst, G, wDst);\n"
"            Osd_convertBezierWeightsToGregory(BDtt, G, wDtt);\n"
"        }\n"
"    }\n"
"    return 18;\n"
"}\n"
"\n"
"// The following functions are low-level internal methods which\n"
"// were exposed in earlier releases, but were never intended to\n"
"// be part of the supported public API.\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBezierWeights(\n"
"    OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDP, 4),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDP2, 4)) {\n"
"\n"
"    Osd_evalBezierCurve(t, wP, wDP, wDP2);\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBSplineWeights(\n"
"    OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDP, 4),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDP2, 4)) {\n"
"\n"
"    Osd_evalBSplineCurve(t, wP, wDP, wDP2);\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBoxSplineWeights(\n"
"    float s, float t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 12)) {\n"
"\n"
"    OSD_REAL stMonomials[15];\n"
"    Osd_evalBivariateMonomialsQuartic(s, t, stMonomials);\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        Osd_evalBoxSplineTriDerivWeights(stMonomials, 0, 0, wP);\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdAdjustBoundaryWeights(\n"
"        int boundary,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, sWeights, 4),\n"
"        OSD_INOUT_ARRAY(OSD_REAL, tWeights, 4)) {\n"
"\n"
"    if ((boundary & 1) != 0) {\n"
"        tWeights[2] -= tWeights[0];\n"
"        tWeights[1] += tWeights[0] * 2.0f;\n"
"        tWeights[0]  = 0.0f;\n"
"    }\n"
"    if ((boundary & 2) != 0) {\n"
"        sWeights[1] -= sWeights[3];\n"
"        sWeights[2] += sWeights[3] * 2.0f;\n"
"        sWeights[3]  = 0.0f;\n"
"    }\n"
"    if ((boundary & 4) != 0) {\n"
"        tWeights[1] -= tWeights[3];\n"
"        tWeights[2] += tWeights[3] * 2.0f;\n"
"        tWeights[3]  = 0.0f;\n"
"    }\n"
"    if ((boundary & 8) != 0) {\n"
"        sWeights[2] -= sWeights[0];\n"
"        sWeights[1] += sWeights[0] * 2.0f;\n"
"        sWeights[0]  = 0.0f;\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdComputeTensorProductPatchWeights(\n"
"    float dScale, int boundary,\n"
"    OSD_IN_ARRAY(float, sWeights, 4),\n"
"    OSD_IN_ARRAY(float, tWeights, 4),\n"
"    OSD_IN_ARRAY(float, dsWeights, 4),\n"
"    OSD_IN_ARRAY(float, dtWeights, 4),\n"
"    OSD_IN_ARRAY(float, dssWeights, 4),\n"
"    OSD_IN_ARRAY(float, dttWeights, 4),\n"
"    OSD_OUT_ARRAY(float, wP, 16),\n"
"    OSD_OUT_ARRAY(float, wDs, 16),\n"
"    OSD_OUT_ARRAY(float, wDt, 16),\n"
"    OSD_OUT_ARRAY(float, wDss, 16),\n"
"    OSD_OUT_ARRAY(float, wDst, 16),\n"
"    OSD_OUT_ARRAY(float, wDtt, 16)) {\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        // Compute the tensor product weight of the (s,t) basis function\n"
"        // corresponding to each control vertex:\n"
"\n"
"        OsdAdjustBoundaryWeights(boundary, sWeights, tWeights);\n"
"\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wP[4*i+j] = sWeights[j] * tWeights[i];\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        // Compute the tensor product weight of the differentiated (s,t) basis\n"
"        // function corresponding to each control vertex (scaled accordingly):\n"
"\n"
"        OsdAdjustBoundaryWeights(boundary, dsWeights, dtWeights);\n"
"\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wDs[4*i+j] = dsWeights[j] * tWeights[i] * dScale;\n"
"                wDt[4*i+j] = sWeights[j] * dtWeights[i] * dScale;\n"
"            }\n"
"        }\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            // Compute the tensor product weight of appropriate differentiated\n"
"            // (s,t) basis functions for each control vertex (scaled accordingly):\n"
"            float d2Scale = dScale * dScale;\n"
"\n"
"            OsdAdjustBoundaryWeights(boundary, dssWeights, dttWeights);\n"
"\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                for (int j = 0; j < 4; ++j) {\n"
"                    wDss[4*i+j] = dssWeights[j] * tWeights[i] * d2Scale;\n"
"                    wDst[4*i+j] = dsWeights[j] * dtWeights[i] * d2Scale;\n"
"                    wDtt[4*i+j] = sWeights[j] * dttWeights[i] * d2Scale;\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBilinearPatchWeights(\n"
"        OSD_REAL s, OSD_REAL t, OSD_REAL d1Scale,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDs, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDt, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDss, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDst, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDtt, 4)) {\n"
"\n"
"    int nPoints = Osd_EvalBasisLinear(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBSplinePatchWeights(\n"
"    OSD_REAL s, OSD_REAL t, OSD_REAL d1Scale, int boundary,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"\n"
"    int nPoints = Osd_EvalBasisBSpline(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    Osd_boundBasisBSpline(boundary, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBezierPatchWeights(\n"
"    OSD_REAL s, OSD_REAL t, OSD_REAL d1Scale,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"    int nPoints = Osd_EvalBasisBezier(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetGregoryPatchWeights(\n"
"    OSD_REAL s, OSD_REAL t, OSD_REAL d1Scale,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 20)) {\n"
"    int nPoints = Osd_EvalBasisGregory(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//\n"
"//  Higher level basis evaluation functions that deal with parameterization and\n"
"//  boundary issues (reflected in PatchParam) for all patch types:\n"
"//\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"OsdEvaluatePatchBasisNormalized(\n"
"    int patchType, OsdPatchParam param,\n"
"    OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 20)) {\n"
"\n"
"    int boundaryMask = OsdPatchParamGetBoundary(param);\n"
"\n"
"    int nPoints = 0;\n"
"    if (patchType == OSD_PATCH_DESCRIPTOR_REGULAR) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisBSpline(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"        if (boundaryMask != 0) {\n"
"            Osd_boundBasisBSpline(\n"
"                boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"        }\n"
"#else\n"
"        OSD_REAL wP16[16], wDs16[16], wDt16[16],\n"
"                 wDss16[16], wDst16[16], wDtt16[16];\n"
"        nPoints = Osd_EvalBasisBSpline(\n"
"                s, t, wP16, wDs16, wDt16, wDss16, wDst16, wDtt16);\n"
"        if (boundaryMask != 0) {\n"
"            Osd_boundBasisBSpline(\n"
"                boundaryMask, wP16, wDs16, wDt16, wDss16, wDst16, wDtt16);\n"
"        }\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP16[i];\n"
"            wDs[i] = wDs16[i]; wDt[i] = wDt16[i];\n"
"            wDss[i] = wDss16[i]; wDst[i] = wDst16[i]; wDtt[i] = wDtt16[i];\n"
"        }\n"
"#endif\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_LOOP) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisBoxSplineTri(\n"
"                s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"        if (boundaryMask != 0) {\n"
"            Osd_boundBasisBoxSplineTri(\n"
"                boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"        }\n"
"#else\n"
"        OSD_REAL wP12[12], wDs12[12], wDt12[12],\n"
"                 wDss12[12], wDst12[12], wDtt12[12];\n"
"        nPoints = Osd_EvalBasisBoxSplineTri(\n"
"                s, t, wP12, wDs12, wDt12, wDss12, wDst12, wDtt12);\n"
"        if (boundaryMask != 0) {\n"
"            Osd_boundBasisBoxSplineTri(\n"
"                boundaryMask, wP12, wDs12, wDt12, wDss12, wDst12, wDtt12);\n"
"        }\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP12[i];\n"
"            wDs[i] = wDs12[i]; wDt[i] = wDt12[i];\n"
"            wDss[i] = wDss12[i]; wDst[i] = wDst12[i]; wDtt[i] = wDtt12[i];\n"
"        }\n"
"#endif\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_GREGORY_BASIS) {\n"
"        nPoints = Osd_EvalBasisGregory(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_GREGORY_TRIANGLE) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisGregoryTri(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"#else\n"
"        OSD_REAL wP18[18], wDs18[18], wDt18[18],\n"
"                 wDss18[18], wDst18[18], wDtt18[18];\n"
"        nPoints = Osd_EvalBasisGregoryTri(\n"
"                s, t, wP18, wDs18, wDt18, wDss18, wDst18, wDtt18);\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP18[i];\n"
"            wDs[i] = wDs18[i]; wDt[i] = wDt18[i];\n"
"            wDss[i] = wDss18[i]; wDst[i] = wDst18[i]; wDtt[i] = wDtt18[i];\n"
"        }\n"
"#endif\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_QUADS) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisLinear(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"#else\n"
"        OSD_REAL wP4[4], wDs4[4], wDt4[4],\n"
"                 wDss4[4], wDst4[4], wDtt4[4];\n"
"        nPoints = Osd_EvalBasisLinear(\n"
"                s, t, wP4, wDs4, wDt4, wDss4, wDst4, wDtt4);\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP4[i];\n"
"            wDs[i] = wDs4[i]; wDt[i] = wDt4[i];\n"
"            wDss[i] = wDss4[i]; wDst[i] = wDst4[i]; wDtt[i] = wDtt4[i];\n"
"        }\n"
"#endif\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_TRIANGLES) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisLinearTri(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"#else\n"
"        OSD_REAL wP3[3], wDs3[3], wDt3[3],\n"
"                 wDss3[3], wDst3[3], wDtt3[3];\n"
"        nPoints = Osd_EvalBasisLinearTri(\n"
"                s, t, wP3, wDs3, wDt3, wDss3, wDst3, wDtt3);\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP3[i];\n"
"            wDs[i] = wDs3[i]; wDt[i] = wDt3[i];\n"
"            wDss[i] = wDss3[i]; wDst[i] = wDst3[i]; wDtt[i] = wDtt3[i];\n"
"        }\n"
"#endif\n"
"    } else {\n"
"        // assert(0);\n"
"    }\n"
"    return nPoints;\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"OsdEvaluatePatchBasis(\n"
"    int patchType, OsdPatchParam param,\n"
"    OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 20)) {\n"
"\n"
"    OSD_REAL derivSign = 1.0f;\n"
"\n"
"    if ((patchType == OSD_PATCH_DESCRIPTOR_LOOP) ||\n"
"        (patchType == OSD_PATCH_DESCRIPTOR_GREGORY_TRIANGLE) ||\n"
"        (patchType == OSD_PATCH_DESCRIPTOR_TRIANGLES)) {\n"
"        OSD_REAL uv[2] = OSD_ARRAY_2(OSD_REAL, s, t);\n"
"        OsdPatchParamNormalizeTriangle(param, uv);\n"
"        s = uv[0];\n"
"        t = uv[1];\n"
"        if (OsdPatchParamIsTriangleRotated(param)) {\n"
"            derivSign = -1.0f;\n"
"        }\n"
"    } else {\n"
"        OSD_REAL uv[2] = OSD_ARRAY_2(OSD_REAL, s, t);\n"
"        OsdPatchParamNormalize(param, uv);\n"
"        s = uv[0];\n"
"        t = uv[1];\n"
"    }\n"
"\n"
"    int nPoints = OsdEvaluatePatchBasisNormalized(\n"
"        patchType, param, s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        OSD_REAL d1Scale =\n"
"                derivSign * OSD_REAL_CAST(1 << OsdPatchParamGetDepth(param));\n"
"\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = derivSign * d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"    return nPoints;\n"
"}\n"
"\n"
"#if !defined(OSD_PATCH_BASIS_GLSL) && "
"    !defined(OSD_PATCH_BASIS_HLSL) && "
"    !defined(OSD_PATCH_BASIS_CUDA) && "
"    !defined(OSD_PATCH_BASIS_OPENCL) && "
"    !defined(OSD_PATCH_BASIS_METAL)\n"
"\n"
"}  // end namespace Osd\n"
"\n"
"}  // end namespace OPENSUBDIV_VERSION\n"
"using namespace OPENSUBDIV_VERSION;\n"
"\n"
"}  // end namespace OpenSubdiv\n"
"\n"
"#endif\n"
"\n"
"#endif /* OPENSUBDIV3_OSD_PATCH_BASIS_H */\n"
"\n"

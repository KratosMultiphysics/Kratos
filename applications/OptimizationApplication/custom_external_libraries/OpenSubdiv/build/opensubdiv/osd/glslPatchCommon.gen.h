"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"// The following callback functions are used when evaluating tessellation\n"
"// rates and when using legacy patch drawing.\n"
"mat4 OsdModelViewMatrix();\n"
"mat4 OsdProjectionMatrix();\n"
"float OsdTessLevel();\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Patch Parameters\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"//\n"
"// Each patch has a corresponding patchParam. This is a set of three values\n"
"// specifying additional information about the patch:\n"
"//\n"
"//    faceId    -- topological face identifier (e.g. Ptex FaceId)\n"
"//    bitfield  -- refinement-level, non-quad, boundary, transition, uv-offset\n"
"//    sharpness -- crease sharpness for single-crease patches\n"
"//\n"
"\n"
"int OsdGetPatchFaceId(ivec3 patchParam)\n"
"{\n"
"    return (patchParam.x & 0xfffffff);\n"
"}\n"
"\n"
"int OsdGetPatchFaceLevel(ivec3 patchParam)\n"
"{\n"
"    return (1 << ((patchParam.y & 0xf) - ((patchParam.y >> 4) & 1)));\n"
"}\n"
"\n"
"int OsdGetPatchRefinementLevel(ivec3 patchParam)\n"
"{\n"
"    return (patchParam.y & 0xf);\n"
"}\n"
"\n"
"int OsdGetPatchBoundaryMask(ivec3 patchParam)\n"
"{\n"
"    return ((patchParam.y >> 7) & 0x1f);\n"
"}\n"
"\n"
"int OsdGetPatchTransitionMask(ivec3 patchParam)\n"
"{\n"
"    return ((patchParam.x >> 28) & 0xf);\n"
"}\n"
"\n"
"ivec2 OsdGetPatchFaceUV(ivec3 patchParam)\n"
"{\n"
"    int u = (patchParam.y >> 22) & 0x3ff;\n"
"    int v = (patchParam.y >> 12) & 0x3ff;\n"
"    return ivec2(u,v);\n"
"}\n"
"\n"
"bool OsdGetPatchIsRegular(ivec3 patchParam)\n"
"{\n"
"    return ((patchParam.y >> 5) & 0x1) != 0;\n"
"}\n"
"\n"
"bool OsdGetPatchIsTriangleRotated(ivec3 patchParam)\n"
"{\n"
"    ivec2 uv = OsdGetPatchFaceUV(patchParam);\n"
"    return (uv.x + uv.y) >= OsdGetPatchFaceLevel(patchParam);\n"
"}\n"
"\n"
"float OsdGetPatchSharpness(ivec3 patchParam)\n"
"{\n"
"    return intBitsToFloat(patchParam.z);\n"
"}\n"
"\n"
"float OsdGetPatchSingleCreaseSegmentParameter(ivec3 patchParam, vec2 uv)\n"
"{\n"
"    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"    float s = 0;\n"
"    if ((boundaryMask & 1) != 0) {\n"
"        s = 1 - uv.y;\n"
"    } else if ((boundaryMask & 2) != 0) {\n"
"        s = uv.x;\n"
"    } else if ((boundaryMask & 4) != 0) {\n"
"        s = uv.y;\n"
"    } else if ((boundaryMask & 8) != 0) {\n"
"        s = 1 - uv.x;\n"
"    }\n"
"    return s;\n"
"}\n"
"\n"
"ivec4 OsdGetPatchCoord(ivec3 patchParam)\n"
"{\n"
"    int faceId = OsdGetPatchFaceId(patchParam);\n"
"    int faceLevel = OsdGetPatchFaceLevel(patchParam);\n"
"    ivec2 faceUV = OsdGetPatchFaceUV(patchParam);\n"
"    return ivec4(faceUV.x, faceUV.y, faceLevel, faceId);\n"
"}\n"
"\n"
"vec4 OsdInterpolatePatchCoord(vec2 localUV, ivec3 patchParam)\n"
"{\n"
"    ivec4 perPrimPatchCoord = OsdGetPatchCoord(patchParam);\n"
"    int faceId = perPrimPatchCoord.w;\n"
"    int faceLevel = perPrimPatchCoord.z;\n"
"    vec2 faceUV = vec2(perPrimPatchCoord.x, perPrimPatchCoord.y);\n"
"    vec2 uv = localUV/faceLevel + faceUV/faceLevel;\n"
"    // add 0.5 to integer values for more robust interpolation\n"
"    return vec4(uv.x, uv.y, faceLevel+0.5f, faceId+0.5f);\n"
"}\n"
"\n"
"vec4 OsdInterpolatePatchCoordTriangle(vec2 localUV, ivec3 patchParam)\n"
"{\n"
"    vec4 result = OsdInterpolatePatchCoord(localUV, patchParam);\n"
"    if (OsdGetPatchIsTriangleRotated(patchParam)) {\n"
"        result.xy = vec2(1.0f) - result.xy;\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"void\n"
"OsdUnivar4x4(in float u, out float B[4], out float D[4])\n"
"{\n"
"    float t = u;\n"
"    float s = 1.0f - u;\n"
"\n"
"    float A0 = s * s;\n"
"    float A1 = 2 * s * t;\n"
"    float A2 = t * t;\n"
"\n"
"    B[0] = s * A0;\n"
"    B[1] = t * A0 + s * A1;\n"
"    B[2] = t * A1 + s * A2;\n"
"    B[3] = t * A2;\n"
"\n"
"    D[0] =    - A0;\n"
"    D[1] = A0 - A1;\n"
"    D[2] = A1 - A2;\n"
"    D[3] = A2;\n"
"}\n"
"\n"
"void\n"
"OsdUnivar4x4(in float u, out float B[4], out float D[4], out float C[4])\n"
"{\n"
"    float t = u;\n"
"    float s = 1.0f - u;\n"
"\n"
"    float A0 = s * s;\n"
"    float A1 = 2 * s * t;\n"
"    float A2 = t * t;\n"
"\n"
"    B[0] = s * A0;\n"
"    B[1] = t * A0 + s * A1;\n"
"    B[2] = t * A1 + s * A2;\n"
"    B[3] = t * A2;\n"
"\n"
"    D[0] =    - A0;\n"
"    D[1] = A0 - A1;\n"
"    D[2] = A1 - A2;\n"
"    D[3] = A2;\n"
"\n"
"    A0 =   - s;\n"
"    A1 = s - t;\n"
"    A2 = t;\n"
"\n"
"    C[0] =    - A0;\n"
"    C[1] = A0 - A1;\n"
"    C[2] = A1 - A2;\n"
"    C[3] = A2;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"struct OsdPerPatchVertexBezier {\n"
"    ivec3 patchParam;\n"
"    vec3 P;\n"
"#if defined OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    vec3 P1;\n"
"    vec3 P2;\n"
"    vec2 vSegments;\n"
"#endif\n"
"};\n"
"\n"
"vec3\n"
"OsdEvalBezier(vec3 cp[16], vec2 uv)\n"
"{\n"
"    vec3 BUCP[4] = vec3[4](vec3(0), vec3(0), vec3(0), vec3(0));\n"
"\n"
"    float B[4], D[4];\n"
"\n"
"    OsdUnivar4x4(uv.x, B, D);\n"
"    for (int i=0; i<4; ++i) {\n"
"        for (int j=0; j<4; ++j) {\n"
"            vec3 A = cp[4*i + j];\n"
"            BUCP[i] += A * B[j];\n"
"        }\n"
"    }\n"
"\n"
"    vec3 P = vec3(0);\n"
"\n"
"    OsdUnivar4x4(uv.y, B, D);\n"
"    for (int k=0; k<4; ++k) {\n"
"        P += B[k] * BUCP[k];\n"
"    }\n"
"\n"
"    return P;\n"
"}\n"
"\n"
"// When OSD_PATCH_ENABLE_SINGLE_CREASE is defined,\n"
"// this function evaluates single-crease patch, which is segmented into\n"
"// 3 parts in the v-direction.\n"
"//\n"
"//  v=0             vSegment.x        vSegment.y              v=1\n"
"//   +------------------+-------------------+------------------+\n"
"//   |       cp 0       |     cp 1          |      cp 2        |\n"
"//   | (infinite sharp) | (floor sharpness) | (ceil sharpness) |\n"
"//   +------------------+-------------------+------------------+\n"
"//\n"
"vec3\n"
"OsdEvalBezier(OsdPerPatchVertexBezier cp[16], ivec3 patchParam, vec2 uv)\n"
"{\n"
"    vec3 BUCP[4] = vec3[4](vec3(0), vec3(0), vec3(0), vec3(0));\n"
"\n"
"    float B[4], D[4];\n"
"    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, uv);\n"
"\n"
"    OsdUnivar4x4(uv.x, B, D);\n"
"#if defined OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    vec2 vSegments = cp[0].vSegments;\n"
"    if (s <= vSegments.x) {\n"
"        for (int i=0; i<4; ++i) {\n"
"            for (int j=0; j<4; ++j) {\n"
"                vec3 A = cp[4*i + j].P;\n"
"                BUCP[i] += A * B[j];\n"
"            }\n"
"        }\n"
"    } else if (s <= vSegments.y) {\n"
"        for (int i=0; i<4; ++i) {\n"
"            for (int j=0; j<4; ++j) {\n"
"                vec3 A = cp[4*i + j].P1;\n"
"                BUCP[i] += A * B[j];\n"
"            }\n"
"        }\n"
"    } else {\n"
"        for (int i=0; i<4; ++i) {\n"
"            for (int j=0; j<4; ++j) {\n"
"                vec3 A = cp[4*i + j].P2;\n"
"                BUCP[i] += A * B[j];\n"
"            }\n"
"        }\n"
"    }\n"
"#else\n"
"    for (int i=0; i<4; ++i) {\n"
"        for (int j=0; j<4; ++j) {\n"
"            vec3 A = cp[4*i + j].P;\n"
"            BUCP[i] += A * B[j];\n"
"        }\n"
"    }\n"
"#endif\n"
"\n"
"    vec3 P = vec3(0);\n"
"\n"
"    OsdUnivar4x4(uv.y, B, D);\n"
"    for (int k=0; k<4; ++k) {\n"
"        P += B[k] * BUCP[k];\n"
"    }\n"
"\n"
"    return P;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Boundary Interpolation\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"void\n"
"OsdComputeBSplineBoundaryPoints(inout vec3 cpt[16], ivec3 patchParam)\n"
"{\n"
"    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"\n"
"    //  Don't extrapolate corner points until all boundary points in place\n"
"    if ((boundaryMask & 1) != 0) {\n"
"        cpt[1] = 2*cpt[5] - cpt[9];\n"
"        cpt[2] = 2*cpt[6] - cpt[10];\n"
"    }\n"
"    if ((boundaryMask & 2) != 0) {\n"
"        cpt[7] = 2*cpt[6] - cpt[5];\n"
"        cpt[11] = 2*cpt[10] - cpt[9];\n"
"    }\n"
"    if ((boundaryMask & 4) != 0) {\n"
"        cpt[13] = 2*cpt[9] - cpt[5];\n"
"        cpt[14] = 2*cpt[10] - cpt[6];\n"
"    }\n"
"    if ((boundaryMask & 8) != 0) {\n"
"        cpt[4] = 2*cpt[5] - cpt[6];\n"
"        cpt[8] = 2*cpt[9] - cpt[10];\n"
"    }\n"
"\n"
"    //  Now safe to extrapolate corner points:\n"
"    if ((boundaryMask & 1) != 0) {\n"
"        cpt[0] = 2*cpt[4] - cpt[8];\n"
"        cpt[3] = 2*cpt[7] - cpt[11];\n"
"    }\n"
"    if ((boundaryMask & 2) != 0) {\n"
"        cpt[3] = 2*cpt[2] - cpt[1];\n"
"        cpt[15] = 2*cpt[14] - cpt[13];\n"
"    }\n"
"    if ((boundaryMask & 4) != 0) {\n"
"        cpt[12] = 2*cpt[8] - cpt[4];\n"
"        cpt[15] = 2*cpt[11] - cpt[7];\n"
"    }\n"
"    if ((boundaryMask & 8) != 0) {\n"
"        cpt[0] = 2*cpt[1] - cpt[2];\n"
"        cpt[12] = 2*cpt[13] - cpt[14];\n"
"    }\n"
"}\n"
"\n"
"void\n"
"OsdComputeBoxSplineTriangleBoundaryPoints(inout vec3 cpt[12], ivec3 patchParam)\n"
"{\n"
"    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"    if (boundaryMask == 0) return;\n"
"\n"
"    int upperBits = (boundaryMask >> 3) & 0x3;\n"
"    int lowerBits = boundaryMask & 7;\n"
"\n"
"    int eBits = lowerBits;\n"
"    int vBits = 0;\n"
"\n"
"    if (upperBits == 1) {\n"
"        vBits = eBits;\n"
"        eBits = 0;\n"
"    } else if (upperBits == 2) {\n"
"        //  Opposite vertex bit is edge bit rotated one to the right:\n"
"        vBits = ((eBits & 1) << 2) | (eBits >> 1);\n"
"    }\n"
"\n"
"    bool edge0IsBoundary = (eBits & 1) != 0;\n"
"    bool edge1IsBoundary = (eBits & 2) != 0;\n"
"    bool edge2IsBoundary = (eBits & 4) != 0;\n"
"\n"
"    if (edge0IsBoundary) {\n"
"        if (edge2IsBoundary) {\n"
"            cpt[0] = cpt[4] + (cpt[4] - cpt[8]);\n"
"        } else {\n"
"            cpt[0] = cpt[4] + (cpt[3] - cpt[7]);\n"
"        }\n"
"        cpt[1] = cpt[4] + cpt[5] - cpt[8];\n"
"        if (edge1IsBoundary) {\n"
"            cpt[2] = cpt[5] + (cpt[5] - cpt[8]);\n"
"        } else {\n"
"            cpt[2] = cpt[5] + (cpt[6] - cpt[9]);\n"
"        }\n"
"    }\n"
"    if (edge1IsBoundary) {\n"
"        if (edge0IsBoundary) {\n"
"            cpt[6] = cpt[5] + (cpt[5] - cpt[4]);\n"
"        } else {\n"
"            cpt[6] = cpt[5] + (cpt[2] - cpt[1]);\n"
"        }\n"
"        cpt[9] = cpt[5] + cpt[8] - cpt[4];\n"
"        if (edge2IsBoundary) {\n"
"            cpt[11] = cpt[8] + (cpt[8] - cpt[4]);\n"
"        } else {\n"
"            cpt[11] = cpt[8] + (cpt[10] - cpt[7]);\n"
"        }\n"
"    }\n"
"    if (edge2IsBoundary) {\n"
"        if (edge1IsBoundary) {\n"
"            cpt[10] = cpt[8] + (cpt[8] - cpt[5]);\n"
"        } else {\n"
"            cpt[10] = cpt[8] + (cpt[11] - cpt[9]);\n"
"        }\n"
"        cpt[7] = cpt[8] + cpt[4] - cpt[5];\n"
"        if (edge0IsBoundary) {\n"
"            cpt[3] = cpt[4] + (cpt[4] - cpt[5]);\n"
"        } else {\n"
"            cpt[3] = cpt[4] + (cpt[0] - cpt[1]);\n"
"        }\n"
"    }\n"
"\n"
"    if ((vBits & 1) != 0) {\n"
"        cpt[3] = cpt[4] + cpt[7] - cpt[8];\n"
"        cpt[0] = cpt[4] + cpt[1] - cpt[5];\n"
"    }\n"
"    if ((vBits & 2) != 0) {\n"
"        cpt[2] = cpt[5] + cpt[1] - cpt[4];\n"
"        cpt[6] = cpt[5] + cpt[9] - cpt[8];\n"
"    }\n"
"    if ((vBits & 4) != 0) {\n"
"        cpt[11] = cpt[8] + cpt[9] - cpt[5];\n"
"        cpt[10] = cpt[8] + cpt[7] - cpt[4];\n"
"    }\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// BSpline\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"// compute single-crease patch matrix\n"
"mat4\n"
"OsdComputeMs(float sharpness)\n"
"{\n"
"    float s = pow(2.0f, sharpness);\n"
"    float s2 = s*s;\n"
"    float s3 = s2*s;\n"
"\n"
"    mat4 m = mat4(\n"
"        0, s + 1 + 3*s2 - s3, 7*s - 2 - 6*s2 + 2*s3, (1-s)*(s-1)*(s-1),\n"
"        0,       (1+s)*(1+s),        6*s - 2 - 2*s2,       (s-1)*(s-1),\n"
"        0,               1+s,               6*s - 2,               1-s,\n"
"        0,                 1,               6*s - 2,                 1);\n"
"\n"
"    m /= (s*6.0);\n"
"    m[0][0] = 1.0/6.0;\n"
"\n"
"    return m;\n"
"}\n"
"\n"
"// flip matrix orientation\n"
"mat4\n"
"OsdFlipMatrix(mat4 m)\n"
"{\n"
"    return mat4(m[3][3], m[3][2], m[3][1], m[3][0],\n"
"                m[2][3], m[2][2], m[2][1], m[2][0],\n"
"                m[1][3], m[1][2], m[1][1], m[1][0],\n"
"                m[0][3], m[0][2], m[0][1], m[0][0]);\n"
"}\n"
"\n"
"// Regular BSpline to Bezier\n"
"const mat4 Q = mat4(\n"
"    1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f,\n"
"    0.f,     4.f/6.f, 2.f/6.f, 0.f,\n"
"    0.f,     2.f/6.f, 4.f/6.f, 0.f,\n"
"    0.f,     1.f/6.f, 4.f/6.f, 1.f/6.f\n"
");\n"
"\n"
"// Infinitely Sharp (boundary)\n"
"const mat4 Mi = mat4(\n"
"    1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f,\n"
"    0.f,     4.f/6.f, 2.f/6.f, 0.f,\n"
"    0.f,     2.f/6.f, 4.f/6.f, 0.f,\n"
"    0.f,     0.f,     1.f,     0.f\n"
");\n"
"\n"
"// convert BSpline cv to Bezier cv\n"
"void\n"
"OsdComputePerPatchVertexBSpline(ivec3 patchParam, int ID, vec3 cv[16],\n"
"                                out OsdPerPatchVertexBezier result)\n"
"{\n"
"    result.patchParam = patchParam;\n"
"\n"
"    int i = ID%4;\n"
"    int j = ID/4;\n"
"\n"
"#if defined OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"\n"
"    vec3 P  = vec3(0); // 0 to 1-2^(-Sf)\n"
"    vec3 P1 = vec3(0); // 1-2^(-Sf) to 1-2^(-Sc)\n"
"    vec3 P2 = vec3(0); // 1-2^(-Sc) to 1\n"
"\n"
"    float sharpness = OsdGetPatchSharpness(patchParam);\n"
"    if (sharpness > 0) {\n"
"        float Sf = floor(sharpness);\n"
"        float Sc = ceil(sharpness);\n"
"        float Sr = fract(sharpness);\n"
"        mat4 Mf = OsdComputeMs(Sf);\n"
"        mat4 Mc = OsdComputeMs(Sc);\n"
"        mat4 Mj = (1-Sr) * Mf + Sr * Mi;\n"
"        mat4 Ms = (1-Sr) * Mf + Sr * Mc;\n"
"        float s0 = 1 - pow(2, -floor(sharpness));\n"
"        float s1 = 1 - pow(2, -ceil(sharpness));\n"
"        result.vSegments = vec2(s0, s1);\n"
"\n"
"        mat4 MUi = Q, MUj = Q, MUs = Q;\n"
"        mat4 MVi = Q, MVj = Q, MVs = Q;\n"
"\n"
"        int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"        if ((boundaryMask & 1) != 0) {\n"
"            MVi = OsdFlipMatrix(Mi);\n"
"            MVj = OsdFlipMatrix(Mj);\n"
"            MVs = OsdFlipMatrix(Ms);\n"
"        }\n"
"        if ((boundaryMask & 2) != 0) {\n"
"            MUi = Mi;\n"
"            MUj = Mj;\n"
"            MUs = Ms;\n"
"        }\n"
"        if ((boundaryMask & 4) != 0) {\n"
"            MVi = Mi;\n"
"            MVj = Mj;\n"
"            MVs = Ms;\n"
"        }\n"
"        if ((boundaryMask & 8) != 0) {\n"
"            MUi = OsdFlipMatrix(Mi);\n"
"            MUj = OsdFlipMatrix(Mj);\n"
"            MUs = OsdFlipMatrix(Ms);\n"
"        }\n"
"\n"
"        vec3 Hi[4], Hj[4], Hs[4];\n"
"        for (int l=0; l<4; ++l) {\n"
"            Hi[l] = Hj[l] = Hs[l] = vec3(0);\n"
"            for (int k=0; k<4; ++k) {\n"
"                Hi[l] += MUi[i][k] * cv[l*4 + k];\n"
"                Hj[l] += MUj[i][k] * cv[l*4 + k];\n"
"                Hs[l] += MUs[i][k] * cv[l*4 + k];\n"
"            }\n"
"        }\n"
"        for (int k=0; k<4; ++k) {\n"
"            P  += MVi[j][k]*Hi[k];\n"
"            P1 += MVj[j][k]*Hj[k];\n"
"            P2 += MVs[j][k]*Hs[k];\n"
"        }\n"
"\n"
"        result.P  = P;\n"
"        result.P1 = P1;\n"
"        result.P2 = P2;\n"
"    } else {\n"
"        result.vSegments = vec2(0);\n"
"\n"
"        OsdComputeBSplineBoundaryPoints(cv, patchParam);\n"
"\n"
"        vec3 Hi[4];\n"
"        for (int l=0; l<4; ++l) {\n"
"            Hi[l] = vec3(0);\n"
"            for (int k=0; k<4; ++k) {\n"
"                Hi[l] += Q[i][k] * cv[l*4 + k];\n"
"            }\n"
"        }\n"
"        for (int k=0; k<4; ++k) {\n"
"            P += Q[j][k]*Hi[k];\n"
"        }\n"
"\n"
"        result.P  = P;\n"
"        result.P1 = P;\n"
"        result.P2 = P;\n"
"    }\n"
"#else\n"
"    OsdComputeBSplineBoundaryPoints(cv, patchParam);\n"
"\n"
"    vec3 H[4];\n"
"    for (int l=0; l<4; ++l) {\n"
"        H[l] = vec3(0);\n"
"        for (int k=0; k<4; ++k) {\n"
"            H[l] += Q[i][k] * cv[l*4 + k];\n"
"        }\n"
"    }\n"
"    {\n"
"        result.P = vec3(0);\n"
"        for (int k=0; k<4; ++k) {\n"
"            result.P += Q[j][k]*H[k];\n"
"        }\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezier(ivec3 patchParam, vec2 UV,\n"
"                   OsdPerPatchVertexBezier cv[16],\n"
"                   out vec3 P, out vec3 dPu, out vec3 dPv,\n"
"                   out vec3 N, out vec3 dNu, out vec3 dNv)\n"
"{\n"
"    //\n"
"    //  Use the recursive nature of the basis functions to compute a 2x2 set\n"
"    //  of intermediate points (via repeated linear interpolation).  These\n"
"    //  points define a bilinear surface tangent to the desired surface at P\n"
"    //  and so containing dPu and dPv.  The cost of computing P, dPu and dPv\n"
"    //  this way is comparable to that of typical tensor product evaluation\n"
"    //  (if not faster).\n"
"    //\n"
"    //  If N = dPu X dPv degenerates, it often results from an edge of the\n"
"    //  2x2 bilinear hull collapsing or two adjacent edges colinear. In both\n"
"    //  cases, the expected non-planar quad degenerates into a triangle, and\n"
"    //  the tangent plane of that triangle provides the desired normal N.\n"
"    //\n"
"\n"
"    //  Reduce 4x4 points to 2x4 -- two levels of linear interpolation in U\n"
"    //  and so 3 original rows contributing to each of the 2 resulting rows:\n"
"    float u    = UV.x;\n"
"    float uinv = 1.0f - u;\n"
"\n"
"    float u0 = uinv * uinv;\n"
"    float u1 = u * uinv * 2.0f;\n"
"    float u2 = u * u;\n"
"\n"
"    vec3 LROW[4], RROW[4];\n"
"#ifndef OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    LROW[0] = u0 * cv[ 0].P + u1 * cv[ 1].P + u2 * cv[ 2].P;\n"
"    LROW[1] = u0 * cv[ 4].P + u1 * cv[ 5].P + u2 * cv[ 6].P;\n"
"    LROW[2] = u0 * cv[ 8].P + u1 * cv[ 9].P + u2 * cv[10].P;\n"
"    LROW[3] = u0 * cv[12].P + u1 * cv[13].P + u2 * cv[14].P;\n"
"\n"
"    RROW[0] = u0 * cv[ 1].P + u1 * cv[ 2].P + u2 * cv[ 3].P;\n"
"    RROW[1] = u0 * cv[ 5].P + u1 * cv[ 6].P + u2 * cv[ 7].P;\n"
"    RROW[2] = u0 * cv[ 9].P + u1 * cv[10].P + u2 * cv[11].P;\n"
"    RROW[3] = u0 * cv[13].P + u1 * cv[14].P + u2 * cv[15].P;\n"
"#else\n"
"    vec2 vSegments = cv[0].vSegments;\n"
"    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, UV);\n"
"\n"
"    for (int i = 0; i < 4; ++i) {\n"
"        int j = i*4;\n"
"        if (s <= vSegments.x) {\n"
"            LROW[i] = u0 * cv[ j ].P + u1 * cv[j+1].P + u2 * cv[j+2].P;\n"
"            RROW[i] = u0 * cv[j+1].P + u1 * cv[j+2].P + u2 * cv[j+3].P;\n"
"        } else if (s <= vSegments.y) {\n"
"            LROW[i] = u0 * cv[ j ].P1 + u1 * cv[j+1].P1 + u2 * cv[j+2].P1;\n"
"            RROW[i] = u0 * cv[j+1].P1 + u1 * cv[j+2].P1 + u2 * cv[j+3].P1;\n"
"        } else {\n"
"            LROW[i] = u0 * cv[ j ].P2 + u1 * cv[j+1].P2 + u2 * cv[j+2].P2;\n"
"            RROW[i] = u0 * cv[j+1].P2 + u1 * cv[j+2].P2 + u2 * cv[j+3].P2;\n"
"        }\n"
"    }\n"
"#endif\n"
"\n"
"    //  Reduce 2x4 points to 2x2 -- two levels of linear interpolation in V\n"
"    //  and so 3 original pairs contributing to each of the 2 resulting:\n"
"    float v    = UV.y;\n"
"    float vinv = 1.0f - v;\n"
"\n"
"    float v0 = vinv * vinv;\n"
"    float v1 = v * vinv * 2.0f;\n"
"    float v2 = v * v;\n"
"\n"
"    vec3 LPAIR[2], RPAIR[2];\n"
"    LPAIR[0] = v0 * LROW[0] + v1 * LROW[1] + v2 * LROW[2];\n"
"    RPAIR[0] = v0 * RROW[0] + v1 * RROW[1] + v2 * RROW[2];\n"
"\n"
"    LPAIR[1] = v0 * LROW[1] + v1 * LROW[2] + v2 * LROW[3];\n"
"    RPAIR[1] = v0 * RROW[1] + v1 * RROW[2] + v2 * RROW[3];\n"
"\n"
"    //  Interpolate points on the edges of the 2x2 bilinear hull from which\n"
"    //  both position and partials are trivially determined:\n"
"    vec3 DU0 = vinv * LPAIR[0] + v * LPAIR[1];\n"
"    vec3 DU1 = vinv * RPAIR[0] + v * RPAIR[1];\n"
"    vec3 DV0 = uinv * LPAIR[0] + u * RPAIR[0];\n"
"    vec3 DV1 = uinv * LPAIR[1] + u * RPAIR[1];\n"
"\n"
"    int level = OsdGetPatchFaceLevel(patchParam);\n"
"    dPu = (DU1 - DU0) * 3 * level;\n"
"    dPv = (DV1 - DV0) * 3 * level;\n"
"\n"
"    P = u * DU1 + uinv * DU0;\n"
"\n"
"    //  Compute the normal and test for degeneracy:\n"
"    //\n"
"    //  We need a geometric measure of the size of the patch for a suitable\n"
"    //  tolerance.  Magnitudes of the partials are generally proportional to\n"
"    //  that size -- the sum of the partials is readily available, cheap to\n"
"    //  compute, and has proved effective in most cases (though not perfect).\n"
"    //  The size of the bounding box of the patch, or some approximation to\n"
"    //  it, would be better but more costly to compute.\n"
"    //\n"
"    float proportionalNormalTolerance = 0.00001f;\n"
"\n"
"    float nEpsilon = (length(dPu) + length(dPv)) * proportionalNormalTolerance;\n"
"\n"
"    N = cross(dPu, dPv);\n"
"\n"
"    float nLength = length(N);\n"
"    if (nLength > nEpsilon) {\n"
"        N = N / nLength;\n"
"    } else {\n"
"        vec3 diagCross = cross(RPAIR[1] - LPAIR[0], LPAIR[1] - RPAIR[0]);\n"
"        float diagCrossLength = length(diagCross);\n"
"        if (diagCrossLength > nEpsilon) {\n"
"            N = diagCross / diagCrossLength;\n"
"        }\n"
"    }\n"
"\n"
"#ifndef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    dNu = vec3(0);\n"
"    dNv = vec3(0);\n"
"#else\n"
"    //\n"
"    //  Compute 2nd order partials of P(u,v) in order to compute 1st order partials\n"
"    //  for the un-normalized n(u,v) = dPu X dPv, then project into the tangent\n"
"    //  plane of normalized N.  With resulting dNu and dNv we can make another\n"
"    //  attempt to resolve a still-degenerate normal.\n"
"    //\n"
"    //  We don't use the Weingarten equations here as they require N != 0 and also\n"
"    //  are a little less numerically stable/accurate in single precision.\n"
"    //\n"
"    float B0u[4], B1u[4], B2u[4];\n"
"    float B0v[4], B1v[4], B2v[4];\n"
"\n"
"    OsdUnivar4x4(UV.x, B0u, B1u, B2u);\n"
"    OsdUnivar4x4(UV.y, B0v, B1v, B2v);\n"
"\n"
"    vec3 dUU = vec3(0);\n"
"    vec3 dVV = vec3(0);\n"
"    vec3 dUV = vec3(0);\n"
"\n"
"    for (int i=0; i<4; ++i) {\n"
"        for (int j=0; j<4; ++j) {\n"
"#ifdef OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"            int k = 4*i + j;\n"
"            vec3 CV = (s <= vSegments.x) ? cv[k].P\n"
"                 :   ((s <= vSegments.y) ? cv[k].P1\n"
"                                         : cv[k].P2);\n"
"#else\n"
"            vec3 CV = cv[4*i + j].P;\n"
"#endif\n"
"            dUU += (B0v[i] * B2u[j]) * CV;\n"
"            dVV += (B2v[i] * B0u[j]) * CV;\n"
"            dUV += (B1v[i] * B1u[j]) * CV;\n"
"        }\n"
"    }\n"
"\n"
"    dUU *= 6 * level;\n"
"    dVV *= 6 * level;\n"
"    dUV *= 9 * level;\n"
"\n"
"    dNu = cross(dUU, dPv) + cross(dPu, dUV);\n"
"    dNv = cross(dUV, dPv) + cross(dPu, dVV);\n"
"\n"
"    float nLengthInv = 1.0;\n"
"    if (nLength > nEpsilon) {\n"
"        nLengthInv = 1.0 / nLength;\n"
"    } else {\n"
"        //  N may have been resolved above if degenerate, but if N was resolved\n"
"        //  we don't have an accurate length for its un-normalized value, and that\n"
"        //  length is needed to project the un-normalized dNu and dNv into the\n"
"        //  tangent plane of N.\n"
"        //\n"
"        //  So compute N more accurately with available second derivatives, i.e.\n"
"        //  with a 1st order Taylor approximation to un-normalized N(u,v).\n"
"\n"
"        float DU = (UV.x == 1.0f) ? -1.0f : 1.0f;\n"
"        float DV = (UV.y == 1.0f) ? -1.0f : 1.0f;\n"
"\n"
"        N = DU * dNu + DV * dNv;\n"
"\n"
"        nLength = length(N);\n"
"        if (nLength > nEpsilon) {\n"
"            nLengthInv = 1.0f / nLength;\n"
"            N = N * nLengthInv;\n"
"        }\n"
"    }\n"
"\n"
"    //  Project derivatives of non-unit normals into tangent plane of N:\n"
"    dNu = (dNu - dot(dNu,N) * N) * nLengthInv;\n"
"    dNv = (dNv - dot(dNv,N) * N) * nLengthInv;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Gregory Basis\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"struct OsdPerPatchVertexGregoryBasis {\n"
"    ivec3 patchParam;\n"
"    vec3 P;\n"
"};\n"
"\n"
"void\n"
"OsdComputePerPatchVertexGregoryBasis(ivec3 patchParam, int ID, vec3 cv,\n"
"                                     out OsdPerPatchVertexGregoryBasis result)\n"
"{\n"
"    result.patchParam = patchParam;\n"
"    result.P = cv;\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchGregory(ivec3 patchParam, vec2 UV, vec3 cv[20],\n"
"                    out vec3 P, out vec3 dPu, out vec3 dPv,\n"
"                    out vec3 N, out vec3 dNu, out vec3 dNv)\n"
"{\n"
"    float u = UV.x, v = UV.y;\n"
"    float U = 1-u, V = 1-v;\n"
"\n"
"    //(0,1)                              (1,1)\n"
"    //   P3         e3-      e2+         P2\n"
"    //      15------17-------11-------10\n"
"    //      |        |        |        |\n"
"    //      |        |        |        |\n"
"    //      |        | f3-    | f2+    |\n"
"    //      |       19       13        |\n"
"    //  e3+ 16-----18          14-----12 e2-\n"
"    //      |     f3+          f2-     |\n"
"    //      |                          |\n"
"    //      |                          |\n"
"    //      |     f0-         f1+      |\n"
"    //  e0- 2------4            8------6 e1+\n"
"    //      |        3 f0+    9        |\n"
"    //      |        |        | f1-    |\n"
"    //      |        |        |        |\n"
"    //      |        |        |        |\n"
"    //      0--------1--------7--------5\n"
"    //    P0        e0+      e1-         P1\n"
"    //(0,0)                               (1,0)\n"
"\n"
"    float d11 = u+v;\n"
"    float d12 = U+v;\n"
"    float d21 = u+V;\n"
"    float d22 = U+V;\n"
"\n"
"    OsdPerPatchVertexBezier bezcv[16];\n"
"\n"
"    bezcv[ 5].P = (d11 == 0.0) ? cv[3]  : (u*cv[3] + v*cv[4])/d11;\n"
"    bezcv[ 6].P = (d12 == 0.0) ? cv[8]  : (U*cv[9] + v*cv[8])/d12;\n"
"    bezcv[ 9].P = (d21 == 0.0) ? cv[18] : (u*cv[19] + V*cv[18])/d21;\n"
"    bezcv[10].P = (d22 == 0.0) ? cv[13] : (U*cv[13] + V*cv[14])/d22;\n"
"\n"
"    bezcv[ 0].P = cv[0];\n"
"    bezcv[ 1].P = cv[1];\n"
"    bezcv[ 2].P = cv[7];\n"
"    bezcv[ 3].P = cv[5];\n"
"    bezcv[ 4].P = cv[2];\n"
"    bezcv[ 7].P = cv[6];\n"
"    bezcv[ 8].P = cv[16];\n"
"    bezcv[11].P = cv[12];\n"
"    bezcv[12].P = cv[15];\n"
"    bezcv[13].P = cv[17];\n"
"    bezcv[14].P = cv[11];\n"
"    bezcv[15].P = cv[10];\n"
"\n"
"    OsdEvalPatchBezier(patchParam, UV, bezcv, P, dPu, dPv, N, dNu, dNv);\n"
"}\n"
"\n"
"//\n"
"//  Convert the 12 points of a regular patch resulting from Loop subdivision\n"
"//  into a more accessible Bezier patch for both tessellation assessment and\n"
"//  evaluation.\n"
"//\n"
"//  Regular patch for Loop subdivision -- quartic triangular Box spline:\n"
"//\n"
"//                           10 --- 11\n"
"//                           . .   . .\n"
"//                          .   . .   .\n"
"//                         7 --- 8 --- 9\n"
"//                        . .   . .   . .\n"
"//                       .   . .   . .   .\n"
"//                      3 --- 4 --- 5 --- 6\n"
"//                       .   . .   . .   .\n"
"//                        . .   . .   . .\n"
"//                         0 --- 1 --- 2\n"
"//\n"
"//  The equivalant quartic Bezier triangle (15 points):\n"
"//\n"
"//                              14\n"
"//                              . .\n"
"//                             .   .\n"
"//                           12 --- 13\n"
"//                           . .   . .\n"
"//                          .   . .   .\n"
"//                         9 -- 10 --- 11\n"
"//                        . .   . .   . .\n"
"//                       .   . .   . .   .\n"
"//                      5 --- 6 --- 7 --- 8\n"
"//                     . .   . .   . .   . .\n"
"//                    .   . .   . .   . .   .\n"
"//                   0 --- 1 --- 2 --- 3 --- 4\n"
"//\n"
"//  A hybrid cubic/quartic Bezier patch with cubic boundaries is a close\n"
"//  approximation and would only use 12 control points, but we need a full\n"
"//  quartic patch to maintain accuracy along boundary curves -- especially\n"
"//  between subdivision levels.\n"
"//\n"
"void\n"
"OsdComputePerPatchVertexBoxSplineTriangle(ivec3 patchParam, int ID, vec3 cv[12],\n"
"                                          out OsdPerPatchVertexBezier result)\n"
"{\n"
"    //\n"
"    //  Conversion matrix from 12-point Box spline to 15-point quartic Bezier\n"
"    //  patch and its common scale factor:\n"
"    //\n"
"    const float boxToBezierMatrix[12*15] = float[12*15](\n"
"    // L0   L1   L2     L3   L4   L5   L6     L7   L8   L9     L10  L11\n"
"        2,   2,   0,     2,  12,   2,   0,     2,   2,   0,     0,   0,  // B0\n"
"        1,   3,   0,     0,  12,   4,   0,     1,   3,   0,     0,   0,  // B1\n"
"        0,   4,   0,     0,   8,   8,   0,     0,   4,   0,     0,   0,  // B2\n"
"        0,   3,   1,     0,   4,  12,   0,     0,   3,   1,     0,   0,  // B3\n"
"        0,   2,   2,     0,   2,  12,   2,     0,   2,   2,     0,   0,  // B4\n"
"        0,   1,   0,     1,  12,   3,   0,     3,   4,   0,     0,   0,  // B5\n"
"        0,   1,   0,     0,  10,   6,   0,     1,   6,   0,     0,   0,  // B6\n"
"        0,   1,   0,     0,   6,  10,   0,     0,   6,   1,     0,   0,  // B7\n"
"        0,   1,   0,     0,   3,  12,   1,     0,   4,   3,     0,   0,  // B8\n"
"        0,   0,   0,     0,   8,   4,   0,     4,   8,   0,     0,   0,  // B9\n"
"        0,   0,   0,     0,   6,   6,   0,     1,  10,   1,     0,   0,  // B10\n"
"        0,   0,   0,     0,   4,   8,   0,     0,   8,   4,     0,   0,  // B11\n"
"        0,   0,   0,     0,   4,   3,   0,     3,  12,   1,     1,   0,  // B12\n"
"        0,   0,   0,     0,   3,   4,   0,     1,  12,   3,     0,   1,  // B13\n"
"        0,   0,   0,     0,   2,   2,   0,     2,  12,   2,     2,   2   // B14\n"
"    );\n"
"    const float boxToBezierMatrixScale = 1.0 / 24.0;\n"
"\n"
"    OsdComputeBoxSplineTriangleBoundaryPoints(cv, patchParam);\n"
"\n"
"    result.patchParam = patchParam;\n"
"    result.P = vec3(0);\n"
"\n"
"    int cvCoeffBase = 12 * ID;\n"
"\n"
"    for (int i = 0; i < 12; ++i) {\n"
"        result.P += boxToBezierMatrix[cvCoeffBase + i] * cv[i];\n"
"    }\n"
"    result.P *= boxToBezierMatrixScale;\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezierTriangle(ivec3 patchParam, vec2 UV,\n"
"                           OsdPerPatchVertexBezier cv[15],\n"
"                           out vec3 P, out vec3 dPu, out vec3 dPv,\n"
"                           out vec3 N, out vec3 dNu, out vec3 dNv)\n"
"{\n"
"    float u = UV.x;\n"
"    float v = UV.y;\n"
"    float w = 1.0 - u - v;\n"
"\n"
"    float uu = u * u;\n"
"    float vv = v * v;\n"
"    float ww = w * w;\n"
"\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    //\n"
"    //  When computing normal derivatives, we need 2nd derivatives, so compute\n"
"    //  an intermediate quadratic Bezier triangle from which 2nd derivatives\n"
"    //  can be easily computed, and which in turn yields the triangle that gives\n"
"    //  the position and 1st derivatives.\n"
"    //\n"
"    //  Quadratic barycentric basis functions (in addition to those above):\n"
"    float uv = u * v * 2.0;\n"
"    float vw = v * w * 2.0;\n"
"    float wu = w * u * 2.0;\n"
"\n"
"    vec3 Q0 = ww * cv[ 0].P + wu * cv[ 1].P + uu * cv[ 2].P +\n"
"              uv * cv[ 6].P + vv * cv[ 9].P + vw * cv[ 5].P;\n"
"    vec3 Q1 = ww * cv[ 1].P + wu * cv[ 2].P + uu * cv[ 3].P +\n"
"              uv * cv[ 7].P + vv * cv[10].P + vw * cv[ 6].P;\n"
"    vec3 Q2 = ww * cv[ 2].P + wu * cv[ 3].P + uu * cv[ 4].P +\n"
"              uv * cv[ 8].P + vv * cv[11].P + vw * cv[ 7].P;\n"
"    vec3 Q3 = ww * cv[ 5].P + wu * cv[ 6].P + uu * cv[ 7].P +\n"
"              uv * cv[10].P + vv * cv[12].P + vw * cv[ 9].P;\n"
"    vec3 Q4 = ww * cv[ 6].P + wu * cv[ 7].P + uu * cv[ 8].P +\n"
"              uv * cv[11].P + vv * cv[13].P + vw * cv[10].P;\n"
"    vec3 Q5 = ww * cv[ 9].P + wu * cv[10].P + uu * cv[11].P +\n"
"              uv * cv[13].P + vv * cv[14].P + vw * cv[12].P;\n"
"\n"
"    vec3 V0 = w * Q0 + u * Q1 + v * Q3;\n"
"    vec3 V1 = w * Q1 + u * Q2 + v * Q4;\n"
"    vec3 V2 = w * Q3 + u * Q4 + v * Q5;\n"
"#else\n"
"    //\n"
"    //  When 2nd derivatives are not required, factor the recursive evaluation\n"
"    //  of a point to directly provide the three points of the triangle at the\n"
"    //  last stage -- which then trivially provides both position and 1st\n"
"    //  derivatives.  Each point of the triangle results from evaluating the\n"
"    //  corresponding cubic Bezier sub-triangle for each corner of the quartic:\n"
"    //\n"
"    //  Cubic barycentric basis functions:\n"
"    float uuu = uu * u;\n"
"    float uuv = uu * v * 3.0;\n"
"    float uvv = u * vv * 3.0;\n"
"    float vvv = vv * v;\n"
"    float vvw = vv * w * 3.0;\n"
"    float vww = v * ww * 3.0;\n"
"    float www = ww * w;\n"
"    float wwu = ww * u * 3.0;\n"
"    float wuu = w * uu * 3.0;\n"
"    float uvw = u * v * w * 6.0;\n"
"\n"
"    vec3 V0 = www * cv[ 0].P + wwu * cv[ 1].P + wuu * cv[ 2].P\n"
"            + uuu * cv[ 3].P + uuv * cv[ 7].P + uvv * cv[10].P\n"
"            + vvv * cv[12].P + vvw * cv[ 9].P + vww * cv[ 5].P + uvw * cv[ 6].P;\n"
"\n"
"    vec3 V1 = www * cv[ 1].P + wwu * cv[ 2].P + wuu * cv[ 3].P\n"
"            + uuu * cv[ 4].P + uuv * cv[ 8].P + uvv * cv[11].P\n"
"            + vvv * cv[13].P + vvw * cv[10].P + vww * cv[ 6].P + uvw * cv[ 7].P;\n"
"\n"
"    vec3 V2 = www * cv[ 5].P + wwu * cv[ 6].P + wuu * cv[ 7].P\n"
"            + uuu * cv[ 8].P + uuv * cv[11].P + uvv * cv[13].P\n"
"            + vvv * cv[14].P + vvw * cv[12].P + vww * cv[ 9].P + uvw * cv[10].P;\n"
"#endif\n"
"\n"
"    //\n"
"    //  Compute P, du and dv all from the triangle formed from the three Vi:\n"
"    //\n"
"    P = w * V0 + u * V1 + v * V2;\n"
"\n"
"    int dSign = OsdGetPatchIsTriangleRotated(patchParam) ? -1 : 1;\n"
"    int level = OsdGetPatchFaceLevel(patchParam);\n"
"\n"
"    float d1Scale = dSign * level * 4;\n"
"\n"
"    dPu = (V1 - V0) * d1Scale;\n"
"    dPv = (V2 - V0) * d1Scale;\n"
"\n"
"    //  Compute N and test for degeneracy:\n"
"    //\n"
"    //  We need a geometric measure of the size of the patch for a suitable\n"
"    //  tolerance.  Magnitudes of the partials are generally proportional to\n"
"    //  that size -- the sum of the partials is readily available, cheap to\n"
"    //  compute, and has proved effective in most cases (though not perfect).\n"
"    //  The size of the bounding box of the patch, or some approximation to\n"
"    //  it, would be better but more costly to compute.\n"
"    //\n"
"    float proportionalNormalTolerance = 0.00001f;\n"
"\n"
"    float nEpsilon = (length(dPu) + length(dPv)) * proportionalNormalTolerance;\n"
"\n"
"    N = cross(dPu, dPv);\n"
"    float nLength = length(N);\n"
"\n"
"\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    //\n"
"    //  Compute normal derivatives using 2nd order partials, then use the\n"
"    //  normal derivatives to resolve a degenerate normal:\n"
"    //\n"
"    float d2Scale = dSign * level * level * 12;\n"
"\n"
"    vec3 dUU = (Q0 - 2 * Q1 + Q2)  * d2Scale;\n"
"    vec3 dVV = (Q0 - 2 * Q3 + Q5)  * d2Scale;\n"
"    vec3 dUV = (Q0 - Q1 + Q4 - Q3) * d2Scale;\n"
"\n"
"    dNu = cross(dUU, dPv) + cross(dPu, dUV);\n"
"    dNv = cross(dUV, dPv) + cross(dPu, dVV);\n"
"\n"
"    if (nLength < nEpsilon) {\n"
"        //  Use 1st order Taylor approximation of N(u,v) within patch interior:\n"
"        if (w > 0.0) {\n"
"            N =  dNu + dNv;\n"
"        } else if (u >= 1.0) {\n"
"            N = -dNu + dNv;\n"
"        } else if (v >= 1.0) {\n"
"            N =  dNu - dNv;\n"
"        } else {\n"
"            N = -dNu - dNv;\n"
"        }\n"
"\n"
"        nLength = length(N);\n"
"        if (nLength < nEpsilon) {\n"
"            nLength = 1.0;\n"
"        }\n"
"    }\n"
"    N = N / nLength;\n"
"\n"
"    //  Project derivs of non-unit normal function onto tangent plane of N:\n"
"    dNu = (dNu - dot(dNu,N) * N) / nLength;\n"
"    dNv = (dNv - dot(dNv,N) * N) / nLength;\n"
"#else\n"
"    dNu = vec3(0);\n"
"    dNv = vec3(0);\n"
"\n"
"    //\n"
"    //  Resolve a degenerate normal using the interior triangle of the\n"
"    //  intermediate quadratic patch that results from recursive evaluation.\n"
"    //  This addresses common cases of degenerate or colinear boundaries\n"
"    //  without resorting to use of explicit 2nd derivatives:\n"
"    //\n"
"    if (nLength < nEpsilon) {\n"
"        float uv  = u * v * 2.0;\n"
"        float vw  = v * w * 2.0;\n"
"        float wu  = w * u * 2.0;\n"
"\n"
"        vec3 Q1 = ww * cv[ 1].P + wu * cv[ 2].P + uu * cv[ 3].P +\n"
"                  uv * cv[ 7].P + vv * cv[10].P + vw * cv[ 6].P;\n"
"        vec3 Q3 = ww * cv[ 5].P + wu * cv[ 6].P + uu * cv[ 7].P +\n"
"                  uv * cv[10].P + vv * cv[12].P + vw * cv[ 9].P;\n"
"        vec3 Q4 = ww * cv[ 6].P + wu * cv[ 7].P + uu * cv[ 8].P +\n"
"                  uv * cv[11].P + vv * cv[13].P + vw * cv[10].P;\n"
"\n"
"        N = cross((Q4 - Q1), (Q3 - Q1));\n"
"        nLength = length(N);\n"
"        if (nLength < nEpsilon) {\n"
"            nLength = 1.0;\n"
"        }\n"
"    }\n"
"    N = N / nLength;\n"
"#endif\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchGregoryTriangle(ivec3 patchParam, vec2 UV, vec3 cv[18],\n"
"                            out vec3 P, out vec3 dPu, out vec3 dPv,\n"
"                            out vec3 N, out vec3 dNu, out vec3 dNv)\n"
"{\n"
"    float u = UV.x;\n"
"    float v = UV.y;\n"
"    float w = 1.0 - u - v;\n"
"\n"
"    float duv = u + v;\n"
"    float dvw = v + w;\n"
"    float dwu = w + u;\n"
"\n"
"    OsdPerPatchVertexBezier bezcv[15];\n"
"\n"
"    bezcv[ 6].P = (duv == 0.0) ? cv[3]  : ((u*cv[ 3] + v*cv[ 4]) / duv);\n"
"    bezcv[ 7].P = (dvw == 0.0) ? cv[8]  : ((v*cv[ 8] + w*cv[ 9]) / dvw);\n"
"    bezcv[10].P = (dwu == 0.0) ? cv[13] : ((w*cv[13] + u*cv[14]) / dwu);\n"
"\n"
"    bezcv[ 0].P = cv[ 0];\n"
"    bezcv[ 1].P = cv[ 1];\n"
"    bezcv[ 2].P = cv[15];\n"
"    bezcv[ 3].P = cv[ 7];\n"
"    bezcv[ 4].P = cv[ 5];\n"
"    bezcv[ 5].P = cv[ 2];\n"
"    bezcv[ 8].P = cv[ 6];\n"
"    bezcv[ 9].P = cv[17];\n"
"    bezcv[11].P = cv[16];\n"
"    bezcv[12].P = cv[11];\n"
"    bezcv[13].P = cv[12];\n"
"    bezcv[14].P = cv[10];\n"
"\n"
"    OsdEvalPatchBezierTriangle(patchParam, UV, bezcv, P, dPu, dPv, N, dNu, dNv);\n"
"}\n"
"\n"
"\n"

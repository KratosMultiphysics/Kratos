//    |  /           |
//    ' /   __| _` | __|  _ \   __|
//    . \  |   (   | |   (   |\__ \.
//   _|\_\_|  \__,_|\__|\___/ ____/
//                   Multi-Physics
//
//  License:         BSD License
//                   Kratos default license: kratos/license.txt
//
//  Main authors:    Eduard GÃ³mez
//

/**
 *
 *                          WARNING! THIS FILE IS READ-ONLY
 *
 * This file has been auto-generated by the compressible navier stokes symbolic generator
 * located in the symbolic_generation directories of the FluidDynamicsApplication
 *
 * Any modifications to this file will be overwritten if and when that script is run again.
 *
 * In order to do any lasting changes, modify the template used by the script:
 * templates/compressible_navier_stokes_explicit_condition_template_2D2N.cpp
 * located in the symbolic_generation directories of the FluidDynamicsApplication.
 *
 * In order to change the formulation you will have to modify the script itself.
 */

// System includes


// External includes


// Project includes


// Application includes
#include "compressible_navier_stokes_explicit_condition.h"


namespace Kratos {

/**
 * Returns the integration method for computation of midpoint magnitudes.
 * Computation of RHS integration method is chosen in the symbolic generator.
 */
template<>
GeometryData::IntegrationMethod CompressibleNavierStokesExplicitCondition<2,2>::GetIntegrationMethod()
{
    return GeometryData::IntegrationMethod::GI_GAUSS_1;
}

template <>
void CompressibleNavierStokesExplicitCondition<2, 2>::EquationIdVector(
    EquationIdVectorType& rResult,
    const ProcessInfo& rCurrentProcessInfo) const
{
    KRATOS_TRY

    if (rResult.size() != DofSize) {
        rResult.resize(DofSize);
    }

    unsigned int local_index = 0;
    const auto& r_geometry = GetGeometry();
    const unsigned int den_pos = r_geometry[0].GetDofPosition(DENSITY);
    const unsigned int mom_pos = r_geometry[0].GetDofPosition(MOMENTUM);
    const unsigned int enr_pos = r_geometry[0].GetDofPosition(TOTAL_ENERGY);
    for (unsigned int i_node = 0; i_node < NumNodes; ++i_node) {
        rResult[local_index++] = r_geometry[i_node].GetDof(DENSITY, den_pos).EquationId();
        rResult[local_index++] = r_geometry[i_node].GetDof(MOMENTUM_X, mom_pos).EquationId();
        rResult[local_index++] = r_geometry[i_node].GetDof(MOMENTUM_Y, mom_pos + 1).EquationId();
        rResult[local_index++] = r_geometry[i_node].GetDof(TOTAL_ENERGY, enr_pos).EquationId();
    }

    KRATOS_CATCH("");
}

template <>
void CompressibleNavierStokesExplicitCondition<2, 2>::GetDofList(
    DofsVectorType& ConditionDofList,
    const ProcessInfo& rCurrentProcessInfo) const
{
    KRATOS_TRY

    if (ConditionDofList.size() != DofSize) {
        ConditionDofList.resize(DofSize);
    }

    unsigned int local_index = 0;
    const auto& r_geometry = GetGeometry();
    const unsigned int den_pos = r_geometry[0].GetDofPosition(DENSITY);
    const unsigned int mom_pos = r_geometry[0].GetDofPosition(MOMENTUM);
    const unsigned int enr_pos = r_geometry[0].GetDofPosition(TOTAL_ENERGY);
    for (unsigned int i_node = 0; i_node < NumNodes; ++i_node) {
        ConditionDofList[local_index++] = r_geometry[i_node].pGetDof(DENSITY, den_pos);
        ConditionDofList[local_index++] = r_geometry[i_node].pGetDof(MOMENTUM_X, mom_pos);
        ConditionDofList[local_index++] = r_geometry[i_node].pGetDof(MOMENTUM_Y, mom_pos + 1);
        ConditionDofList[local_index++] = r_geometry[i_node].pGetDof(TOTAL_ENERGY, enr_pos);
    }

    KRATOS_CATCH("");
}

template<>
BoundedVector<double, 8> CompressibleNavierStokesExplicitCondition<2,2>::CalculateRightHandSideInternal(
    const ProcessInfo& rCurrentProcessInfo)
{
    KRATOS_TRY

    BoundedVector<double, BlockSize*NumNodes> rRightHandSideBoundedVector = ZeroVector(BlockSize*NumNodes);

    const auto data = ConditionData(rCurrentProcessInfo);

    const double crRightHandSideBoundedVector0 = data.alpha_sc_nodes(0) + data.alpha_sc_nodes(1);
    const double crRightHandSideBoundedVector1 = data.U(0,1) + data.U(1,1);
    const double crRightHandSideBoundedVector2 = data.U(0,2) + data.U(1,2);
    const double crRightHandSideBoundedVector3 = 0.25*data.unit_normal(0)*(crRightHandSideBoundedVector0*data.gradients[0].density(0) + crRightHandSideBoundedVector1) + 0.25*data.unit_normal(1)*(crRightHandSideBoundedVector0*data.gradients[0].density(1) + crRightHandSideBoundedVector2);
    const double crRightHandSideBoundedVector4 = data.U(0,0) + data.U(1,0);
    const double crRightHandSideBoundedVector5 = 1.0/crRightHandSideBoundedVector4;
    const double crRightHandSideBoundedVector6 = 0.5*crRightHandSideBoundedVector1*crRightHandSideBoundedVector2;
    const double crRightHandSideBoundedVector7 = crRightHandSideBoundedVector2*data.gradients[0].density(0);
    const double crRightHandSideBoundedVector8 = crRightHandSideBoundedVector1*data.gradients[0].density(1);
    const double crRightHandSideBoundedVector9 = crRightHandSideBoundedVector4*data.gradients[0].momentum(0,1);
    const double crRightHandSideBoundedVector10 = crRightHandSideBoundedVector4*data.gradients[0].momentum(1,0);
    const double crRightHandSideBoundedVector11 = data.mu + 0.5*data.mu_sc_nodes(0) + 0.5*data.mu_sc_nodes(1);
    const double crRightHandSideBoundedVector12 = 2.0*crRightHandSideBoundedVector5;
    const double crRightHandSideBoundedVector13 = crRightHandSideBoundedVector11*crRightHandSideBoundedVector12;
    const double crRightHandSideBoundedVector14 = pow(crRightHandSideBoundedVector1, 2);
    const double crRightHandSideBoundedVector15 = 0.5*crRightHandSideBoundedVector5;
    const double crRightHandSideBoundedVector16 = crRightHandSideBoundedVector1*data.gradients[0].density(0);
    const double crRightHandSideBoundedVector17 = crRightHandSideBoundedVector4*data.gradients[0].momentum(0,0);
    const double crRightHandSideBoundedVector18 = crRightHandSideBoundedVector16 - crRightHandSideBoundedVector17;
    const double crRightHandSideBoundedVector19 = pow(crRightHandSideBoundedVector4, -2);
    const double crRightHandSideBoundedVector20 = 4.0*crRightHandSideBoundedVector11;
    const double crRightHandSideBoundedVector21 = crRightHandSideBoundedVector19*crRightHandSideBoundedVector20;
    const double crRightHandSideBoundedVector22 = pow(crRightHandSideBoundedVector2, 2);
    const double crRightHandSideBoundedVector23 = 0.5*data.U(0,3) + 0.5*data.U(1,3);
    const double crRightHandSideBoundedVector24 = (crRightHandSideBoundedVector23 - crRightHandSideBoundedVector5*(0.25*crRightHandSideBoundedVector14 + 0.25*crRightHandSideBoundedVector22))*(data.gamma - 1);
    const double crRightHandSideBoundedVector25 = crRightHandSideBoundedVector2*data.gradients[0].density(1);
    const double crRightHandSideBoundedVector26 = crRightHandSideBoundedVector4*data.gradients[0].momentum(1,1);
    const double crRightHandSideBoundedVector27 = crRightHandSideBoundedVector25 - crRightHandSideBoundedVector26;
    const double crRightHandSideBoundedVector28 = 0.5*data.beta_sc_nodes(0);
    const double crRightHandSideBoundedVector29 = 0.5*data.beta_sc_nodes(1);
    const double crRightHandSideBoundedVector30 = 0.66666666666666663*data.mu;
    const double crRightHandSideBoundedVector31 = 0.33333333333333331*data.mu_sc_nodes(0);
    const double crRightHandSideBoundedVector32 = 0.33333333333333331*data.mu_sc_nodes(1);
    const double crRightHandSideBoundedVector33 = 2.0*crRightHandSideBoundedVector19;
    const double crRightHandSideBoundedVector34 = crRightHandSideBoundedVector24 - crRightHandSideBoundedVector33*(crRightHandSideBoundedVector18 + crRightHandSideBoundedVector27)*(-crRightHandSideBoundedVector28 - crRightHandSideBoundedVector29 + crRightHandSideBoundedVector30 + crRightHandSideBoundedVector31 + crRightHandSideBoundedVector32);
    const double crRightHandSideBoundedVector35 = 0.5*crRightHandSideBoundedVector5*data.unit_normal(1)*(crRightHandSideBoundedVector13*(-crRightHandSideBoundedVector10 + crRightHandSideBoundedVector7 + crRightHandSideBoundedVector8 - crRightHandSideBoundedVector9) + crRightHandSideBoundedVector6) + 0.5*data.unit_normal(0)*(crRightHandSideBoundedVector14*crRightHandSideBoundedVector15 + crRightHandSideBoundedVector18*crRightHandSideBoundedVector21 + crRightHandSideBoundedVector34);
    const double crRightHandSideBoundedVector36 = crRightHandSideBoundedVector10 - crRightHandSideBoundedVector7 - crRightHandSideBoundedVector8 + crRightHandSideBoundedVector9;
    const double crRightHandSideBoundedVector37 = -0.5*crRightHandSideBoundedVector5*data.unit_normal(0)*(crRightHandSideBoundedVector13*crRightHandSideBoundedVector36 - crRightHandSideBoundedVector6) + 0.5*data.unit_normal(1)*(crRightHandSideBoundedVector15*crRightHandSideBoundedVector22 + crRightHandSideBoundedVector21*crRightHandSideBoundedVector27 + crRightHandSideBoundedVector34);
    const double crRightHandSideBoundedVector38 = crRightHandSideBoundedVector11*crRightHandSideBoundedVector33*crRightHandSideBoundedVector36;
    const double crRightHandSideBoundedVector39 = 1.0*crRightHandSideBoundedVector23 + 1.0*crRightHandSideBoundedVector24;
    const double crRightHandSideBoundedVector40 = data.U(0,3) + data.U(1,3);
    const double crRightHandSideBoundedVector41 = crRightHandSideBoundedVector5*data.gradients[0].density(0);
    const double crRightHandSideBoundedVector42 = crRightHandSideBoundedVector12*(0.5*data.lamb_sc_nodes(0) + 0.5*data.lamb_sc_nodes(1) + data.lambda)/data.c_v;
    const double crRightHandSideBoundedVector43 = -crRightHandSideBoundedVector16 + crRightHandSideBoundedVector17;
    const double crRightHandSideBoundedVector44 = -crRightHandSideBoundedVector25 + crRightHandSideBoundedVector26;
    const double crRightHandSideBoundedVector45 = 2.0*(crRightHandSideBoundedVector43 + crRightHandSideBoundedVector44)*(crRightHandSideBoundedVector28 + crRightHandSideBoundedVector29 - crRightHandSideBoundedVector30 - crRightHandSideBoundedVector31 - crRightHandSideBoundedVector32);
    const double crRightHandSideBoundedVector46 = 1.0*crRightHandSideBoundedVector19;
    const double crRightHandSideBoundedVector47 = crRightHandSideBoundedVector5*data.gradients[0].density(1);
    const double crRightHandSideBoundedVector48 = -crRightHandSideBoundedVector15*(data.unit_normal(0)*(-crRightHandSideBoundedVector1*crRightHandSideBoundedVector39 + crRightHandSideBoundedVector1*crRightHandSideBoundedVector46*(crRightHandSideBoundedVector20*crRightHandSideBoundedVector43 + crRightHandSideBoundedVector45) + crRightHandSideBoundedVector2*crRightHandSideBoundedVector38 + crRightHandSideBoundedVector42*(-crRightHandSideBoundedVector1*data.gradients[0].momentum(0,0) + crRightHandSideBoundedVector14*crRightHandSideBoundedVector41 - crRightHandSideBoundedVector2*data.gradients[0].momentum(0,1) + crRightHandSideBoundedVector22*crRightHandSideBoundedVector41 + crRightHandSideBoundedVector4*data.gradients[0].total_energy(0) - crRightHandSideBoundedVector40*data.gradients[0].density(0))) + data.unit_normal(1)*(crRightHandSideBoundedVector1*crRightHandSideBoundedVector38 - crRightHandSideBoundedVector2*crRightHandSideBoundedVector39 + crRightHandSideBoundedVector2*crRightHandSideBoundedVector46*(crRightHandSideBoundedVector20*crRightHandSideBoundedVector44 + crRightHandSideBoundedVector45) + crRightHandSideBoundedVector42*(-crRightHandSideBoundedVector1*data.gradients[0].momentum(1,0) + crRightHandSideBoundedVector14*crRightHandSideBoundedVector47 - crRightHandSideBoundedVector2*data.gradients[0].momentum(1,1) + crRightHandSideBoundedVector22*crRightHandSideBoundedVector47 + crRightHandSideBoundedVector4*data.gradients[0].total_energy(1) - crRightHandSideBoundedVector40*data.gradients[0].density(1))));
    rRightHandSideBoundedVector[0] = crRightHandSideBoundedVector3;
    rRightHandSideBoundedVector[1] = crRightHandSideBoundedVector35;
    rRightHandSideBoundedVector[2] = crRightHandSideBoundedVector37;
    rRightHandSideBoundedVector[3] = crRightHandSideBoundedVector48;
    rRightHandSideBoundedVector[4] = crRightHandSideBoundedVector3;
    rRightHandSideBoundedVector[5] = crRightHandSideBoundedVector35;
    rRightHandSideBoundedVector[6] = crRightHandSideBoundedVector37;
    rRightHandSideBoundedVector[7] = crRightHandSideBoundedVector48;


    // Here we assume that all the weights of the gauss points are the same so we multiply at the end by Volume/NumNodes
    rRightHandSideBoundedVector *= data.volume / static_cast<double>(NumNodes);

    return rRightHandSideBoundedVector;
    KRATOS_CATCH("")
}


template class CompressibleNavierStokesExplicitCondition<2,2>;
using CompressibleNavierStokesExplicitCondition2D2N = CompressibleNavierStokesExplicitCondition<2,2>;

}
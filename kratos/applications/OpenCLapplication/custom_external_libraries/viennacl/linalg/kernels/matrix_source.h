#ifndef _VIENNACL_MATRIX_SOURCE_HPP_
#define _VIENNACL_MATRIX_SOURCE_HPP_
//Automatically generated file from aux-directory, do not edit manually!
namespace viennacl
{
 namespace linalg
 {
  namespace kernels
  {
const char * const matrix_align1_trans_lower_triangular_substitute_inplace = 
"__kernel void trans_lower_triangular_substitute_inplace(\n"
"          __global const float * matrix,\n"
"          __global float * vector,\n"
"          unsigned int row_length,\n"
"          unsigned int size)\n"
"{\n"
"  float temp;\n"
"  for (int row = 0; row < size; ++row)\n"
"  {\n"
"    if (get_global_id(0) == 0)\n"
"      vector[row] /= matrix[row+row*row_length];\n"
"\n"
"    barrier(CLK_GLOBAL_MEM_FENCE);\n"
"\n"
"    temp = vector[row];\n"
"\n"
"    for  (int row_elim = row + get_global_id(0) + 1; row_elim < size; row_elim += get_global_size(0))\n"
"      vector[row_elim] -= temp * matrix[row*row_length+row_elim];\n"
"  }\n"
"};\n"
"\n"
; //matrix_align1_trans_lower_triangular_substitute_inplace

const char * const matrix_align1_rank1_update = 
"//perform a rank-1 update of the matrix, i.e. A += x * x^T\n"
"__kernel void rank1_update(\n"
"          __global float * matrix,\n"
"          __global const float * vector1,  \n"
"          __global const float * vector2,  \n"
"          unsigned int matrix_row_length,\n"
"          unsigned int row_length,\n"
"          unsigned int col_length) \n"
"{ \n"
"  float tmp;\n"
"  unsigned int offset;\n"
"\n"
"  for (unsigned int row = get_global_id(0); row < row_length; row += get_global_size(0))\n"
"  {\n"
"    tmp = vector1[row];\n"
"    offset = row*matrix_row_length;\n"
"    for (unsigned int col = 0; col < col_length; ++col)\n"
"      matrix[offset+col] += tmp * vector2[col];\n"
"  }\n"
"};\n"
; //matrix_align1_rank1_update

const char * const matrix_align1_lower_triangular_substitute_inplace = 
"__kernel void lower_triangular_substitute_inplace(\n"
"          __global const float * matrix,\n"
"          __global float * vector,\n"
"          unsigned int row_length,\n"
"          unsigned int size)\n"
"{\n"
"  float temp;\n"
"  for (int row = 0; row < size; ++row)\n"
"  {\n"
"    if (get_global_id(0) == 0)\n"
"      vector[row] /= matrix[row+row*row_length];\n"
"\n"
"    barrier(CLK_GLOBAL_MEM_FENCE);\n"
"\n"
"    temp = vector[row];\n"
"\n"
"    for  (int row_elim = row + get_global_id(0) + 1; row_elim < size; row_elim += get_global_size(0))\n"
"      vector[row_elim] -= temp * matrix[row_elim*row_length+row];\n"
"  }\n"
"};\n"
"\n"
; //matrix_align1_lower_triangular_substitute_inplace

const char * const matrix_align1_lu_factorize = 
"__kernel void lu_factorize(\n"
"          __global float * matrix,\n"
"          unsigned int matrix_row_length,\n"
"          unsigned int size) \n"
"{ \n"
"  float temp;\n"
"  unsigned rowi;\n"
"  unsigned rowk;\n"
"  for (unsigned int i=1; i<size; ++i)\n"
"  {\n"
"    rowi = i * matrix_row_length;\n"
"    for (unsigned int k=0; k<i; ++k)\n"
"    {\n"
"      rowk = k * matrix_row_length;\n"
"      if (get_global_id(0) == 0)\n"
"        matrix[rowi + k] /= matrix[rowk + k];\n"
"\n"
"      barrier(CLK_GLOBAL_MEM_FENCE);\n"
"      temp = matrix[rowi + k];\n"
"      \n"
"      //parallel subtraction:\n"
"      for (unsigned int j=k+1 + get_global_id(0); j<size; j += get_global_size(0))\n"
"        matrix[rowi + j] -= temp * matrix[rowk + j];\n"
"    }\n"
"  }\n"
"} \n"
"\n"
; //matrix_align1_lu_factorize

const char * const matrix_align1_trans_vec_mul = 
"__kernel void trans_vec_mul(\n"
"          __global const float * matrix,\n"
"          __global const float * vector,  \n"
"          __global float * result,\n"
"          unsigned int matrix_row_length, //keep transpose operation in mind!\n"
"          unsigned int vector_length, //keep transpose operation in mind!\n"
"          unsigned int result_length) \n"
"{ \n"
"  for (unsigned int row = get_global_id(0); row < result_length; row += get_global_size(0))\n"
"  {\n"
"    float dot_prod2 = 0.0f;\n"
"    for (unsigned int col = 0; col < vector_length; ++col)\n"
"      dot_prod2 += matrix[row + col*matrix_row_length] * vector[col];\n"
"    result[row] = dot_prod2;\n"
"  }\n"
"};\n"
"\n"
; //matrix_align1_trans_vec_mul

const char * const matrix_align1_scaled_rank1_update = 
"__kernel void scaled_rank1_update(\n"
"          __global float * matrix,\n"
"          float val,\n"
"          __global const float * vector1,  \n"
"          __global const float * vector2,  \n"
"          unsigned int matrix_row_length,\n"
"          unsigned int row_length,\n"
"          unsigned int col_length) \n"
"{ \n"
"  float tmp;\n"
"  unsigned int offset;\n"
"\n"
"  for (unsigned int row = get_global_id(0); row < row_length; row += get_global_size(0))\n"
"  {\n"
"    tmp = val * vector1[row];\n"
"    offset = row*matrix_row_length;\n"
"    for (unsigned int col = 0; col < col_length; ++col)\n"
"      matrix[offset+col] += tmp * vector2[col];\n"
"  }\n"
"};\n"
"\n"
; //matrix_align1_scaled_rank1_update

const char * const matrix_align1_vec_mul = 
"__kernel void vec_mul(\n"
"          __global const float * matrix,\n"
"          __global const float * vector,  \n"
"          __global float * result,\n"
"          unsigned int matrix_row_length, //keep transpose operation in mind!\n"
"          unsigned int vector_length,\n"
"          unsigned int result_length) \n"
"{ \n"
"  for (unsigned int row = get_global_id(0); row < result_length; row += get_global_size(0))\n"
"  {\n"
"    float dot_prod = 0.0f;\n"
"    for (unsigned int col = 0; col < vector_length; ++col)\n"
"      dot_prod += matrix[row*matrix_row_length+col] * vector[col];\n"
"    result[row] = dot_prod;\n"
"  }\n"
"};\n"
"\n"
; //matrix_align1_vec_mul

const char * const matrix_align1_unit_upper_triangular_substitute_inplace = 
"__kernel void unit_upper_triangular_substitute_inplace( \n"
"          __global const float * matrix, \n"
"          __global float * vector, \n"
"          unsigned int row_length, \n"
"          unsigned int size) \n"
"{ \n"
"  float temp; \n"
"  for (int row = size-1; row > -1; --row) \n"
"  { \n"
"    barrier(CLK_GLOBAL_MEM_FENCE); \n"
"    temp = vector[row]; \n"
"    //eliminate column with index 'row' in parallel: \n"
"    for  (int row_elim = get_global_id(0); row_elim < row; row_elim += get_global_size(0)) \n"
"      vector[row_elim] -= temp * matrix[row_elim*row_length+row]; \n"
"  } \n"
"   \n"
"}; \n"
; //matrix_align1_unit_upper_triangular_substitute_inplace

const char * const matrix_align1_unit_lower_triangular_substitute_inplace = 
"__kernel void unit_lower_triangular_substitute_inplace(\n"
"          __global const float * matrix,\n"
"          __global float * vector,\n"
"          unsigned int row_length,\n"
"          unsigned int size)\n"
"{\n"
"  float temp;\n"
"  for (int row = 0; row < size; ++row)\n"
"  {\n"
"    barrier(CLK_GLOBAL_MEM_FENCE);\n"
"    temp = vector[row];\n"
"\n"
"    for  (int row_elim = row + get_global_id(0) + 1; row_elim < size; row_elim += get_global_size(0))\n"
"      vector[row_elim] -= temp * matrix[row_elim*row_length+row];\n"
"  }\n"
"};\n"
"\n"
; //matrix_align1_unit_lower_triangular_substitute_inplace

const char * const matrix_align1_trans_upper_triangular_substitute_inplace = 
"//transposed lower triangular matrix\n"
"__kernel void trans_upper_triangular_substitute_inplace(\n"
"          __global const float * matrix,\n"
"          __global float * vector,\n"
"          unsigned int row_length,\n"
"          unsigned int size)\n"
"{\n"
"  float temp;\n"
"  for (int row = size-1; row > -1; --row)\n"
"  {\n"
"    if (get_global_id(0) == 0)\n"
"      vector[row] /= matrix[row+row*row_length];\n"
"\n"
"    barrier(CLK_GLOBAL_MEM_FENCE);\n"
"\n"
"    temp = vector[row];\n"
"\n"
"    for  (int row_elim = get_global_id(0); row_elim < row; row_elim += get_global_size(0))\n"
"      vector[row_elim] -= temp * matrix[row*row_length+row_elim];\n"
"  }\n"
"};\n"
"\n"
; //matrix_align1_trans_upper_triangular_substitute_inplace

const char * const matrix_align1_upper_triangular_substitute_inplace = 
"__kernel void upper_triangular_substitute_inplace( \n"
"          __global const float * matrix, \n"
"          __global float * vector, \n"
"          unsigned int row_length, \n"
"          unsigned int size) \n"
"{ \n"
"  float temp; \n"
"  for (int row = size-1; row > -1; --row) \n"
"  { \n"
"    barrier(CLK_GLOBAL_MEM_FENCE); \n"
"    if (get_global_id(0) == 0) \n"
"      vector[row] /= matrix[row*row_length+row]; \n"
" \n"
"    barrier(CLK_GLOBAL_MEM_FENCE); \n"
"    temp = vector[row]; \n"
"    //eliminate column with index 'row' in parallel: \n"
"    for  (int row_elim = get_global_id(0); row_elim < row; row_elim += get_global_size(0)) \n"
"      vector[row_elim] -= temp * matrix[row_elim*row_length+row]; \n"
"  } \n"
"   \n"
"}; \n"
; //matrix_align1_upper_triangular_substitute_inplace

  }  //namespace kernels
 }  //namespace linalg
}  //namespace viennacl
#endif

#ifndef _VIENNACL_COORDINATE_MATRIX_SOURCE_HPP_
#define _VIENNACL_COORDINATE_MATRIX_SOURCE_HPP_
//Automatically generated file from aux-directory, do not edit manually!
namespace viennacl
{
 namespace linalg
 {
  namespace kernels
  {
const char * const coordinate_matrix_align1_vec_mul = 
"//segmented parallel reduction. At present restricted to up to 256 threads\n"
"void segmented_parallel_reduction(unsigned int row, \n"
"                                  float val, \n"
"                                  __local unsigned int * shared_rows, \n"
"                                  __local float * inter_results) \n"
"{ \n"
"  barrier(CLK_LOCAL_MEM_FENCE); \n"
"  shared_rows[get_local_id(0)] = row; \n"
"  inter_results[get_local_id(0)] = val; \n"
" \n"
"  barrier(CLK_LOCAL_MEM_FENCE); \n"
"  if( get_local_id(0) >=  1 && row == shared_rows[get_local_id(0) -  1] ) { inter_results[get_local_id(0)] += inter_results[get_local_id(0) -  1]; }  \n"
"  barrier(CLK_LOCAL_MEM_FENCE); \n"
"  if( get_local_id(0) >=  2 && row == shared_rows[get_local_id(0) -  2] ) { inter_results[get_local_id(0)] += inter_results[get_local_id(0) -  2]; } \n"
"  barrier(CLK_LOCAL_MEM_FENCE); \n"
"  if( get_local_id(0) >=  4 && row == shared_rows[get_local_id(0) -  4] ) { inter_results[get_local_id(0)] += inter_results[get_local_id(0) -  4]; } \n"
"  barrier(CLK_LOCAL_MEM_FENCE); \n"
"  if( get_local_id(0) >=  8 && row == shared_rows[get_local_id(0) -  8] ) { inter_results[get_local_id(0)] += inter_results[get_local_id(0) -  8]; } \n"
"  barrier(CLK_LOCAL_MEM_FENCE); \n"
"  if( get_local_id(0) >= 16 && row == shared_rows[get_local_id(0) - 16] ) { inter_results[get_local_id(0)] += inter_results[get_local_id(0) - 16]; } \n"
"  barrier(CLK_LOCAL_MEM_FENCE); \n"
"  if( get_local_id(0) >= 32 && row == shared_rows[get_local_id(0) - 32] ) { inter_results[get_local_id(0)] += inter_results[get_local_id(0) - 32]; } \n"
"  barrier(CLK_LOCAL_MEM_FENCE); \n"
"  if( get_local_id(0) >= 64 && row == shared_rows[get_local_id(0) - 64] ) { inter_results[get_local_id(0)] += inter_results[get_local_id(0) - 64]; } \n"
"  barrier(CLK_LOCAL_MEM_FENCE); \n"
"  if( get_local_id(0) >= 128 && row == shared_rows[get_local_id(0) - 128] ) { inter_results[get_local_id(0)] += inter_results[get_local_id(0) - 128]; } \n"
"  barrier(CLK_LOCAL_MEM_FENCE); \n"
"  //if( get_local_id(0) >= 256 && row == shared_rows[get_local_id(0) - 256] ) { inter_results[get_local_id(0)] += inter_results[get_local_id(0) - 256]; } \n"
"  //barrier(CLK_LOCAL_MEM_FENCE); \n"
" \n"
"}\n"
"void impl_vec_mul( \n"
"          __global const uint2 * coords, //(row_index, column_index) \n"
"          __global const float * elements, \n"
"          __global const float * vector,  \n"
"          __global float * result, \n"
"          unsigned int size, \n"
"          __local unsigned int * shared_rows, \n"
"          __local float * inter_results) \n"
"{\n"
"  uint2 tmp; \n"
"  float val; \n"
"  const uint last_index = get_local_size(0) - 1; \n"
"  shared_rows[get_local_id(0)] = 0; \n"
"  inter_results[get_local_id(0)] = 0.0f; \n"
"  unsigned int for_size = (size - 1) / get_local_size(0); \n"
"  \n"
"  for (unsigned int k = 0; k <= for_size; ++k)\n"
"  { \n"
"    unsigned int index = k * get_local_size(0) + get_local_id(0); \n"
"    barrier(CLK_GLOBAL_MEM_FENCE);\n"
"  \n"
"    if (index < size)\n"
"    {\n"
"      tmp = coords[index]; \n"
"      val = elements[index] * vector[tmp.y]; \n"
"      \n"
"      if (get_local_id(0) == 0) \n"
"      { \n"
"        //check for carry from previous loop run: \n"
"        if (tmp.x == shared_rows[last_index]) \n"
"          val += inter_results[last_index]; \n"
"        else \n"
"          result[shared_rows[last_index]] += inter_results[last_index]; \n"
"      } \n"
"      segmented_parallel_reduction(tmp.x, val, shared_rows, inter_results); \n"
"    }\n"
"    else\n"
"      segmented_parallel_reduction(0, 0, shared_rows, inter_results); //all threads have to enter this function\n"
"     \n"
"    barrier(CLK_GLOBAL_MEM_FENCE);\n"
"  \n"
"    if (get_local_id(0) != last_index &&\n"
"         shared_rows[get_local_id(0)] != shared_rows[get_local_id(0) + 1] &&\n"
"         inter_results[get_local_id(0)] != 0) \n"
"    { \n"
"      result[tmp.x] += inter_results[get_local_id(0)]; \n"
"    }\n"
"  } //for \n"
"   \n"
"  barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE); \n"
"   \n"
"  if (get_local_id(0) == last_index && inter_results[get_local_id(0)] != 0) \n"
"    result[shared_rows[get_local_id(0)]] += inter_results[get_local_id(0)]; \n"
"}\n"
"__kernel void vec_mul( \n"
"          __global const uint2 * coords, //(row_index, column_index) \n"
"          __global const float * elements, \n"
"          __global const float * vector,  \n"
"          __global float * result, \n"
"          unsigned int size, \n"
"          __local unsigned int * shared_rows, \n"
"          __local float * inter_results) \n"
"{ \n"
"  \n"
"  __global const uint2 * group_coords_start   = coords   + (size * get_group_id(0))       / get_num_groups(0);\n"
"  __global const uint2 * group_coords_end     = coords   + (size * (get_group_id(0) + 1)) / get_num_groups(0);\n"
"  __global const float * group_elements_start = elements + (size * get_group_id(0))       / get_num_groups(0);\n"
"  unsigned int group_size = (size * (get_group_id(0) + 1)) / get_num_groups(0) - (size * get_group_id(0)) / get_num_groups(0);\n"
"  \n"
"  //find suitable start:\n"
"  uint2 tmp;\n"
"  if (group_coords_start != coords) //first pointer stays at start, others search for start of next row\n"
"  {\n"
"    tmp = *group_coords_start;\n"
"    while ( (*group_coords_start).x == tmp.x && \n"
"            (group_coords_start != group_coords_end) )\n"
"    {\n"
"      ++group_coords_start;\n"
"      ++group_elements_start;\n"
"      --group_size;\n"
"    }\n"
"  }\n"
"  //if the row index does not change within the group, then group is inactive.\n"
"  \n"
"  \n"
"  //find suitable end for remaining active groups:\n"
"  if (group_coords_start != group_coords_end)\n"
"  {\n"
"    if (group_coords_end != coords + size)   //do not increment or dereference beyond available array length\n"
"    {\n"
"      tmp = *group_coords_end;\n"
"      while ( (*group_coords_end).x == tmp.x && \n"
"              (group_coords_end != coords + size) )\n"
"      {\n"
"        ++group_coords_end;\n"
"        ++group_size;\n"
"      }\n"
"    }\n"
"    //run workers:\n"
"    impl_vec_mul( group_coords_start,    //coords pointer\n"
"                  group_elements_start,  //elements pointer\n"
"                  vector,    //vector pointer\n"
"                  result,    //result pointer\n"
"                  group_size,  //size of group (unsigned int)\n"
"                  shared_rows, //local row buffer\n"
"                  inter_results); //local result buffer\n"
"  }\n"
"}\n"
; //coordinate_matrix_align1_vec_mul

  }  //namespace kernels
 }  //namespace linalg
}  //namespace viennacl
#endif

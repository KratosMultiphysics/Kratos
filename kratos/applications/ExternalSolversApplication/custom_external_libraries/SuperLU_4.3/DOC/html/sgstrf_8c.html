<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>SuperLU: SRC/sgstrf.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SRC/sgstrf.c File Reference</h1>Computes an LU factorization of a general sparse matrix. <a href="#_details">More...</a>
<p>
<code>#include &quot;<a class="el" href="slu__sdefs_8h-source.html">slu_sdefs.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sgstrf_8c.html#2428d5d7ef46cf9a08069d9f55901284">sgstrf</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *options, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *<a class="el" href="ilu__zdrop__row_8c.html#c900805a486cbb8489e3c176ed6e0d8e">A</a>, int relax, int panel_size, int *etree, void *work, int lwork, int *perm_c, int *perm_r, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *L, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *U, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *stat, int *info)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<pre>
 -- SuperLU routine (version 3.0) --
 Univ. of California Berkeley, Xerox Palo Alto Research Center,
 and Lawrence Berkeley National Lab.
 October 15, 2003</pre><p>
<pre> Copyright (c) 1994 by Xerox Corporation.  All rights reserved.</pre><p>
<pre> THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
 EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.</pre><p>
<pre> Permission is hereby granted to use or copy this program for any
 purpose, provided the above notices are retained on all copies.
 Permission to modify the code and to distribute modified code is
 granted, provided the above notices are retained, and a notice that
 the code was modified is included with the above copyright notice.
 </pre> <hr><h2>Function Documentation</h2>
<a class="anchor" name="2428d5d7ef46cf9a08069d9f55901284"></a><!-- doxytag: member="sgstrf.c::sgstrf" ref="2428d5d7ef46cf9a08069d9f55901284" args="(superlu_options_t *options, SuperMatrix *A, int relax, int panel_size, int *etree, void *work, int lwork, int *perm_c, int *perm_r, SuperMatrix *L, SuperMatrix *U, SuperLUStat_t *stat, int *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgstrf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>relax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>etree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> SGSTRF computes an LU factorization of a general sparse m-by-n
 matrix A using partial pivoting with row interchanges.
 The factorization has the form
     Pr * A = L * U
 where Pr is a row permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if A-&gt;nrow &gt; A-&gt;ncol), and U is upper 
 triangular (upper trapezoidal if A-&gt;nrow &lt; A-&gt;ncol).</pre><p>
<pre> See <a class="el" href="supermatrix_8h.html" title="Defines matrix types.">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> options (input) superlu_options_t*
         The structure defines the input parameters to control
         how the LU decomposition will be performed.</pre><p>
<pre> A        (input) SuperMatrix*
	    Original matrix A, permuted by columns, of dimension
          (A-&gt;nrow, A-&gt;ncol). The type of A can be:
          Stype = SLU_NCP; Dtype = SLU_S; Mtype = SLU_GE.</pre><p>
<pre> relax    (input) int
          To control degree of relaxing supernodes. If the number
          of nodes (columns) in a subtree of the elimination tree is less
          than relax, this subtree is considered as one supernode,
          regardless of the row structures of those columns.</pre><p>
<pre> panel_size (input) int
          A panel consists of at most panel_size consecutive columns.</pre><p>
<pre> etree    (input) int*, dimension (A-&gt;ncol)
          Elimination tree of A'*A.
          Note: etree is a vector of parent pointers for a forest whose
          vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.
          On input, the columns of A should be permuted so that the
          etree is in a certain postorder.</pre><p>
<pre> work     (input/output) void*, size (lwork) (in bytes)
          User-supplied work space and space for the output data structures.
          Not referenced if lwork = 0;</pre><p>
<pre> lwork   (input) int
         Specifies the size of work array in bytes.
         = 0:  allocate space internally by system malloc;
         &gt; 0:  use user-supplied work array of length lwork in bytes,
               returns error if space runs out.
         = -1: the routine guesses the amount of space needed without
               performing the factorization, and returns it in
               *info; no other side effects.</pre><p>
<pre> perm_c   (input) int*, dimension (A-&gt;ncol)
	    Column permutation vector, which defines the 
          permutation matrix Pc; perm_c[i] = j means column i of A is 
          in position j in A*Pc.
          When searching for diagonal, perm_c[*] is applied to the
          row subscripts of A, so that diagonal threshold pivoting
          can find the diagonal of A, rather than that of A*Pc.</pre><p>
<pre> perm_r   (input/output) int*, dimension (A-&gt;nrow)
          Row permutation vector which defines the permutation matrix Pr,
          perm_r[i] = j means row i of A is in position j in Pr*A.
          If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
             will try to use the input perm_r, unless a certain threshold
             criterion is violated. In that case, perm_r is overwritten by
             a new permutation determined by partial pivoting or diagonal
             threshold pivoting.
          Otherwise, perm_r is output argument;</pre><p>
<pre> L        (output) SuperMatrix*
          The factor L from the factorization Pr*A=L*U; use compressed row 
          subscripts storage for supernodes, i.e., L has type: 
          Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><p>
<pre> U        (output) SuperMatrix*
	    The factor U from the factorization Pr*A*Pc=L*U. Use column-wise
          storage scheme, i.e., U has types: Stype = SLU_NC, 
          Dtype = SLU_S, Mtype = SLU_TRU.</pre><p>
<pre> stat     (output) SuperLUStat_t*
          Record the statistics on runtime and floating-point operation count.
          See <a class="el" href="slu__util_8h.html" title="Utility header file.">slu_util.h</a> for the definition of 'SuperLUStat_t'.</pre><p>
<pre> info     (output) int*
          = 0: successful exit
          &lt; 0: if info = -i, the i-th argument had an illegal value
          &gt; 0: if info = i, and i is
             &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
                been completed, but the factor U is exactly singular,
                and division by zero will occur if it is used to solve a
                system of equations.
             &gt; A-&gt;ncol: number of bytes allocated when memory allocation
                failure occurred, plus A-&gt;ncol. If lwork = -1, it is
                the estimated amount of space needed, plus A-&gt;ncol.</pre><p>
<pre> ======================================================================</pre><p>
<pre> Local Working Arrays: 
 ======================
   m = number of rows in the matrix
   n = number of columns in the matrix</pre><p>
<pre>   xprune[0:n-1]: xprune[*] points to locations in subscript 
	vector lsub[*]. For column i, xprune[i] denotes the point where 
	structural pruning begins. I.e. only xlsub[i],..,xprune[i]-1 need 
	to be traversed for symbolic factorization.</pre><p>
<pre>   marker[0:3*m-1]: marker[i] = j means that node i has been 
	reached when working on column j.
	Storage: relative to original row subscripts
	NOTE: There are 3 of them: marker/marker1 are used for panel dfs, 
	      see <a class="el" href="spanel__dfs_8c.html" title="Peforms a symbolic factorization on a panel of symbols.">spanel_dfs.c</a>; marker2 is used for inner-factorization,
            see <a class="el" href="scolumn__dfs_8c.html" title="Performs a symbolic factorization.">scolumn_dfs.c</a>.</pre><p>
<pre>   parent[0:m-1]: parent vector used during dfs
      Storage: relative to new row subscripts</pre><p>
<pre>   xplore[0:m-1]: xplore[i] gives the location of the next (dfs) 
	unexplored neighbor of i in lsub[*]</pre><p>
<pre>   segrep[0:nseg-1]: contains the list of supernodal representatives
	in topological order of the dfs. A supernode representative is the 
	last column of a supernode.
      The maximum size of segrep[] is n.</pre><p>
<pre>   repfnz[0:W*m-1]: for a nonzero segment U[*,j] that ends at a 
	supernodal representative r, repfnz[r] is the location of the first 
	nonzero in this segment.  It is also used during the dfs: repfnz[r]&gt;0
	indicates the supernode r has been explored.
	NOTE: There are W of them, each used for one column of a panel.</pre><p>
<pre>   panel_lsub[0:W*m-1]: temporary for the nonzeros row indices below 
      the panel diagonal. These are filled in during <a class="el" href="slu__sdefs_8h.html#77baf210393e04fa71d4e73b5e60e556">spanel_dfs()</a>, and are
      used later in the inner LU factorization within the panel.
	panel_lsub[]/dense[] pair forms the SPA data structure.
	NOTE: There are W of them.</pre><p>
<pre>   dense[0:W*m-1]: sparse accumulating (SPA) vector for intermediate values;
	    	   NOTE: there are W of them.</pre><p>
<pre>   tempv[0:*]: real temporary used for dense numeric kernels;
	The size of this array is defined by <a class="el" href="slu__util_8h.html#06193b28f40a4779ae7737711642eb45">NUM_TEMPV()</a> in <a class="el" href="slu__sdefs_8h.html" title="Header file for real operations.">slu_sdefs.h</a>.
 </pre> 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 25 13:43:49 2011 for SuperLU by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>

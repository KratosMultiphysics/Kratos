<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>SuperLU: SRC/slu_cdefs.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SRC/slu_cdefs.h File Reference</h1>Header file for real operations. <a href="#_details">More...</a>
<p>
<code>#include &lt;math.h&gt;</code><br>
<code>#include &lt;limits.h&gt;</code><br>
<code>#include &quot;<a class="el" href="slu__Cnames_8h-source.html">slu_Cnames.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="supermatrix_8h-source.html">supermatrix.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="slu__util_8h-source.html">slu_util.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="slu__scomplex_8h-source.html">slu_scomplex.h</a>&quot;</code><br>

<p>
<a href="slu__cdefs_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#b6fd6105e64ed14a0c9281326f05e623">int_t</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#58aff6521bb64732e981ce5779820a89">cgssv</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Driver routines.  <a href="#58aff6521bb64732e981ce5779820a89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#264b6681cc04244cdd116978acfe4e2a">cgssvx</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, int *, char *, float *, float *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, void *, int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, float *, float *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#908282efea752470dcd38f794b435dbc">cgsisv</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#35048de8a07c47ab61c15793f63ad398">cgsisx</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, int *, char *, float *, float *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, void *, int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#4f54bdbff678075fdf06720bbb299346">cCreate_CompCol_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int, <a class="el" href="structcomplex.html">complex</a> *, int *, int *, <a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supernodal LU factor related.  <a href="#4f54bdbff678075fdf06720bbb299346"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#866240e7f5a35e821bc898d2e5ba26fc">cCreate_CompRow_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int, <a class="el" href="structcomplex.html">complex</a> *, int *, int *, <a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#2b7edfb65023104b0f88f5aaab393248">cCopy_CompCol_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy matrix A into matrix B.  <a href="#2b7edfb65023104b0f88f5aaab393248"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#9af123cab0520e5800a1b60668a09de6">cCreate_Dense_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, <a class="el" href="structcomplex.html">complex</a> *, int, <a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#63d7d14c6a2312b9f95844e5055deae9">cCreate_SuperNode_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int, <a class="el" href="structcomplex.html">complex</a> *, int *, int *, int *, int *, int *, <a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#7378a64fc445fa7e0101059d7353f4ac">cCopy_Dense_Matrix</a> (int, int, <a class="el" href="structcomplex.html">complex</a> *, int, <a class="el" href="structcomplex.html">complex</a> *, int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#8086902aa8be3fc7d04c3c82ec3a79dc">countnz</a> (const int, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the total number of nonzeros in factors L and U, and in the symmetrically reduced L.  <a href="#8086902aa8be3fc7d04c3c82ec3a79dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#ae8eb367a0a2fcdf734738bc9630df85">ilu_countnz</a> (const int, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the total number of nonzeros in factors L and U.  <a href="#ae8eb367a0a2fcdf734738bc9630df85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#7061332d759d7e4d73c1b2e5cb0bf2bf">fixupL</a> (const int, const int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fix up the data storage lsub for L-subscripts. It removes the subscript sets for structural pruning, and applies permuation to the remaining subscripts.  <a href="#7061332d759d7e4d73c1b2e5cb0bf2bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#22ec97af17a44cd9aae6aeae3de50e87">callocateA</a> (int, int, <a class="el" href="structcomplex.html">complex</a> **, int **, int **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate storage for original matrix A.  <a href="#22ec97af17a44cd9aae6aeae3de50e87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#1743ff4c80f33a0ae166a61a691c348a">cgstrf</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int *, void *, int, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#c98da7d6b5809dadb1cae9bc019619ce">csnode_dfs</a> (const int, const int, const int *, const int *, const int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#ab1987caf36c8eedcf605b59e56a9d5d">csnode_bmod</a> (const int, const int, const int, <a class="el" href="structcomplex.html">complex</a> *, <a class="el" href="structcomplex.html">complex</a> *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numeric block updates within the relaxed snode.  <a href="#ab1987caf36c8eedcf605b59e56a9d5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#780968651deed587e187bd7661edbb20">cpanel_dfs</a> (const int, const int, const int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, <a class="el" href="structcomplex.html">complex</a> *, int *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#c37d9a28b8745daf72ae1d5ad29c140d">cpanel_bmod</a> (const int, const int, const int, const int, <a class="el" href="structcomplex.html">complex</a> *, <a class="el" href="structcomplex.html">complex</a> *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#6aace79c0009c9a5a32219753f51b695">ccolumn_dfs</a> (const int, const int, int *, int *, int *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#19d15802e430420a5512a8e9bbe42d64">ccolumn_bmod</a> (const int, const int, <a class="el" href="structcomplex.html">complex</a> *, <a class="el" href="structcomplex.html">complex</a> *, int *, int *, int, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#247f30177d193339d293899fe702afe6">ccopy_to_ucol</a> (int, int, int *, int *, int *, <a class="el" href="structcomplex.html">complex</a> *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#4a31e35e95f28f69549ffa45bebd4499">cpivotL</a> (const int, const double, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#65d7df9e58c2415f455dbe6db9a99f2b">cpruneL</a> (const int, const int *, const int, const int, const int *, const int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#88701835280a367a90b9ea2a73f946f0">creadmt</a> (int *, int *, int *, <a class="el" href="structcomplex.html">complex</a> **, int **, int **)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#7f454dd3045fdd51e8bf0d29c7561fe5">cGenXtrue</a> (int, int, <a class="el" href="structcomplex.html">complex</a> *, int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#afc07318b1802f00402e7d8afbeaaeae">cFillRHS</a> (<a class="el" href="superlu__enum__consts_8h.html#0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>, int, <a class="el" href="structcomplex.html">complex</a> *, int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Let rhs[i] = sum of i-th row of A, so the solution vector is all 1's.  <a href="#afc07318b1802f00402e7d8afbeaaeae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#a45033d577ad2afbe488a837d6aba8cf">cgstrs</a> (<a class="el" href="superlu__enum__consts_8h.html#0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#82dc99bce4d9b50c3534eb424d03182b">cgsitrf</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int *, void *, int, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#c7a85f8c55c71b4f4d454c4d62ffbfae">cldperm</a> (int, int, int, int[], int[], <a class="el" href="structcomplex.html">complex</a>[], int[], float[], float[])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#c4e46d9d75c94503e94b4599960479d7">ilu_csnode_dfs</a> (const int, const int, const int *, const int *, const int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#9f427fadf45d56409840775c99ce8967">ilu_cpanel_dfs</a> (const int, const int, const int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, <a class="el" href="structcomplex.html">complex</a> *, float *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#94b01af5a7e93ca2cc3cf52717e767a0">ilu_ccolumn_dfs</a> (const int, const int, int *, int *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#a9bf5072c6b1c6803b1dba973ac4be3e">ilu_ccopy_to_ucol</a> (int, int, int *, int *, int *, <a class="el" href="structcomplex.html">complex</a> *, int, <a class="el" href="superlu__enum__consts_8h.html#0cb73c13a7c2390c3a9a0a8913477ff0">milu_t</a>, double, int, <a class="el" href="structcomplex.html">complex</a> *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, float *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#c4edc9f45dad6dd53caca13240690633">ilu_cpivotL</a> (const int, const double, int *, int *, int, int *, int *, int *, int *, double, <a class="el" href="superlu__enum__consts_8h.html#0cb73c13a7c2390c3a9a0a8913477ff0">milu_t</a>, <a class="el" href="structcomplex.html">complex</a>, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#cf639d4fcc71c90f3e966b47787ad834">ilu_cdrop_row</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, int, int, double, int, int *, double *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, float *, float *, int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#d34b27648bc5b43d1ad19dd017f8273f">cgsequ</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, float *, float *, float *, int *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Driver related.  <a href="#d34b27648bc5b43d1ad19dd017f8273f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#dbc57dc56d0c962aa148a573895883b0">claqgs</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, float, float, float, char *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#2ca330446884f122ee31f4f2b5243abe">cgscon</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float, float *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#9a5b1cc4e96708825cc21108ebbeb061">cPivotGrowth</a> (int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#64715c1d0510eaf5f8e37f2465e9e8d6">cgsrfs</a> (<a class="el" href="superlu__enum__consts_8h.html#0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, char *, float *, float *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#8299a994a223b7178314fe7faff74508">sp_ctrsv</a> (char *, char *, char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structcomplex.html">complex</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves one of the systems of equations A*x = b, or A'*x = b.  <a href="#8299a994a223b7178314fe7faff74508"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#59e320a29e9ded59a46e8d64619ffac6">sp_cgemv</a> (char *, <a class="el" href="structcomplex.html">complex</a>, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structcomplex.html">complex</a> *, int, <a class="el" href="structcomplex.html">complex</a>, <a class="el" href="structcomplex.html">complex</a> *, int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one of the matrix-vector operations y := alpha*A*x + beta*y, or y := alpha*A'*x + beta*y.  <a href="#59e320a29e9ded59a46e8d64619ffac6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#0473a1696817ed02c501ca8af8ff0285">sp_cgemm</a> (char *, char *, int, int, int, <a class="el" href="structcomplex.html">complex</a>, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structcomplex.html">complex</a> *, int, <a class="el" href="structcomplex.html">complex</a>, <a class="el" href="structcomplex.html">complex</a> *, int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#47c1dd1b8332f4366d5c5112219fdb3a">slamch_</a> (char *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#0f124ea0294cce1fb4c467b1d63ac209">cLUMemInit</a> (<a class="el" href="superlu__enum__consts_8h.html#c785c8235480e5cfef9848d89c047c0a">fact_t</a>, void *, int, int, int, int, int, float, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, int **, <a class="el" href="structcomplex.html">complex</a> **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory-related.  <a href="#0f124ea0294cce1fb4c467b1d63ac209"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#f3bbcd362fb260a0dba5488a3e4ee926">cSetRWork</a> (int, int, <a class="el" href="structcomplex.html">complex</a> *, <a class="el" href="structcomplex.html">complex</a> **, <a class="el" href="structcomplex.html">complex</a> **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up pointers for real working arrays.  <a href="#f3bbcd362fb260a0dba5488a3e4ee926"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#a759583daf08db801cf6fe8018442d4c">cLUWorkFree</a> (int *, <a class="el" href="structcomplex.html">complex</a> *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the working storage used by factor routines.  <a href="#a759583daf08db801cf6fe8018442d4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#255ed62863700298939edfda48ae534a">cLUMemXpand</a> (int, int, <a class="el" href="superlu__enum__consts_8h.html#bd31f838aefffa46191d0d7dc36a96b2">MemType</a>, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expand the data structures for L and U during the factorization.  <a href="#255ed62863700298939edfda48ae534a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#db98fa14a907e0e848a35e896d4040db">complexMalloc</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#f558e3813415369a8805c473a7eaa5e8">complexCalloc</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#42361c3ce2ba81d149ffba01fbd6f138">floatMalloc</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#3e1230bff11a9e47c35555299bcdcf1b">floatCalloc</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#cea36c2598bb3f8a27b6985634d2b8e9">cmemory_usage</a> (const int, const int, const int, const int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#7ac9ff71eef6bf8c52c41eb9209a0caf">cQuerySpace</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#97e43257315ae194779ffe9c3dc9c213">ilu_cQuerySpace</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#34243c626347c973358d3d095802783b">creadhb</a> (int *, int *, int *, <a class="el" href="structcomplex.html">complex</a> **, int **, int **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auxiliary routines.  <a href="#34243c626347c973358d3d095802783b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#0cce050053c795f6b9c52174008bf775">creadrb</a> (int *, int *, int *, <a class="el" href="structcomplex.html">complex</a> **, int **, int **)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#7c84a33df79e533f6167e4a1e9ce89cb">creadtriple</a> (int *, int *, int *, <a class="el" href="structcomplex.html">complex</a> **, int **, int **)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#3891d961d41be3af94b755b27d371c1d">cCompRow_to_CompCol</a> (int, int, int, <a class="el" href="structcomplex.html">complex</a> *, int *, int *, <a class="el" href="structcomplex.html">complex</a> **, int **, int **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a row compressed storage into a column compressed storage.  <a href="#3891d961d41be3af94b755b27d371c1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#614eea417aeb37825463637f47c980ba">cfill</a> (<a class="el" href="structcomplex.html">complex</a> *, int, <a class="el" href="structcomplex.html">complex</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills a <a class="el" href="structcomplex.html">complex</a> precision array with a given value.  <a href="#614eea417aeb37825463637f47c980ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#293818022b119a511598f4766c54a1ee">cinf_norm_error</a> (int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structcomplex.html">complex</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the inf-norm of the error vector.  <a href="#293818022b119a511598f4766c54a1ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#7a41152a5800bc02bef17b56e070d0e6">PrintPerf</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *, <a class="el" href="structcomplex.html">complex</a>, <a class="el" href="structcomplex.html">complex</a>, <a class="el" href="structcomplex.html">complex</a> *, <a class="el" href="structcomplex.html">complex</a> *, char *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#98d44fe59660f87330b0172151a76141">sqselect</a> (int, float *, int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#f091472c1fb3c085c384bf52b3bebd8d">cPrint_CompCol_Matrix</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Routines for debugging.  <a href="#f091472c1fb3c085c384bf52b3bebd8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#8482f76b710a91d26250bca719b9d00c">cPrint_SuperNode_Matrix</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#1cbad8400b16c776b112f20b8645757d">cPrint_Dense_Matrix</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#4f43048c524cbdac07232ab635e67364">cprint_lu_col</a> (char *, int, int, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Diagnostic print of column "jcol" in the U/L factor.  <a href="#4f43048c524cbdac07232ab635e67364"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#ad0c06e9adc1e29a0ab2e78c38119bb4">print_double_vec</a> (char *, int, double *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__cdefs_8h.html#2cfc97393b65ddc5a40fdc523a50003a">check_tempv</a> (int, <a class="el" href="structcomplex.html">complex</a> *)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<pre> 
 -- SuperLU routine (version 4.1) --
 Univ. of California Berkeley, Xerox Palo Alto Research Center,
 and Lawrence Berkeley National Lab.
 November, 2010</pre><p>
<pre> Global data structures used in LU factorization -</pre><p>
<pre>   nsuper: supernodes = nsuper + 1, numbered [0, nsuper].
   (xsup,supno): supno[i] is the supernode no to which i belongs;
	xsup(s) points to the beginning of the s-th supernode.
	e.g.   supno 0 1 2 2 3 3 3 4 4 4 4 4   (n=12)
	        xsup 0 1 2 4 7 12
	Note: dfs will be performed on supernode rep. relative to the new 
	      row pivoting ordering</pre><p>
<pre>   (xlsub,lsub): lsub[*] contains the compressed subscript of
	rectangular supernodes; xlsub[j] points to the starting
	location of the j-th column in lsub[*]. Note that xlsub 
	is indexed by column.
	Storage: original row subscripts</pre><p>
<pre>      During the course of sparse LU factorization, we also use
	(xlsub,lsub) for the purpose of symmetric pruning. For each
	supernode {s,s+1,...,t=s+r} with first column s and last
	column t, the subscript set
		lsub[j], j=xlsub[s], .., xlsub[s+1]-1
	is the structure of column s (i.e. structure of this supernode).
	It is used for the storage of numerical values.
	Furthermore,
		lsub[j], j=xlsub[t], .., xlsub[t+1]-1
	is the structure of the last column t of this supernode.
	It is for the purpose of symmetric pruning. Therefore, the
	structural subscripts can be rearranged without making physical
	interchanges among the numerical values.</pre><p>
<pre>	However, if the supernode has only one column, then we
	only keep one set of subscripts. For any subscript interchange
	performed, similar interchange must be done on the numerical
	values.</pre><p>
<pre>	The last column structures (for pruning) will be removed
	after the numercial LU factorization phase.</pre><p>
<pre>   (xlusup,lusup): lusup[*] contains the numerical values of the
	rectangular supernodes; xlusup[j] points to the starting
	location of the j-th column in storage vector lusup[*]
	Note: xlusup is indexed by column.
	Each rectangular supernode is stored by column-major
	scheme, consistent with Fortran 2-dim array storage.</pre><p>
<pre>   (xusub,ucol,usub): ucol[*] stores the numerical values of
	U-columns outside the rectangular supernodes. The row
	subscript of nonzero ucol[k] is stored in usub[k].
	xusub[i] points to the starting location of column i in ucol.
	Storage: new row subscripts; that is subscripts of PA.
 </pre> <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="b6fd6105e64ed14a0c9281326f05e623"></a><!-- doxytag: member="slu_cdefs.h::int_t" ref="b6fd6105e64ed14a0c9281326f05e623" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="slu__zdefs_8h.html#b6fd6105e64ed14a0c9281326f05e623">int_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="22ec97af17a44cd9aae6aeae3de50e87"></a><!-- doxytag: member="slu_cdefs.h::callocateA" ref="22ec97af17a44cd9aae6aeae3de50e87" args="(int, int, complex **, int **, int **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void callocateA           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="19d15802e430420a5512a8e9bbe42d64"></a><!-- doxytag: member="slu_cdefs.h::ccolumn_bmod" ref="19d15802e430420a5512a8e9bbe42d64" args="(const int, const int, complex *, complex *, int *, int *, int, GlobalLU_t *, SuperLUStat_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccolumn_bmod           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname"> <em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname"> <em>tempv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fpanelc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose:
 ========
 Performs numeric block updates (sup-col) in topological order.
 It features: col-col, 2cols-col, 3cols-col, and sup-col updates.
 Special processing on the supernodal portion of L[*,j]
 Return value:   0 - successful return
               &gt; 0 - number of bytes allocated when run out of space
 </pre> 
</div>
</div><p>
<a class="anchor" name="6aace79c0009c9a5a32219753f51b695"></a><!-- doxytag: member="slu_cdefs.h::ccolumn_dfs" ref="6aace79c0009c9a5a32219753f51b695" args="(const int, const int, int *, int *, int *, int *, int *, int *, int *, int *, int *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccolumn_dfs           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>lsub_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Glu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======
   CCOLUMN_DFS performs a symbolic factorization on column jcol, and
   decide the supernode boundary.</pre><p>
<pre>   This routine does not use numeric values, but only use the RHS 
   row indices to start the dfs.</pre><p>
<pre>   A supernode representative is the last column of a supernode.
   The nonzeros in U[*,j] are segments that end at supernodal
   representatives. The routine returns a list of such supernodal 
   representatives in topological order of the dfs that generates them.
   The location of the first nonzero in each such supernodal segment
   (supernodal entry location) is also returned.</pre><p>
<pre> Local parameters
 ================
   nseg: no of segments in current U[*,j]
   jsuper: jsuper=EMPTY if column j does not belong to the same
	supernode as j-1. Otherwise, jsuper=nsuper.</pre><p>
<pre>   marker2: A-row --&gt; A-row/col (0/1)
   repfnz: SuperA-col --&gt; PA-row
   parent: SuperA-col --&gt; SuperA-col
   xplore: SuperA-col --&gt; index to L-structure</pre><p>
<pre> Return value
 ============
     0  success;
   &gt; 0  number of bytes allocated when run out of space.
 </pre> 
</div>
</div><p>
<a class="anchor" name="3891d961d41be3af94b755b27d371c1d"></a><!-- doxytag: member="slu_cdefs.h::cCompRow_to_CompCol" ref="3891d961d41be3af94b755b27d371c1d" args="(int, int, int, complex *, int *, int *, complex **, int **, int **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cCompRow_to_CompCol           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2b7edfb65023104b0f88f5aaab393248"></a><!-- doxytag: member="slu_cdefs.h::cCopy_CompCol_Matrix" ref="2b7edfb65023104b0f88f5aaab393248" args="(SuperMatrix *, SuperMatrix *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cCopy_CompCol_Matrix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7378a64fc445fa7e0101059d7353f4ac"></a><!-- doxytag: member="slu_cdefs.h::cCopy_Dense_Matrix" ref="7378a64fc445fa7e0101059d7353f4ac" args="(int, int, complex *, int, complex *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cCopy_Dense_Matrix           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Copies a two-dimensional matrix X to another matrix Y. 
</div>
</div><p>
<a class="anchor" name="247f30177d193339d293899fe702afe6"></a><!-- doxytag: member="slu_cdefs.h::ccopy_to_ucol" ref="247f30177d193339d293899fe702afe6" args="(int, int, int *, int *, int *, complex *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccopy_to_ucol           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4f54bdbff678075fdf06720bbb299346"></a><!-- doxytag: member="slu_cdefs.h::cCreate_CompCol_Matrix" ref="4f54bdbff678075fdf06720bbb299346" args="(SuperMatrix *, int, int, int, complex *, int *, int *, Stype_t, Dtype_t, Mtype_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cCreate_CompCol_Matrix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="866240e7f5a35e821bc898d2e5ba26fc"></a><!-- doxytag: member="slu_cdefs.h::cCreate_CompRow_Matrix" ref="866240e7f5a35e821bc898d2e5ba26fc" args="(SuperMatrix *, int, int, int, complex *, int *, int *, Stype_t, Dtype_t, Mtype_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cCreate_CompRow_Matrix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9af123cab0520e5800a1b60668a09de6"></a><!-- doxytag: member="slu_cdefs.h::cCreate_Dense_Matrix" ref="9af123cab0520e5800a1b60668a09de6" args="(SuperMatrix *, int, int, complex *, int, Stype_t, Dtype_t, Mtype_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cCreate_Dense_Matrix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="63d7d14c6a2312b9f95844e5055deae9"></a><!-- doxytag: member="slu_cdefs.h::cCreate_SuperNode_Matrix" ref="63d7d14c6a2312b9f95844e5055deae9" args="(SuperMatrix *, int, int, int, complex *, int *, int *, int *, int *, int *, Stype_t, Dtype_t, Mtype_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cCreate_SuperNode_Matrix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#5962adac634f3feebe487ad443802d60">Mtype_t</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="614eea417aeb37825463637f47c980ba"></a><!-- doxytag: member="slu_cdefs.h::cfill" ref="614eea417aeb37825463637f47c980ba" args="(complex *, int, complex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cfill           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="afc07318b1802f00402e7d8afbeaaeae"></a><!-- doxytag: member="slu_cdefs.h::cFillRHS" ref="afc07318b1802f00402e7d8afbeaaeae" args="(trans_t, int, complex *, int, SuperMatrix *, SuperMatrix *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cFillRHS           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7f454dd3045fdd51e8bf0d29c7561fe5"></a><!-- doxytag: member="slu_cdefs.h::cGenXtrue" ref="7f454dd3045fdd51e8bf0d29c7561fe5" args="(int, int, complex *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cGenXtrue           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2ca330446884f122ee31f4f2b5243abe"></a><!-- doxytag: member="slu_cdefs.h::cgscon" ref="2ca330446884f122ee31f4f2b5243abe" args="(char *, SuperMatrix *, SuperMatrix *, float, float *, SuperLUStat_t *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgscon           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>anorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
   Purpose   
   =======</pre><p>
<pre>   CGSCON estimates the reciprocal of the condition number of a general 
   real matrix A, in either the 1-norm or the infinity-norm, using   
   the LU factorization computed by CGETRF.   *</pre><p>
<pre>   An estimate is obtained for norm(inv(A)), and the reciprocal of the   
   condition number is computed as   
      RCOND = 1 / ( norm(A) * norm(inv(A)) ).</pre><p>
<pre>   See <a class="el" href="supermatrix_8h.html" title="Defines matrix types.">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre>   Arguments   
   =========</pre><p>
<pre>    NORM    (input) char*
            Specifies whether the 1-norm condition number or the   
            infinity-norm condition number is required:   
            = '1' or 'O':  1-norm;   
            = 'I':         Infinity-norm.</pre><p>
<pre>    L       (input) SuperMatrix*
            The factor L from the factorization Pr*A*Pc=L*U as computed by
            <a class="el" href="cgstrf_8c.html#9c9f2ce12946612c7426a10352ac5984">cgstrf()</a>. Use compressed row subscripts storage for supernodes,
            i.e., L has types: Stype = SLU_SC, Dtype = SLU_C, Mtype = SLU_TRLU.</pre><p>
<pre>    U       (input) SuperMatrix*
            The factor U from the factorization Pr*A*Pc=L*U as computed by
            <a class="el" href="cgstrf_8c.html#9c9f2ce12946612c7426a10352ac5984">cgstrf()</a>. Use column-wise storage scheme, i.e., U has types:
            Stype = SLU_NC, Dtype = SLU_C, Mtype = SLU_TRU.</pre><p>
<pre>    ANORM   (input) float
            If NORM = '1' or 'O', the 1-norm of the original matrix A.   
            If NORM = 'I', the infinity-norm of the original matrix A.</pre><p>
<pre>    RCOND   (output) float*
           The reciprocal of the condition number of the matrix A,   
           computed as RCOND = 1/(norm(A) * norm(inv(A))).</pre><p>
<pre>    INFO    (output) int*
           = 0:  successful exit   
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value</pre><p>
<pre>    ===================================================================== 
 </pre> 
</div>
</div><p>
<a class="anchor" name="d34b27648bc5b43d1ad19dd017f8273f"></a><!-- doxytag: member="slu_cdefs.h::cgsequ" ref="d34b27648bc5b43d1ad19dd017f8273f" args="(SuperMatrix *, float *, float *, float *, float *, float *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgsequ           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>rowcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>colcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose   
   =======</pre><p>
<pre>   CGSEQU computes row and column scalings intended to equilibrate an   
   M-by-N sparse matrix A and reduce its condition number. R returns the row
   scale factors and C the column scale factors, chosen to try to make   
   the largest element in each row and column of the matrix B with   
   elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.</pre><p>
<pre>   R(i) and C(j) are restricted to be between SMLNUM = smallest safe   
   number and BIGNUM = largest safe number.  Use of these scaling   
   factors is not guaranteed to reduce the condition number of A but   
   works well in practice.</pre><p>
<pre>   See <a class="el" href="supermatrix_8h.html" title="Defines matrix types.">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre>   Arguments   
   =========</pre><p>
<pre>   A       (input) SuperMatrix*
           The matrix of dimension (A-&gt;nrow, A-&gt;ncol) whose equilibration
           factors are to be computed. The type of A can be:
           Stype = SLU_NC; Dtype = SLU_C; Mtype = SLU_GE.</pre><p>
<pre>   R       (output) float*, size A-&gt;nrow
           If INFO = 0 or INFO &gt; M, R contains the row scale factors   
           for A.</pre><p>
<pre>   C       (output) float*, size A-&gt;ncol
           If INFO = 0,  C contains the column scale factors for A.</pre><p>
<pre>   ROWCND  (output) float*
           If INFO = 0 or INFO &gt; M, ROWCND contains the ratio of the   
           smallest R(i) to the largest R(i).  If ROWCND &gt;= 0.1 and   
           AMAX is neither too large nor too small, it is not worth   
           scaling by R.</pre><p>
<pre>   COLCND  (output) float*
           If INFO = 0, COLCND contains the ratio of the smallest   
           C(i) to the largest C(i).  If COLCND &gt;= 0.1, it is not   
           worth scaling by C.</pre><p>
<pre>   AMAX    (output) float*
           Absolute value of largest matrix element.  If AMAX is very   
           close to overflow or very close to underflow, the matrix   
           should be scaled.</pre><p>
<pre>   INFO    (output) int*
           = 0:  successful exit   
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value   
           &gt; 0:  if INFO = i,  and i is   
                 &lt;= A-&gt;nrow:  the i-th row of A is exactly zero   
                 &gt;  A-&gt;ncol:  the (i-M)-th column of A is exactly zero</pre><p>
<pre>   ===================================================================== 
 </pre> 
</div>
</div><p>
<a class="anchor" name="908282efea752470dcd38f794b435dbc"></a><!-- doxytag: member="slu_cdefs.h::cgsisv" ref="908282efea752470dcd38f794b435dbc" args="(superlu_options_t *, SuperMatrix *, int *, int *, SuperMatrix *, SuperMatrix *, SuperMatrix *, SuperLUStat_t *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgsisv           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="35048de8a07c47ab61c15793f63ad398"></a><!-- doxytag: member="slu_cdefs.h::cgsisx" ref="35048de8a07c47ab61c15793f63ad398" args="(superlu_options_t *, SuperMatrix *, int *, int *, int *, char *, float *, float *, SuperMatrix *, SuperMatrix *, void *, int, SuperMatrix *, SuperMatrix *, float *, float *, mem_usage_t *, SuperLUStat_t *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgsisx           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>etree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>recip_pivot_growth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mem_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> CGSISX computes an approximate solutions of linear equations
 A*X=B or A'*X=B, using the ILU factorization from <a class="el" href="cgsitrf_8c.html#16b6ae6c8a2812e62ace44629f313bc6">cgsitrf()</a>.
 An estimation of the condition number is provided. 
 The routine performs the following steps:</pre><p>
<pre>   1. If A is stored column-wise (A-&gt;Stype = SLU_NC):</pre><p>
<pre>	1.1. If options-&gt;Equil = YES or options-&gt;RowPerm = LargeDiag, scaling
	     factors are computed to equilibrate the system:
	     options-&gt;Trans = NOTRANS:
		 diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
	     options-&gt;Trans = TRANS:
		 (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
	     options-&gt;Trans = CONJ:
		 (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
	     Whether or not the system will be equilibrated depends on the
	     scaling of the matrix A, but if equilibration is used, A is
	     overwritten by diag(R)*A*diag(C) and B by diag(R)*B
	     (if options-&gt;Trans=NOTRANS) or diag(C)*B (if options-&gt;Trans
	     = TRANS or CONJ).</pre><p>
<pre>	1.2. Permute columns of A, forming A*Pc, where Pc is a permutation
	     matrix that usually preserves sparsity.
	     For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix.">sp_preorder.c</a>.</pre><p>
<pre>	1.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
	     factor the matrix A (after equilibration if options-&gt;Equil = YES)
	     as Pr*A*Pc = L*U, with Pr determined by partial pivoting.</pre><p>
<pre>	1.4. Compute the reciprocal pivot growth factor.</pre><p>
<pre>	1.5. If some U(i,i) = 0, so that U is exactly singular, then the
	     routine fills a small number on the diagonal entry, that is
		U(i,i) = ||A(:,i)||_oo * options-&gt;ILU_FillTol ** (1 - i / n),
	     and info will be increased by 1. The factored form of A is used
	     to estimate the condition number of the preconditioner. If the
	     reciprocal of the condition number is less than machine precision,
	     info = A-&gt;ncol+1 is returned as a warning, but the routine still
	     goes on to solve for X.</pre><p>
<pre>	1.6. The system of equations is solved for X using the factored form
	     of A.</pre><p>
<pre>	1.7. options-&gt;IterRefine is not used</pre><p>
<pre>	1.8. If equilibration was used, the matrix X is premultiplied by
	     diag(C) (if options-&gt;Trans = NOTRANS) or diag(R)
	     (if options-&gt;Trans = TRANS or CONJ) so that it solves the
	     original system before equilibration.</pre><p>
<pre>	1.9. options for ILU only
	     1) If options-&gt;RowPerm = LargeDiag, MC64 is used to scale and
		permute the matrix to an I-matrix, that is Pr*Dr*A*Dc has
		entries of modulus 1 on the diagonal and off-diagonal entries
		of modulus at most 1. If MC64 fails, <a class="el" href="dgsequ_8c.html#af22b247cc134fb0ba90285e84ccebb4" title="Driver related.">dgsequ()</a> is used to
		equilibrate the system.
              ( Default: LargeDiag )
	     2) options-&gt;ILU_DropTol = tau is the threshold for dropping.
		For L, it is used directly (for the whole row in a supernode);
		For U, ||A(:,i)||_oo * tau is used as the threshold
	        for the	i-th column.
		If a secondary dropping rule is required, tau will
	        also be used to compute the second threshold.
              ( Default: 1e-4 )
	     3) options-&gt;ILU_FillFactor = gamma, used as the initial guess
		of memory growth.
		If a secondary dropping rule is required, it will also
              be used as an upper bound of the memory.
              ( Default: 10 )
	     4) options-&gt;ILU_DropRule specifies the dropping rule.
		Option	      Meaning
		======	      ===========
		DROP_BASIC:   Basic dropping rule, supernodal based ILUTP(tau).
		DROP_PROWS:   Supernodal based ILUTP(p,tau), p = gamma*nnz(A)/n.
		DROP_COLUMN:  Variant of ILUTP(p,tau), for j-th column,
			      p = gamma * nnz(A(:,j)).
		DROP_AREA:    Variation of ILUTP, for j-th column, use
			      nnz(F(:,1:j)) / nnz(A(:,1:j)) to control memory.
		DROP_DYNAMIC: Modify the threshold tau during factorizaion:
			      If nnz(L(:,1:j)) / nnz(A(:,1:j)) &gt; gamma
				  tau_L(j) := MIN(tau_0, tau_L(j-1) * 2);
			      Otherwise
				  tau_L(j) := MAX(tau_0, tau_L(j-1) / 2);
			      tau_U(j) uses the similar rule.
			      NOTE: the thresholds used by L and U are separate.
		DROP_INTERP:  Compute the second dropping threshold by
			      interpolation instead of sorting (default).
			      In this case, the actual fill ratio is not
			      guaranteed smaller than gamma.
		DROP_PROWS, DROP_COLUMN and DROP_AREA are mutually exclusive.
		( Default: DROP_BASIC | DROP_AREA )
	     5) options-&gt;ILU_Norm is the criterion of measuring the magnitude
		of a row in a supernode of L. ( Default is INF_NORM )
		options-&gt;ILU_Norm	RowSize(x[1:n])
		=================	===============
		ONE_NORM		||x||_1 / n
		TWO_NORM		||x||_2 / sqrt(n)
		INF_NORM		max{|x[i]|}
	     6) options-&gt;ILU_MILU specifies the type of MILU's variation.
		= SILU: do not perform Modified ILU;
		= SMILU_1 (not recommended):
		    U(i,i) := U(i,i) + sum(dropped entries);
		= SMILU_2:
		    U(i,i) := U(i,i) + SGN(U(i,i)) * sum(dropped entries);
		= SMILU_3:
		    U(i,i) := U(i,i) + SGN(U(i,i)) * sum(|dropped entries|);
		NOTE: Even SMILU_1 does not preserve the column sum because of
		late dropping.
              ( Default: SILU )
	     7) options-&gt;ILU_FillTol is used as the perturbation when
		encountering zero pivots. If some U(i,i) = 0, so that U is
		exactly singular, then
		   U(i,i) := ||A(:,i)|| * options-&gt;ILU_FillTol ** (1 - i / n).
              ( Default: 1e-2 )</pre><p>
<pre>   2. If A is stored row-wise (A-&gt;Stype = SLU_NR), apply the above algorithm
	to the transpose of A:</pre><p>
<pre>	2.1. If options-&gt;Equil = YES or options-&gt;RowPerm = LargeDiag, scaling
	     factors are computed to equilibrate the system:
	     options-&gt;Trans = NOTRANS:
		 diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
	     options-&gt;Trans = TRANS:
		 (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
	     options-&gt;Trans = CONJ:
		 (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
	     Whether or not the system will be equilibrated depends on the
	     scaling of the matrix A, but if equilibration is used, A' is
	     overwritten by diag(R)*A'*diag(C) and B by diag(R)*B
	     (if trans='N') or diag(C)*B (if trans = 'T' or 'C').</pre><p>
<pre>	2.2. Permute columns of transpose(A) (rows of A),
	     forming transpose(A)*Pc, where Pc is a permutation matrix that
	     usually preserves sparsity.
	     For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix.">sp_preorder.c</a>.</pre><p>
<pre>	2.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
	     factor the transpose(A) (after equilibration if
	     options-&gt;Fact = YES) as Pr*transpose(A)*Pc = L*U with the
	     permutation Pr determined by partial pivoting.</pre><p>
<pre>	2.4. Compute the reciprocal pivot growth factor.</pre><p>
<pre>	2.5. If some U(i,i) = 0, so that U is exactly singular, then the
	     routine fills a small number on the diagonal entry, that is
		 U(i,i) = ||A(:,i)||_oo * options-&gt;ILU_FillTol ** (1 - i / n).
	     And info will be increased by 1. The factored form of A is used
	     to estimate the condition number of the preconditioner. If the
	     reciprocal of the condition number is less than machine precision,
	     info = A-&gt;ncol+1 is returned as a warning, but the routine still
	     goes on to solve for X.</pre><p>
<pre>	2.6. The system of equations is solved for X using the factored form
	     of transpose(A).</pre><p>
<pre>	2.7. If options-&gt;IterRefine is not used.</pre><p>
<pre>	2.8. If equilibration was used, the matrix X is premultiplied by
	     diag(C) (if options-&gt;Trans = NOTRANS) or diag(R)
	     (if options-&gt;Trans = TRANS or CONJ) so that it solves the
	     original system before equilibration.</pre><p>
<pre>   See <a class="el" href="supermatrix_8h.html" title="Defines matrix types.">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> options (input) superlu_options_t*
	   The structure defines the input parameters to control
	   how the LU decomposition will be performed and how the
	   system will be solved.</pre><p>
<pre> A	   (input/output) SuperMatrix*
	   Matrix A in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol). The number
	   of the linear equations is A-&gt;nrow. Currently, the type of A can be:
	   Stype = SLU_NC or SLU_NR, Dtype = SLU_C, Mtype = SLU_GE.
	   In the future, more general A may be handled.</pre><p>
<pre>	   On entry, If options-&gt;Fact = FACTORED and equed is not 'N',
	   then A must have been equilibrated by the scaling factors in
	   R and/or C.
	   On exit, A is not modified
         if options-&gt;Equil = NO, or
         if options-&gt;Equil = YES but equed = 'N' on exit, or
         if options-&gt;RowPerm = NO.</pre><p>
<pre>	   Otherwise, if options-&gt;Equil = YES and equed is not 'N',
	   A is scaled as follows:
	   If A-&gt;Stype = SLU_NC:
	     equed = 'R':  A := diag(R) * A
	     equed = 'C':  A := A * diag(C)
	     equed = 'B':  A := diag(R) * A * diag(C).
	   If A-&gt;Stype = SLU_NR:
	     equed = 'R':  transpose(A) := diag(R) * transpose(A)
	     equed = 'C':  transpose(A) := transpose(A) * diag(C)
	     equed = 'B':  transpose(A) := diag(R) * transpose(A) * diag(C).</pre><p>
<pre>         If options-&gt;RowPerm = LargeDiag, MC64 is used to scale and permute
            the matrix to an I-matrix, that is A is modified as follows:
            P*Dr*A*Dc has entries of modulus 1 on the diagonal and 
            off-diagonal entries of modulus at most 1. P is a permutation
            obtained from MC64.
            If MC64 fails, <a class="el" href="cgsequ_8c.html#36bb68fea3ee44ff05eb7da2ee059fa5" title="Driver related.">cgsequ()</a> is used to equilibrate the system,
            and A is scaled as above, but no permutation is involved.
            On exit, A is restored to the orginal row numbering, so
            Dr*A*Dc is returned.</pre><p>
<pre> perm_c  (input/output) int*
	   If A-&gt;Stype = SLU_NC, Column permutation vector of size A-&gt;ncol,
	   which defines the permutation matrix Pc; perm_c[i] = j means
	   column i of A is in position j in A*Pc.
	   On exit, perm_c may be overwritten by the product of the input
	   perm_c and a permutation that postorders the elimination tree
	   of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree
	   is already in postorder.</pre><p>
<pre>	   If A-&gt;Stype = SLU_NR, column permutation vector of size A-&gt;nrow,
	   which describes permutation of columns of transpose(A) 
	   (rows of A) as described above.</pre><p>
<pre> perm_r  (input/output) int*
	   If A-&gt;Stype = SLU_NC, row permutation vector of size A-&gt;nrow, 
	   which defines the permutation matrix Pr, and is determined
	   by MC64 first then followed by partial pivoting.
         perm_r[i] = j means row i of A is in position j in Pr*A.</pre><p>
<pre>	   If A-&gt;Stype = SLU_NR, permutation vector of size A-&gt;ncol, which
	   determines permutation of rows of transpose(A)
	   (columns of A) as described above.</pre><p>
<pre>	   If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
	   will try to use the input perm_r, unless a certain threshold
	   criterion is violated. In that case, perm_r is overwritten by a
	   new permutation determined by partial pivoting or diagonal
	   threshold pivoting.
	   Otherwise, perm_r is output argument.</pre><p>
<pre> etree   (input/output) int*,  dimension (A-&gt;ncol)
	   Elimination tree of Pc'*A'*A*Pc.
	   If options-&gt;Fact != FACTORED and options-&gt;Fact != DOFACT,
	   etree is an input argument, otherwise it is an output argument.
	   Note: etree is a vector of parent pointers for a forest whose
	   vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.</pre><p>
<pre> equed   (input/output) char*
	   Specifies the form of equilibration that was done.
	   = 'N': No equilibration.
	   = 'R': Row equilibration, i.e., A was premultiplied by diag(R).
	   = 'C': Column equilibration, i.e., A was postmultiplied by diag(C).
	   = 'B': Both row and column equilibration, i.e., A was replaced 
		  by diag(R)*A*diag(C).
	   If options-&gt;Fact = FACTORED, equed is an input argument,
	   otherwise it is an output argument.</pre><p>
<pre> R	   (input/output) float*, dimension (A-&gt;nrow)
	   The row scale factors for A or transpose(A).
	   If equed = 'R' or 'B', A (if A-&gt;Stype = SLU_NC) or transpose(A)
	       (if A-&gt;Stype = SLU_NR) is multiplied on the left by diag(R).
	   If equed = 'N' or 'C', R is not accessed.
	   If options-&gt;Fact = FACTORED, R is an input argument,
	       otherwise, R is output.
	   If options-&gt;Fact = FACTORED and equed = 'R' or 'B', each element
	       of R must be positive.</pre><p>
<pre> C	   (input/output) float*, dimension (A-&gt;ncol)
	   The column scale factors for A or transpose(A).
	   If equed = 'C' or 'B', A (if A-&gt;Stype = SLU_NC) or transpose(A)
	       (if A-&gt;Stype = SLU_NR) is multiplied on the right by diag(C).
	   If equed = 'N' or 'R', C is not accessed.
	   If options-&gt;Fact = FACTORED, C is an input argument,
	       otherwise, C is output.
	   If options-&gt;Fact = FACTORED and equed = 'C' or 'B', each element
	       of C must be positive.</pre><p>
<pre> L	   (output) SuperMatrix*
	   The factor L from the factorization
	       Pr*A*Pc=L*U		(if A-&gt;Stype SLU_= NC) or
	       Pr*transpose(A)*Pc=L*U	(if A-&gt;Stype = SLU_NR).
	   Uses compressed row subscripts storage for supernodes, i.e.,
	   L has types: Stype = SLU_SC, Dtype = SLU_C, Mtype = SLU_TRLU.</pre><p>
<pre> U	   (output) SuperMatrix*
	   The factor U from the factorization
	       Pr*A*Pc=L*U		(if A-&gt;Stype = SLU_NC) or
	       Pr*transpose(A)*Pc=L*U	(if A-&gt;Stype = SLU_NR).
	   Uses column-wise storage scheme, i.e., U has types:
	   Stype = SLU_NC, Dtype = SLU_C, Mtype = SLU_TRU.</pre><p>
<pre> work    (workspace/output) void*, size (lwork) (in bytes)
	   User supplied workspace, should be large enough
	   to hold data structures for factors L and U.
	   On exit, if fact is not 'F', L and U point to this array.</pre><p>
<pre> lwork   (input) int
	   Specifies the size of work array in bytes.
	   = 0:  allocate space internally by system malloc;
	   &gt; 0:  use user-supplied work array of length lwork in bytes,
		 returns error if space runs out.
	   = -1: the routine guesses the amount of space needed without
		 performing the factorization, and returns it in
		 mem_usage-&gt;total_needed; no other side effects.</pre><p>
<pre>	   See argument 'mem_usage' for memory usage statistics.</pre><p>
<pre> B	   (input/output) SuperMatrix*
	   B has types: Stype = SLU_DN, Dtype = SLU_C, Mtype = SLU_GE.
	   On entry, the right hand side matrix.
	   If B-&gt;ncol = 0, only LU decomposition is performed, the triangular
			   solve is skipped.
	   On exit,
	      if equed = 'N', B is not modified; otherwise
	      if A-&gt;Stype = SLU_NC:
		 if options-&gt;Trans = NOTRANS and equed = 'R' or 'B',
		    B is overwritten by diag(R)*B;
		 if options-&gt;Trans = TRANS or CONJ and equed = 'C' of 'B',
		    B is overwritten by diag(C)*B;
	      if A-&gt;Stype = SLU_NR:
		 if options-&gt;Trans = NOTRANS and equed = 'C' or 'B',
		    B is overwritten by diag(C)*B;
		 if options-&gt;Trans = TRANS or CONJ and equed = 'R' of 'B',
		    B is overwritten by diag(R)*B.</pre><p>
<pre> X	   (output) SuperMatrix*
	   X has types: Stype = SLU_DN, Dtype = SLU_C, Mtype = SLU_GE.
	   If info = 0 or info = A-&gt;ncol+1, X contains the solution matrix
	   to the original system of equations. Note that A and B are modified
	   on exit if equed is not 'N', and the solution to the equilibrated
	   system is inv(diag(C))*X if options-&gt;Trans = NOTRANS and
	   equed = 'C' or 'B', or inv(diag(R))*X if options-&gt;Trans = 'T' or 'C'
	   and equed = 'R' or 'B'.</pre><p>
<pre> recip_pivot_growth (output) float*
	   The reciprocal pivot growth factor max_j( norm(A_j)/norm(U_j) ).
	   The infinity norm is used. If recip_pivot_growth is much less
	   than 1, the stability of the LU factorization could be poor.</pre><p>
<pre> rcond   (output) float*
	   The estimate of the reciprocal condition number of the matrix A
	   after equilibration (if done). If rcond is less than the machine
	   precision (in particular, if rcond = 0), the matrix is singular
	   to working precision. This condition is indicated by a return
	   code of info &gt; 0.</pre><p>
<pre> mem_usage (output) mem_usage_t*
	   Record the memory usage statistics, consisting of following fields:<ul>
<li>for_lu (float)
	     The amount of space used in bytes for L data structures.</li><li>total_needed (float)
	     The amount of space needed in bytes to perform factorization.</li><li>expansions (int)
	     The number of memory expansions during the LU factorization.</li></ul>
</pre><p>
<pre> stat   (output) SuperLUStat_t*
	  Record the statistics on runtime and floating-point operation count.
	  See <a class="el" href="slu__util_8h.html" title="Utility header file.">slu_util.h</a> for the definition of 'SuperLUStat_t'.</pre><p>
<pre> info    (output) int*
	   = 0: successful exit
	   &lt; 0: if info = -i, the i-th argument had an illegal value
	   &gt; 0: if info = i, and i is
		&lt;= A-&gt;ncol: number of zero pivots. They are replaced by small
		      entries due to options-&gt;ILU_FillTol.
		= A-&gt;ncol+1: U is nonsingular, but RCOND is less than machine
		      precision, meaning that the matrix is singular to
		      working precision. Nevertheless, the solution and
		      error bounds are computed because there are a number
		      of situations where the computed solution can be more
		      accurate than the value of RCOND would suggest.
		&gt; A-&gt;ncol+1: number of bytes allocated when memory allocation
		      failure occurred, plus A-&gt;ncol.
 </pre> 
</div>
</div><p>
<a class="anchor" name="82dc99bce4d9b50c3534eb424d03182b"></a><!-- doxytag: member="slu_cdefs.h::cgsitrf" ref="82dc99bce4d9b50c3534eb424d03182b" args="(superlu_options_t *, SuperMatrix *, int, int, int *, void *, int, int *, int *, SuperMatrix *, SuperMatrix *, SuperLUStat_t *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgsitrf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>relax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>etree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> CGSITRF computes an ILU factorization of a general sparse m-by-n
 matrix A using partial pivoting with row interchanges.
 The factorization has the form
     Pr * A = L * U
 where Pr is a row permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if A-&gt;nrow &gt; A-&gt;ncol), and U is upper
 triangular (upper trapezoidal if A-&gt;nrow &lt; A-&gt;ncol).</pre><p>
<pre> See <a class="el" href="supermatrix_8h.html" title="Defines matrix types.">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> options (input) superlu_options_t*
	   The structure defines the input parameters to control
	   how the ILU decomposition will be performed.</pre><p>
<pre> A	    (input) SuperMatrix*
	    Original matrix A, permuted by columns, of dimension
	    (A-&gt;nrow, A-&gt;ncol). The type of A can be:
	    Stype = SLU_NCP; Dtype = SLU_C; Mtype = SLU_GE.</pre><p>
<pre> relax    (input) int
	    To control degree of relaxing supernodes. If the number
	    of nodes (columns) in a subtree of the elimination tree is less
	    than relax, this subtree is considered as one supernode,
	    regardless of the row structures of those columns.</pre><p>
<pre> panel_size (input) int
	    A panel consists of at most panel_size consecutive columns.</pre><p>
<pre> etree    (input) int*, dimension (A-&gt;ncol)
	    Elimination tree of A'*A.
	    Note: etree is a vector of parent pointers for a forest whose
	    vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.
	    On input, the columns of A should be permuted so that the
	    etree is in a certain postorder.</pre><p>
<pre> work     (input/output) void*, size (lwork) (in bytes)
	    User-supplied work space and space for the output data structures.
	    Not referenced if lwork = 0;</pre><p>
<pre> lwork   (input) int
	   Specifies the size of work array in bytes.
	   = 0:  allocate space internally by system malloc;
	   &gt; 0:  use user-supplied work array of length lwork in bytes,
		 returns error if space runs out.
	   = -1: the routine guesses the amount of space needed without
		 performing the factorization, and returns it in
		 *info; no other side effects.</pre><p>
<pre> perm_c   (input) int*, dimension (A-&gt;ncol)
	    Column permutation vector, which defines the
	    permutation matrix Pc; perm_c[i] = j means column i of A is
	    in position j in A*Pc.
	    When searching for diagonal, perm_c[*] is applied to the
	    row subscripts of A, so that diagonal threshold pivoting
	    can find the diagonal of A, rather than that of A*Pc.</pre><p>
<pre> perm_r   (input/output) int*, dimension (A-&gt;nrow)
	    Row permutation vector which defines the permutation matrix Pr,
	    perm_r[i] = j means row i of A is in position j in Pr*A.
	    If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
	       will try to use the input perm_r, unless a certain threshold
	       criterion is violated. In that case, perm_r is overwritten by
	       a new permutation determined by partial pivoting or diagonal
	       threshold pivoting.
	    Otherwise, perm_r is output argument;</pre><p>
<pre> L	    (output) SuperMatrix*
	    The factor L from the factorization Pr*A=L*U; use compressed row
	    subscripts storage for supernodes, i.e., L has type:
	    Stype = SLU_SC, Dtype = SLU_C, Mtype = SLU_TRLU.</pre><p>
<pre> U	    (output) SuperMatrix*
	    The factor U from the factorization Pr*A*Pc=L*U. Use column-wise
	    storage scheme, i.e., U has types: Stype = SLU_NC,
	    Dtype = SLU_C, Mtype = SLU_TRU.</pre><p>
<pre> stat     (output) SuperLUStat_t*
	    Record the statistics on runtime and floating-point operation count.
	    See <a class="el" href="slu__util_8h.html" title="Utility header file.">slu_util.h</a> for the definition of 'SuperLUStat_t'.</pre><p>
<pre> info     (output) int*
	    = 0: successful exit
	    &lt; 0: if info = -i, the i-th argument had an illegal value
	    &gt; 0: if info = i, and i is
	       &lt;= A-&gt;ncol: number of zero pivots. They are replaced by small
		  entries according to options-&gt;ILU_FillTol.
	       &gt; A-&gt;ncol: number of bytes allocated when memory allocation
		  failure occurred, plus A-&gt;ncol. If lwork = -1, it is
		  the estimated amount of space needed, plus A-&gt;ncol.</pre><p>
<pre> ======================================================================</pre><p>
<pre> Local Working Arrays:
 ======================
   m = number of rows in the matrix
   n = number of columns in the matrix</pre><p>
<pre>   marker[0:3*m-1]: marker[i] = j means that node i has been
	reached when working on column j.
	Storage: relative to original row subscripts
	NOTE: There are 4 of them:
	      marker/marker1 are used for panel dfs, see (ilu_)<a class="el" href="dpanel__dfs_8c.html" title="Peforms a symbolic factorization on a panel of symbols.">dpanel_dfs.c</a>;
	      marker2 is used for inner-factorization, see (ilu)_dcolumn_dfs.c;
	      marker_relax(has its own space) is used for relaxed supernodes.</pre><p>
<pre>   parent[0:m-1]: parent vector used during dfs
	Storage: relative to new row subscripts</pre><p>
<pre>   xplore[0:m-1]: xplore[i] gives the location of the next (dfs)
	unexplored neighbor of i in lsub[*]</pre><p>
<pre>   segrep[0:nseg-1]: contains the list of supernodal representatives
	in topological order of the dfs. A supernode representative is the
	last column of a supernode.
	The maximum size of segrep[] is n.</pre><p>
<pre>   repfnz[0:W*m-1]: for a nonzero segment U[*,j] that ends at a
	supernodal representative r, repfnz[r] is the location of the first
	nonzero in this segment.  It is also used during the dfs: repfnz[r]&gt;0
	indicates the supernode r has been explored.
	NOTE: There are W of them, each used for one column of a panel.</pre><p>
<pre>   panel_lsub[0:W*m-1]: temporary for the nonzeros row indices below
	the panel diagonal. These are filled in during <a class="el" href="dpanel__dfs_8c.html#2a809488b87d2c1a9b2a574b726e8517">dpanel_dfs()</a>, and are
	used later in the inner LU factorization within the panel.
	panel_lsub[]/dense[] pair forms the SPA data structure.
	NOTE: There are W of them.</pre><p>
<pre>   dense[0:W*m-1]: sparse accumulating (SPA) vector for intermediate values;
		   NOTE: there are W of them.</pre><p>
<pre>   tempv[0:*]: real temporary used for dense numeric kernels;
	The size of this array is defined by <a class="el" href="slu__util_8h.html#06193b28f40a4779ae7737711642eb45">NUM_TEMPV()</a> in <a class="el" href="slu__util_8h.html" title="Utility header file.">slu_util.h</a>.
	It is also used by the dropping routine <a class="el" href="ilu__ddrop__row_8c.html#380317801e05b11930fd1e094db34179">ilu_ddrop_row()</a>.
 </pre> 
</div>
</div><p>
<a class="anchor" name="64715c1d0510eaf5f8e37f2465e9e8d6"></a><!-- doxytag: member="slu_cdefs.h::cgsrfs" ref="64715c1d0510eaf5f8e37f2465e9e8d6" args="(trans_t, SuperMatrix *, SuperMatrix *, SuperMatrix *, int *, int *, char *, float *, float *, SuperMatrix *, SuperMatrix *, float *, float *, SuperLUStat_t *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgsrfs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>&nbsp;</td>
          <td class="paramname"> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
   Purpose   
   =======</pre><p>
<pre>   CGSRFS improves the computed solution to a system of linear   
   equations and provides error bounds and backward error estimates for 
   the solution.</pre><p>
<pre>   If equilibration was performed, the system becomes:
           (diag(R)*A_original*diag(C)) * X = diag(R)*B_original.</pre><p>
<pre>   See <a class="el" href="supermatrix_8h.html" title="Defines matrix types.">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre>   Arguments   
   =========</pre><p>
<pre> trans   (input) trans_t
          Specifies the form of the system of equations:
          = NOTRANS: A * X = B  (No transpose)
          = TRANS:   A'* X = B  (Transpose)
          = CONJ:    A**H * X = B  (Conjugate transpose)</pre><p>
<pre>   A       (input) SuperMatrix*
           The original matrix A in the system, or the scaled A if
           equilibration was done. The type of A can be:
           Stype = SLU_NC, Dtype = SLU_C, Mtype = SLU_GE.</pre><p>
<pre>   L       (input) SuperMatrix*
	     The factor L from the factorization Pr*A*Pc=L*U. Use
           compressed row subscripts storage for supernodes, 
           i.e., L has types: Stype = SLU_SC, Dtype = SLU_C, Mtype = SLU_TRLU.</pre><p>
<pre>   U       (input) SuperMatrix*
           The factor U from the factorization Pr*A*Pc=L*U as computed by
           <a class="el" href="cgstrf_8c.html#9c9f2ce12946612c7426a10352ac5984">cgstrf()</a>. Use column-wise storage scheme, 
           i.e., U has types: Stype = SLU_NC, Dtype = SLU_C, Mtype = SLU_TRU.</pre><p>
<pre>   perm_c  (input) int*, dimension (A-&gt;ncol)
	     Column permutation vector, which defines the 
           permutation matrix Pc; perm_c[i] = j means column i of A is 
           in position j in A*Pc.</pre><p>
<pre>   perm_r  (input) int*, dimension (A-&gt;nrow)
           Row permutation vector, which defines the permutation matrix Pr;
           perm_r[i] = j means row i of A is in position j in Pr*A.</pre><p>
<pre>   equed   (input) Specifies the form of equilibration that was done.
           = 'N': No equilibration.
           = 'R': Row equilibration, i.e., A was premultiplied by diag(R).
           = 'C': Column equilibration, i.e., A was postmultiplied by
                  diag(C).
           = 'B': Both row and column equilibration, i.e., A was replaced 
                  by diag(R)*A*diag(C).</pre><p>
<pre>   R       (input) float*, dimension (A-&gt;nrow)
           The row scale factors for A.
           If equed = 'R' or 'B', A is premultiplied by diag(R).
           If equed = 'N' or 'C', R is not accessed.</pre><p>
<pre>   C       (input) float*, dimension (A-&gt;ncol)
           The column scale factors for A.
           If equed = 'C' or 'B', A is postmultiplied by diag(C).
           If equed = 'N' or 'R', C is not accessed.</pre><p>
<pre>   B       (input) SuperMatrix*
           B has types: Stype = SLU_DN, Dtype = SLU_C, Mtype = SLU_GE.
           The right hand side matrix B.
           if equed = 'R' or 'B', B is premultiplied by diag(R).</pre><p>
<pre>   X       (input/output) SuperMatrix*
           X has types: Stype = SLU_DN, Dtype = SLU_C, Mtype = SLU_GE.
           On entry, the solution matrix X, as computed by <a class="el" href="cgstrs_8c.html#19517b9d29e4faf9ae777ca6fb9d415b">cgstrs()</a>.
           On exit, the improved solution matrix X.
           if *equed = 'C' or 'B', X should be premultiplied by diag(C)
               in order to obtain the solution to the original system.</pre><p>
<pre>   FERR    (output) float*, dimension (B-&gt;ncol)   
           The estimated forward error bound for each solution vector   
           X(j) (the j-th column of the solution matrix X).   
           If XTRUE is the true solution corresponding to X(j), FERR(j) 
           is an estimated upper bound for the magnitude of the largest 
           element in (X(j) - XTRUE) divided by the magnitude of the   
           largest element in X(j).  The estimate is as reliable as   
           the estimate for RCOND, and is almost always a slight   
           overestimate of the true error.</pre><p>
<pre>   BERR    (output) float*, dimension (B-&gt;ncol)   
           The componentwise relative backward error of each solution   
           vector X(j) (i.e., the smallest relative change in   
           any element of A or B that makes X(j) an exact solution).</pre><p>
<pre>   stat     (output) SuperLUStat_t*
            Record the statistics on runtime and floating-point operation count.
            See util.h for the definition of 'SuperLUStat_t'.</pre><p>
<pre>   info    (output) int*   
           = 0:  successful exit   
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value</pre><p>
<pre>    Internal Parameters   
    ===================</pre><p>
<pre>    ITMAX is the maximum number of steps of iterative refinement.</pre><p>
<pre> </pre> 
</div>
</div><p>
<a class="anchor" name="58aff6521bb64732e981ce5779820a89"></a><!-- doxytag: member="slu_cdefs.h::cgssv" ref="58aff6521bb64732e981ce5779820a89" args="(superlu_options_t *, SuperMatrix *, int *, int *, SuperMatrix *, SuperMatrix *, SuperMatrix *, SuperLUStat_t *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgssv           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> CGSSV solves the system of linear equations A*X=B, using the
 LU factorization from CGSTRF. It performs the following steps:</pre><p>
<pre>   1. If A is stored column-wise (A-&gt;Stype = SLU_NC):</pre><p>
<pre>      1.1. Permute the columns of A, forming A*Pc, where Pc
           is a permutation matrix. For more details of this step, 
           see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix.">sp_preorder.c</a>.</pre><p>
<pre>      1.2. Factor A as Pr*A*Pc=L*U with the permutation Pr determined
           by Gaussian elimination with partial pivoting.
           L is unit lower triangular with offdiagonal entries
           bounded by 1 in magnitude, and U is upper triangular.</pre><p>
<pre>      1.3. Solve the system of equations A*X=B using the factored
           form of A.</pre><p>
<pre>   2. If A is stored row-wise (A-&gt;Stype = SLU_NR), apply the
      above algorithm to the transpose of A:</pre><p>
<pre>      2.1. Permute columns of transpose(A) (rows of A),
           forming transpose(A)*Pc, where Pc is a permutation matrix. 
           For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix.">sp_preorder.c</a>.</pre><p>
<pre>      2.2. Factor A as Pr*transpose(A)*Pc=L*U with the permutation Pr
           determined by Gaussian elimination with partial pivoting.
           L is unit lower triangular with offdiagonal entries
           bounded by 1 in magnitude, and U is upper triangular.</pre><p>
<pre>      2.3. Solve the system of equations A*X=B using the factored
           form of A.</pre><p>
<pre>   See <a class="el" href="supermatrix_8h.html" title="Defines matrix types.">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> options (input) superlu_options_t*
         The structure defines the input parameters to control
         how the LU decomposition will be performed and how the
         system will be solved.</pre><p>
<pre> A       (input) SuperMatrix*
         Matrix A in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol). The number
         of linear equations is A-&gt;nrow. Currently, the type of A can be:
         Stype = SLU_NC or SLU_NR; Dtype = SLU_C; Mtype = SLU_GE.
         In the future, more general A may be handled.</pre><p>
<pre> perm_c  (input/output) int*
         If A-&gt;Stype = SLU_NC, column permutation vector of size A-&gt;ncol
         which defines the permutation matrix Pc; perm_c[i] = j means 
         column i of A is in position j in A*Pc.
         If A-&gt;Stype = SLU_NR, column permutation vector of size A-&gt;nrow
         which describes permutation of columns of transpose(A) 
         (rows of A) as described above.</pre><p>
<pre>         If options-&gt;ColPerm = MY_PERMC or options-&gt;Fact = SamePattern or
            options-&gt;Fact = SamePattern_SameRowPerm, it is an input argument.
            On exit, perm_c may be overwritten by the product of the input
            perm_c and a permutation that postorders the elimination tree
            of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree
            is already in postorder.
         Otherwise, it is an output argument.</pre><p>
<pre> perm_r  (input/output) int*
         If A-&gt;Stype = SLU_NC, row permutation vector of size A-&gt;nrow, 
         which defines the permutation matrix Pr, and is determined 
         by partial pivoting.  perm_r[i] = j means row i of A is in 
         position j in Pr*A.
         If A-&gt;Stype = SLU_NR, permutation vector of size A-&gt;ncol, which
         determines permutation of rows of transpose(A)
         (columns of A) as described above.</pre><p>
<pre>         If options-&gt;RowPerm = MY_PERMR or
            options-&gt;Fact = SamePattern_SameRowPerm, perm_r is an
            input argument.
         otherwise it is an output argument.</pre><p>
<pre> L       (output) SuperMatrix*
         The factor L from the factorization 
             Pr*A*Pc=L*U              (if A-&gt;Stype = SLU_NC) or
             Pr*transpose(A)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
         Uses compressed row subscripts storage for supernodes, i.e.,
         L has types: Stype = SLU_SC, Dtype = SLU_C, Mtype = SLU_TRLU.</pre><p>
<pre> U       (output) SuperMatrix*
	   The factor U from the factorization 
             Pr*A*Pc=L*U              (if A-&gt;Stype = SLU_NC) or
             Pr*transpose(A)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
         Uses column-wise storage scheme, i.e., U has types:
         Stype = SLU_NC, Dtype = SLU_C, Mtype = SLU_TRU.</pre><p>
<pre> B       (input/output) SuperMatrix*
         B has types: Stype = SLU_DN, Dtype = SLU_C, Mtype = SLU_GE.
         On entry, the right hand side matrix.
         On exit, the solution matrix if info = 0;</pre><p>
<pre> stat   (output) SuperLUStat_t*
        Record the statistics on runtime and floating-point operation count.
        See util.h for the definition of 'SuperLUStat_t'.</pre><p>
<pre> info    (output) int*
	   = 0: successful exit
         &gt; 0: if info = i, and i is
             &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
                been completed, but the factor U is exactly singular,
                so the solution could not be computed.
             &gt; A-&gt;ncol: number of bytes allocated when memory allocation
                failure occurred, plus A-&gt;ncol.
 </pre> 
</div>
</div><p>
<a class="anchor" name="264b6681cc04244cdd116978acfe4e2a"></a><!-- doxytag: member="slu_cdefs.h::cgssvx" ref="264b6681cc04244cdd116978acfe4e2a" args="(superlu_options_t *, SuperMatrix *, int *, int *, int *, char *, float *, float *, SuperMatrix *, SuperMatrix *, void *, int, SuperMatrix *, SuperMatrix *, float *, float *, float *, float *, mem_usage_t *, SuperLUStat_t *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgssvx           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>etree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>recip_pivot_growth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mem_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> CGSSVX solves the system of linear equations A*X=B or A'*X=B, using
 the LU factorization from <a class="el" href="cgstrf_8c.html#9c9f2ce12946612c7426a10352ac5984">cgstrf()</a>. Error bounds on the solution and
 a condition estimate are also provided. It performs the following steps:</pre><p>
<pre>   1. If A is stored column-wise (A-&gt;Stype = SLU_NC):</pre><p>
<pre>      1.1. If options-&gt;Equil = YES, scaling factors are computed to
           equilibrate the system:
           options-&gt;Trans = NOTRANS:
               diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
           options-&gt;Trans = TRANS:
               (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
           options-&gt;Trans = CONJ:
               (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
           Whether or not the system will be equilibrated depends on the
           scaling of the matrix A, but if equilibration is used, A is
           overwritten by diag(R)*A*diag(C) and B by diag(R)*B
           (if options-&gt;Trans=NOTRANS) or diag(C)*B (if options-&gt;Trans
           = TRANS or CONJ).</pre><p>
<pre>      1.2. Permute columns of A, forming A*Pc, where Pc is a permutation
           matrix that usually preserves sparsity.
           For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix.">sp_preorder.c</a>.</pre><p>
<pre>      1.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
           factor the matrix A (after equilibration if options-&gt;Equil = YES)
           as Pr*A*Pc = L*U, with Pr determined by partial pivoting.</pre><p>
<pre>      1.4. Compute the reciprocal pivot growth factor.</pre><p>
<pre>      1.5. If some U(i,i) = 0, so that U is exactly singular, then the
           routine returns with info = i. Otherwise, the factored form of 
           A is used to estimate the condition number of the matrix A. If
           the reciprocal of the condition number is less than machine
           precision, info = A-&gt;ncol+1 is returned as a warning, but the
           routine still goes on to solve for X and computes error bounds
           as described below.</pre><p>
<pre>      1.6. The system of equations is solved for X using the factored form
           of A.</pre><p>
<pre>      1.7. If options-&gt;IterRefine != NOREFINE, iterative refinement is
           applied to improve the computed solution matrix and calculate
           error bounds and backward error estimates for it.</pre><p>
<pre>      1.8. If equilibration was used, the matrix X is premultiplied by
           diag(C) (if options-&gt;Trans = NOTRANS) or diag(R)
           (if options-&gt;Trans = TRANS or CONJ) so that it solves the
           original system before equilibration.</pre><p>
<pre>   2. If A is stored row-wise (A-&gt;Stype = SLU_NR), apply the above algorithm
      to the transpose of A:</pre><p>
<pre>      2.1. If options-&gt;Equil = YES, scaling factors are computed to
           equilibrate the system:
           options-&gt;Trans = NOTRANS:
               diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
           options-&gt;Trans = TRANS:
               (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
           options-&gt;Trans = CONJ:
               (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
           Whether or not the system will be equilibrated depends on the
           scaling of the matrix A, but if equilibration is used, A' is
           overwritten by diag(R)*A'*diag(C) and B by diag(R)*B 
           (if trans='N') or diag(C)*B (if trans = 'T' or 'C').</pre><p>
<pre>      2.2. Permute columns of transpose(A) (rows of A), 
           forming transpose(A)*Pc, where Pc is a permutation matrix that 
           usually preserves sparsity.
           For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix.">sp_preorder.c</a>.</pre><p>
<pre>      2.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
           factor the transpose(A) (after equilibration if 
           options-&gt;Fact = YES) as Pr*transpose(A)*Pc = L*U with the
           permutation Pr determined by partial pivoting.</pre><p>
<pre>      2.4. Compute the reciprocal pivot growth factor.</pre><p>
<pre>      2.5. If some U(i,i) = 0, so that U is exactly singular, then the
           routine returns with info = i. Otherwise, the factored form 
           of transpose(A) is used to estimate the condition number of the
           matrix A. If the reciprocal of the condition number
           is less than machine precision, info = A-&gt;nrow+1 is returned as
           a warning, but the routine still goes on to solve for X and
           computes error bounds as described below.</pre><p>
<pre>      2.6. The system of equations is solved for X using the factored form
           of transpose(A).</pre><p>
<pre>      2.7. If options-&gt;IterRefine != NOREFINE, iterative refinement is
           applied to improve the computed solution matrix and calculate
           error bounds and backward error estimates for it.</pre><p>
<pre>      2.8. If equilibration was used, the matrix X is premultiplied by
           diag(C) (if options-&gt;Trans = NOTRANS) or diag(R) 
           (if options-&gt;Trans = TRANS or CONJ) so that it solves the
           original system before equilibration.</pre><p>
<pre>   See <a class="el" href="supermatrix_8h.html" title="Defines matrix types.">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> options (input) superlu_options_t*
         The structure defines the input parameters to control
         how the LU decomposition will be performed and how the
         system will be solved.</pre><p>
<pre> A       (input/output) SuperMatrix*
         Matrix A in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol). The number
         of the linear equations is A-&gt;nrow. Currently, the type of A can be:
         Stype = SLU_NC or SLU_NR, Dtype = SLU_D, Mtype = SLU_GE.
         In the future, more general A may be handled.</pre><p>
<pre>         On entry, If options-&gt;Fact = FACTORED and equed is not 'N', 
         then A must have been equilibrated by the scaling factors in
         R and/or C.  
         On exit, A is not modified if options-&gt;Equil = NO, or if 
         options-&gt;Equil = YES but equed = 'N' on exit.
         Otherwise, if options-&gt;Equil = YES and equed is not 'N',
         A is scaled as follows:
         If A-&gt;Stype = SLU_NC:
           equed = 'R':  A := diag(R) * A
           equed = 'C':  A := A * diag(C)
           equed = 'B':  A := diag(R) * A * diag(C).
         If A-&gt;Stype = SLU_NR:
           equed = 'R':  transpose(A) := diag(R) * transpose(A)
           equed = 'C':  transpose(A) := transpose(A) * diag(C)
           equed = 'B':  transpose(A) := diag(R) * transpose(A) * diag(C).</pre><p>
<pre> perm_c  (input/output) int*
	   If A-&gt;Stype = SLU_NC, Column permutation vector of size A-&gt;ncol,
         which defines the permutation matrix Pc; perm_c[i] = j means
         column i of A is in position j in A*Pc.
         On exit, perm_c may be overwritten by the product of the input
         perm_c and a permutation that postorders the elimination tree
         of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree
         is already in postorder.</pre><p>
<pre>         If A-&gt;Stype = SLU_NR, column permutation vector of size A-&gt;nrow,
         which describes permutation of columns of transpose(A) 
         (rows of A) as described above.</pre><p>
<pre> perm_r  (input/output) int*
         If A-&gt;Stype = SLU_NC, row permutation vector of size A-&gt;nrow, 
         which defines the permutation matrix Pr, and is determined
         by partial pivoting.  perm_r[i] = j means row i of A is in 
         position j in Pr*A.</pre><p>
<pre>         If A-&gt;Stype = SLU_NR, permutation vector of size A-&gt;ncol, which
         determines permutation of rows of transpose(A)
         (columns of A) as described above.</pre><p>
<pre>         If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
         will try to use the input perm_r, unless a certain threshold
         criterion is violated. In that case, perm_r is overwritten by a
         new permutation determined by partial pivoting or diagonal
         threshold pivoting.
         Otherwise, perm_r is output argument.</pre><p>
<pre> etree   (input/output) int*,  dimension (A-&gt;ncol)
         Elimination tree of Pc'*A'*A*Pc.
         If options-&gt;Fact != FACTORED and options-&gt;Fact != DOFACT,
         etree is an input argument, otherwise it is an output argument.
         Note: etree is a vector of parent pointers for a forest whose
         vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.</pre><p>
<pre> equed   (input/output) char*
         Specifies the form of equilibration that was done.
         = 'N': No equilibration.
         = 'R': Row equilibration, i.e., A was premultiplied by diag(R).
         = 'C': Column equilibration, i.e., A was postmultiplied by diag(C).
         = 'B': Both row and column equilibration, i.e., A was replaced 
                by diag(R)*A*diag(C).
         If options-&gt;Fact = FACTORED, equed is an input argument,
         otherwise it is an output argument.</pre><p>
<pre> R       (input/output) float*, dimension (A-&gt;nrow)
         The row scale factors for A or transpose(A).
         If equed = 'R' or 'B', A (if A-&gt;Stype = SLU_NC) or transpose(A)
             (if A-&gt;Stype = SLU_NR) is multiplied on the left by diag(R).
         If equed = 'N' or 'C', R is not accessed.
         If options-&gt;Fact = FACTORED, R is an input argument,
             otherwise, R is output.
         If options-&gt;zFact = FACTORED and equed = 'R' or 'B', each element
             of R must be positive.</pre><p>
<pre> C       (input/output) float*, dimension (A-&gt;ncol)
         The column scale factors for A or transpose(A).
         If equed = 'C' or 'B', A (if A-&gt;Stype = SLU_NC) or transpose(A)
             (if A-&gt;Stype = SLU_NR) is multiplied on the right by diag(C).
         If equed = 'N' or 'R', C is not accessed.
         If options-&gt;Fact = FACTORED, C is an input argument,
             otherwise, C is output.
         If options-&gt;Fact = FACTORED and equed = 'C' or 'B', each element
             of C must be positive.</pre><p>
<pre> L       (output) SuperMatrix*
	   The factor L from the factorization
             Pr*A*Pc=L*U              (if A-&gt;Stype SLU_= NC) or
             Pr*transpose(A)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
         Uses compressed row subscripts storage for supernodes, i.e.,
         L has types: Stype = SLU_SC, Dtype = SLU_C, Mtype = SLU_TRLU.</pre><p>
<pre> U       (output) SuperMatrix*
	   The factor U from the factorization
             Pr*A*Pc=L*U              (if A-&gt;Stype = SLU_NC) or
             Pr*transpose(A)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
         Uses column-wise storage scheme, i.e., U has types:
         Stype = SLU_NC, Dtype = SLU_C, Mtype = SLU_TRU.</pre><p>
<pre> work    (workspace/output) void*, size (lwork) (in bytes)
         User supplied workspace, should be large enough
         to hold data structures for factors L and U.
         On exit, if fact is not 'F', L and U point to this array.</pre><p>
<pre> lwork   (input) int
         Specifies the size of work array in bytes.
         = 0:  allocate space internally by system malloc;
         &gt; 0:  use user-supplied work array of length lwork in bytes,
               returns error if space runs out.
         = -1: the routine guesses the amount of space needed without
               performing the factorization, and returns it in
               mem_usage-&gt;total_needed; no other side effects.</pre><p>
<pre>         See argument 'mem_usage' for memory usage statistics.</pre><p>
<pre> B       (input/output) SuperMatrix*
         B has types: Stype = SLU_DN, Dtype = SLU_C, Mtype = SLU_GE.
         On entry, the right hand side matrix.
         If B-&gt;ncol = 0, only LU decomposition is performed, the triangular
                         solve is skipped.
         On exit,
            if equed = 'N', B is not modified; otherwise
            if A-&gt;Stype = SLU_NC:
               if options-&gt;Trans = NOTRANS and equed = 'R' or 'B',
                  B is overwritten by diag(R)*B;
               if options-&gt;Trans = TRANS or CONJ and equed = 'C' of 'B',
                  B is overwritten by diag(C)*B;
            if A-&gt;Stype = SLU_NR:
               if options-&gt;Trans = NOTRANS and equed = 'C' or 'B',
                  B is overwritten by diag(C)*B;
               if options-&gt;Trans = TRANS or CONJ and equed = 'R' of 'B',
                  B is overwritten by diag(R)*B.</pre><p>
<pre> X       (output) SuperMatrix*
         X has types: Stype = SLU_DN, Dtype = SLU_C, Mtype = SLU_GE. 
         If info = 0 or info = A-&gt;ncol+1, X contains the solution matrix
         to the original system of equations. Note that A and B are modified
         on exit if equed is not 'N', and the solution to the equilibrated
         system is inv(diag(C))*X if options-&gt;Trans = NOTRANS and
         equed = 'C' or 'B', or inv(diag(R))*X if options-&gt;Trans = 'T' or 'C'
         and equed = 'R' or 'B'.</pre><p>
<pre> recip_pivot_growth (output) float*
         The reciprocal pivot growth factor max_j( norm(A_j)/norm(U_j) ).
         The infinity norm is used. If recip_pivot_growth is much less
         than 1, the stability of the LU factorization could be poor.</pre><p>
<pre> rcond   (output) float*
         The estimate of the reciprocal condition number of the matrix A
         after equilibration (if done). If rcond is less than the machine
         precision (in particular, if rcond = 0), the matrix is singular
         to working precision. This condition is indicated by a return
         code of info &gt; 0.</pre><p>
<pre> FERR    (output) float*, dimension (B-&gt;ncol)   
         The estimated forward error bound for each solution vector   
         X(j) (the j-th column of the solution matrix X).   
         If XTRUE is the true solution corresponding to X(j), FERR(j) 
         is an estimated upper bound for the magnitude of the largest 
         element in (X(j) - XTRUE) divided by the magnitude of the   
         largest element in X(j).  The estimate is as reliable as   
         the estimate for RCOND, and is almost always a slight   
         overestimate of the true error.
         If options-&gt;IterRefine = NOREFINE, ferr = 1.0.</pre><p>
<pre> BERR    (output) float*, dimension (B-&gt;ncol)
         The componentwise relative backward error of each solution   
         vector X(j) (i.e., the smallest relative change in   
         any element of A or B that makes X(j) an exact solution).
         If options-&gt;IterRefine = NOREFINE, berr = 1.0.</pre><p>
<pre> mem_usage (output) mem_usage_t*
         Record the memory usage statistics, consisting of following fields:<ul>
<li>for_lu (float)
           The amount of space used in bytes for L data structures.</li><li>total_needed (float)
           The amount of space needed in bytes to perform factorization.</li><li>expansions (int)
           The number of memory expansions during the LU factorization.</li></ul>
</pre><p>
<pre> stat   (output) SuperLUStat_t*
        Record the statistics on runtime and floating-point operation count.
        See <a class="el" href="slu__util_8h.html" title="Utility header file.">slu_util.h</a> for the definition of 'SuperLUStat_t'.</pre><p>
<pre> info    (output) int*
         = 0: successful exit   
         &lt; 0: if info = -i, the i-th argument had an illegal value   
         &gt; 0: if info = i, and i is   
              &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has   
                    been completed, but the factor U is exactly   
                    singular, so the solution and error bounds   
                    could not be computed.   
              = A-&gt;ncol+1: U is nonsingular, but RCOND is less than machine
                    precision, meaning that the matrix is singular to
                    working precision. Nevertheless, the solution and
                    error bounds are computed because there are a number
                    of situations where the computed solution can be more
                    accurate than the value of RCOND would suggest.   
              &gt; A-&gt;ncol+1: number of bytes allocated when memory allocation
                    failure occurred, plus A-&gt;ncol.
 </pre> 
</div>
</div><p>
<a class="anchor" name="1743ff4c80f33a0ae166a61a691c348a"></a><!-- doxytag: member="slu_cdefs.h::cgstrf" ref="1743ff4c80f33a0ae166a61a691c348a" args="(superlu_options_t *, SuperMatrix *, int, int, int *, void *, int, int *, int *, SuperMatrix *, SuperMatrix *, SuperLUStat_t *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgstrf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>relax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>etree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> CGSTRF computes an LU factorization of a general sparse m-by-n
 matrix A using partial pivoting with row interchanges.
 The factorization has the form
     Pr * A = L * U
 where Pr is a row permutation matrix, L is lower triangular with unit
 diagonal elements (lower trapezoidal if A-&gt;nrow &gt; A-&gt;ncol), and U is upper 
 triangular (upper trapezoidal if A-&gt;nrow &lt; A-&gt;ncol).</pre><p>
<pre> See <a class="el" href="supermatrix_8h.html" title="Defines matrix types.">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> options (input) superlu_options_t*
         The structure defines the input parameters to control
         how the LU decomposition will be performed.</pre><p>
<pre> A        (input) SuperMatrix*
	    Original matrix A, permuted by columns, of dimension
          (A-&gt;nrow, A-&gt;ncol). The type of A can be:
          Stype = SLU_NCP; Dtype = SLU_C; Mtype = SLU_GE.</pre><p>
<pre> relax    (input) int
          To control degree of relaxing supernodes. If the number
          of nodes (columns) in a subtree of the elimination tree is less
          than relax, this subtree is considered as one supernode,
          regardless of the row structures of those columns.</pre><p>
<pre> panel_size (input) int
          A panel consists of at most panel_size consecutive columns.</pre><p>
<pre> etree    (input) int*, dimension (A-&gt;ncol)
          Elimination tree of A'*A.
          Note: etree is a vector of parent pointers for a forest whose
          vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.
          On input, the columns of A should be permuted so that the
          etree is in a certain postorder.</pre><p>
<pre> work     (input/output) void*, size (lwork) (in bytes)
          User-supplied work space and space for the output data structures.
          Not referenced if lwork = 0;</pre><p>
<pre> lwork   (input) int
         Specifies the size of work array in bytes.
         = 0:  allocate space internally by system malloc;
         &gt; 0:  use user-supplied work array of length lwork in bytes,
               returns error if space runs out.
         = -1: the routine guesses the amount of space needed without
               performing the factorization, and returns it in
               *info; no other side effects.</pre><p>
<pre> perm_c   (input) int*, dimension (A-&gt;ncol)
	    Column permutation vector, which defines the 
          permutation matrix Pc; perm_c[i] = j means column i of A is 
          in position j in A*Pc.
          When searching for diagonal, perm_c[*] is applied to the
          row subscripts of A, so that diagonal threshold pivoting
          can find the diagonal of A, rather than that of A*Pc.</pre><p>
<pre> perm_r   (input/output) int*, dimension (A-&gt;nrow)
          Row permutation vector which defines the permutation matrix Pr,
          perm_r[i] = j means row i of A is in position j in Pr*A.
          If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
             will try to use the input perm_r, unless a certain threshold
             criterion is violated. In that case, perm_r is overwritten by
             a new permutation determined by partial pivoting or diagonal
             threshold pivoting.
          Otherwise, perm_r is output argument;</pre><p>
<pre> L        (output) SuperMatrix*
          The factor L from the factorization Pr*A=L*U; use compressed row 
          subscripts storage for supernodes, i.e., L has type: 
          Stype = SLU_SC, Dtype = SLU_C, Mtype = SLU_TRLU.</pre><p>
<pre> U        (output) SuperMatrix*
	    The factor U from the factorization Pr*A*Pc=L*U. Use column-wise
          storage scheme, i.e., U has types: Stype = SLU_NC, 
          Dtype = SLU_C, Mtype = SLU_TRU.</pre><p>
<pre> stat     (output) SuperLUStat_t*
          Record the statistics on runtime and floating-point operation count.
          See <a class="el" href="slu__util_8h.html" title="Utility header file.">slu_util.h</a> for the definition of 'SuperLUStat_t'.</pre><p>
<pre> info     (output) int*
          = 0: successful exit
          &lt; 0: if info = -i, the i-th argument had an illegal value
          &gt; 0: if info = i, and i is
             &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
                been completed, but the factor U is exactly singular,
                and division by zero will occur if it is used to solve a
                system of equations.
             &gt; A-&gt;ncol: number of bytes allocated when memory allocation
                failure occurred, plus A-&gt;ncol. If lwork = -1, it is
                the estimated amount of space needed, plus A-&gt;ncol.</pre><p>
<pre> ======================================================================</pre><p>
<pre> Local Working Arrays: 
 ======================
   m = number of rows in the matrix
   n = number of columns in the matrix</pre><p>
<pre>   xprune[0:n-1]: xprune[*] points to locations in subscript 
	vector lsub[*]. For column i, xprune[i] denotes the point where 
	structural pruning begins. I.e. only xlsub[i],..,xprune[i]-1 need 
	to be traversed for symbolic factorization.</pre><p>
<pre>   marker[0:3*m-1]: marker[i] = j means that node i has been 
	reached when working on column j.
	Storage: relative to original row subscripts
	NOTE: There are 3 of them: marker/marker1 are used for panel dfs, 
	      see <a class="el" href="cpanel__dfs_8c.html" title="Peforms a symbolic factorization on a panel of symbols.">cpanel_dfs.c</a>; marker2 is used for inner-factorization,
            see <a class="el" href="ccolumn__dfs_8c.html" title="Performs a symbolic factorization.">ccolumn_dfs.c</a>.</pre><p>
<pre>   parent[0:m-1]: parent vector used during dfs
      Storage: relative to new row subscripts</pre><p>
<pre>   xplore[0:m-1]: xplore[i] gives the location of the next (dfs) 
	unexplored neighbor of i in lsub[*]</pre><p>
<pre>   segrep[0:nseg-1]: contains the list of supernodal representatives
	in topological order of the dfs. A supernode representative is the 
	last column of a supernode.
      The maximum size of segrep[] is n.</pre><p>
<pre>   repfnz[0:W*m-1]: for a nonzero segment U[*,j] that ends at a 
	supernodal representative r, repfnz[r] is the location of the first 
	nonzero in this segment.  It is also used during the dfs: repfnz[r]&gt;0
	indicates the supernode r has been explored.
	NOTE: There are W of them, each used for one column of a panel.</pre><p>
<pre>   panel_lsub[0:W*m-1]: temporary for the nonzeros row indices below 
      the panel diagonal. These are filled in during <a class="el" href="cpanel__dfs_8c.html#052edfd06c5aeab7a37b5fa558a06602">cpanel_dfs()</a>, and are
      used later in the inner LU factorization within the panel.
	panel_lsub[]/dense[] pair forms the SPA data structure.
	NOTE: There are W of them.</pre><p>
<pre>   dense[0:W*m-1]: sparse accumulating (SPA) vector for intermediate values;
	    	   NOTE: there are W of them.</pre><p>
<pre>   tempv[0:*]: real temporary used for dense numeric kernels;
	The size of this array is defined by <a class="el" href="slu__util_8h.html#06193b28f40a4779ae7737711642eb45">NUM_TEMPV()</a> in <a class="el" href="slu__cdefs_8h.html" title="Header file for real operations.">slu_cdefs.h</a>.
 </pre> 
</div>
</div><p>
<a class="anchor" name="a45033d577ad2afbe488a837d6aba8cf"></a><!-- doxytag: member="slu_cdefs.h::cgstrs" ref="a45033d577ad2afbe488a837d6aba8cf" args="(trans_t, SuperMatrix *, SuperMatrix *, int *, int *, SuperMatrix *, SuperLUStat_t *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgstrs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>&nbsp;</td>
          <td class="paramname"> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> CGSTRS solves a system of linear equations A*X=B or A'*X=B
 with A sparse and B dense, using the LU factorization computed by
 CGSTRF.</pre><p>
<pre> See <a class="el" href="supermatrix_8h.html" title="Defines matrix types.">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> trans   (input) trans_t
          Specifies the form of the system of equations:
          = NOTRANS: A * X = B  (No transpose)
          = TRANS:   A'* X = B  (Transpose)
          = CONJ:    A**H * X = B  (Conjugate transpose)</pre><p>
<pre> L       (input) SuperMatrix*
         The factor L from the factorization Pr*A*Pc=L*U as computed by
         <a class="el" href="cgstrf_8c.html#9c9f2ce12946612c7426a10352ac5984">cgstrf()</a>. Use compressed row subscripts storage for supernodes,
         i.e., L has types: Stype = SLU_SC, Dtype = SLU_C, Mtype = SLU_TRLU.</pre><p>
<pre> U       (input) SuperMatrix*
         The factor U from the factorization Pr*A*Pc=L*U as computed by
         <a class="el" href="cgstrf_8c.html#9c9f2ce12946612c7426a10352ac5984">cgstrf()</a>. Use column-wise storage scheme, i.e., U has types:
         Stype = SLU_NC, Dtype = SLU_C, Mtype = SLU_TRU.</pre><p>
<pre> perm_c  (input) int*, dimension (L-&gt;ncol)
	   Column permutation vector, which defines the 
         permutation matrix Pc; perm_c[i] = j means column i of A is 
         in position j in A*Pc.</pre><p>
<pre> perm_r  (input) int*, dimension (L-&gt;nrow)
         Row permutation vector, which defines the permutation matrix Pr; 
         perm_r[i] = j means row i of A is in position j in Pr*A.</pre><p>
<pre> B       (input/output) SuperMatrix*
         B has types: Stype = SLU_DN, Dtype = SLU_C, Mtype = SLU_GE.
         On entry, the right hand side matrix.
         On exit, the solution matrix if info = 0;</pre><p>
<pre> stat     (output) SuperLUStat_t*
          Record the statistics on runtime and floating-point operation count.
          See util.h for the definition of 'SuperLUStat_t'.</pre><p>
<pre> info    (output) int*
 	   = 0: successful exit
	   &lt; 0: if info = -i, the i-th argument had an illegal value
 </pre> 
</div>
</div><p>
<a class="anchor" name="2cfc97393b65ddc5a40fdc523a50003a"></a><!-- doxytag: member="slu_cdefs.h::check_tempv" ref="2cfc97393b65ddc5a40fdc523a50003a" args="(int, complex *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_tempv           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="293818022b119a511598f4766c54a1ee"></a><!-- doxytag: member="slu_cdefs.h::cinf_norm_error" ref="293818022b119a511598f4766c54a1ee" args="(int, SuperMatrix *, complex *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cinf_norm_error           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="dbc57dc56d0c962aa148a573895883b0"></a><!-- doxytag: member="slu_cdefs.h::claqgs" ref="dbc57dc56d0c962aa148a573895883b0" args="(SuperMatrix *, float *, float *, float, float, float, char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void claqgs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>rowcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>colcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>equed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
   Purpose   
   =======</pre><p>
<pre>   CLAQGS equilibrates a general sparse M by N matrix A using the row and   
   scaling factors in the vectors R and C.</pre><p>
<pre>   See <a class="el" href="supermatrix_8h.html" title="Defines matrix types.">supermatrix.h</a> for the definition of 'SuperMatrix' structure.</pre><p>
<pre>   Arguments   
   =========</pre><p>
<pre>   A       (input/output) SuperMatrix*
           On exit, the equilibrated matrix.  See EQUED for the form of 
           the equilibrated matrix. The type of A can be:
	    Stype = NC; Dtype = SLU_C; Mtype = GE.</pre><p>
<pre>   R       (input) float*, dimension (A-&gt;nrow)
           The row scale factors for A.</pre><p>
<pre>   C       (input) float*, dimension (A-&gt;ncol)
           The column scale factors for A.</pre><p>
<pre>   ROWCND  (input) float
           Ratio of the smallest R(i) to the largest R(i).</pre><p>
<pre>   COLCND  (input) float
           Ratio of the smallest C(i) to the largest C(i).</pre><p>
<pre>   AMAX    (input) float
           Absolute value of largest matrix entry.</pre><p>
<pre>   EQUED   (output) char*
           Specifies the form of equilibration that was done.   
           = 'N':  No equilibration   
           = 'R':  Row equilibration, i.e., A has been premultiplied by  
                   diag(R).   
           = 'C':  Column equilibration, i.e., A has been postmultiplied  
                   by diag(C).   
           = 'B':  Both row and column equilibration, i.e., A has been
                   replaced by diag(R) * A * diag(C).</pre><p>
<pre>   Internal Parameters   
   ===================</pre><p>
<pre>   THRESH is a threshold value used to decide if row or column scaling   
   should be done based on the ratio of the row or column scaling   
   factors.  If ROWCND &lt; THRESH, row scaling is done, and if   
   COLCND &lt; THRESH, column scaling is done.</pre><p>
<pre>   LARGE and SMALL are threshold values used to decide if row scaling   
   should be done based on the absolute size of the largest matrix   
   element.  If AMAX &gt; LARGE or AMAX &lt; SMALL, row scaling is done.</pre><p>
<pre>   ===================================================================== 
 </pre> 
</div>
</div><p>
<a class="anchor" name="c7a85f8c55c71b4f4d454c4d62ffbfae"></a><!-- doxytag: member="slu_cdefs.h::cldperm" ref="c7a85f8c55c71b4f4d454c4d62ffbfae" args="(int, int, int, int[], int[], complex[], int[], float[], float[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cldperm           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&nbsp;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname">[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0f124ea0294cce1fb4c467b1d63ac209"></a><!-- doxytag: member="slu_cdefs.h::cLUMemInit" ref="0f124ea0294cce1fb4c467b1d63ac209" args="(fact_t, void *, int, int, int, int, int, float, SuperMatrix *, SuperMatrix *, GlobalLU_t *, int **, complex **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cLUMemInit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#c785c8235480e5cfef9848d89c047c0a">fact_t</a>&nbsp;</td>
          <td class="paramname"> <em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>annz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>fill_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"> <em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> **&nbsp;</td>
          <td class="paramname"> <em>dwork</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Memory-related.<p>
<pre>
 For those unpredictable size, estimate as fill_ratio * nnz(A).
 Return value:
     If lwork = -1, return the estimated amount of space required, plus n;
     otherwise, return the amount of space actually allocated when
     memory allocation failure occurred.
 </pre> 
</div>
</div><p>
<a class="anchor" name="255ed62863700298939edfda48ae534a"></a><!-- doxytag: member="slu_cdefs.h::cLUMemXpand" ref="255ed62863700298939edfda48ae534a" args="(int, int, MemType, int *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cLUMemXpand           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#bd31f838aefffa46191d0d7dc36a96b2">MemType</a>&nbsp;</td>
          <td class="paramname"> <em>mem_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Glu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Return value:   0 - successful return
               &gt; 0 - number of bytes allocated when run out of space
 </pre> 
</div>
</div><p>
<a class="anchor" name="a759583daf08db801cf6fe8018442d4c"></a><!-- doxytag: member="slu_cdefs.h::cLUWorkFree" ref="a759583daf08db801cf6fe8018442d4c" args="(int *, complex *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cLUWorkFree           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cea36c2598bb3f8a27b6985634d2b8e9"></a><!-- doxytag: member="slu_cdefs.h::cmemory_usage" ref="cea36c2598bb3f8a27b6985634d2b8e9" args="(const int, const int, const int, const int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cmemory_usage           </td>
          <td>(</td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>int</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f558e3813415369a8805c473a7eaa5e8"></a><!-- doxytag: member="slu_cdefs.h::complexCalloc" ref="f558e3813415369a8805c473a7eaa5e8" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex.html">complex</a>* complexCalloc           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="db98fa14a907e0e848a35e896d4040db"></a><!-- doxytag: member="slu_cdefs.h::complexMalloc" ref="db98fa14a907e0e848a35e896d4040db" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex.html">complex</a>* complexMalloc           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8086902aa8be3fc7d04c3c82ec3a79dc"></a><!-- doxytag: member="slu_cdefs.h::countnz" ref="8086902aa8be3fc7d04c3c82ec3a79dc" args="(const int, int *, int *, int *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void countnz           </td>
          <td>(</td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c37d9a28b8745daf72ae1d5ad29c140d"></a><!-- doxytag: member="slu_cdefs.h::cpanel_bmod" ref="c37d9a28b8745daf72ae1d5ad29c140d" args="(const int, const int, const int, const int, complex *, complex *, int *, int *, GlobalLU_t *, SuperLUStat_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpanel_bmod           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname"> <em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname"> <em>tempv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======</pre><p>
<pre>    Performs numeric block updates (sup-panel) in topological order.
    It features: col-col, 2cols-col, 3cols-col, and sup-col updates.
    Special processing on the supernodal portion of L[*,j]</pre><p>
<pre>    Before entering this routine, the original nonzeros in the panel 
    were already copied into the spa[m,w].</pre><p>
<pre>    Updated/Output parameters-
    dense[0:m-1,w]: L[*,j:j+w-1] and U[*,j:j+w-1] are returned 
    collectively in the m-by-w vector dense[*]. 
 </pre> 
</div>
</div><p>
<a class="anchor" name="780968651deed587e187bd7661edbb20"></a><!-- doxytag: member="slu_cdefs.h::cpanel_dfs" ref="780968651deed587e187bd7661edbb20" args="(const int, const int, const int, SuperMatrix *, int *, int *, complex *, int *, int *, int *, int *, int *, int *, int *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpanel_dfs           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname"> <em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panel_lsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Glu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======</pre><p>
<pre>   Performs a symbolic factorization on a panel of columns [jcol, jcol+w).</pre><p>
<pre>   A supernode representative is the last column of a supernode.
   The nonzeros in U[*,j] are segments that end at supernodal
   representatives.</pre><p>
<pre>   The routine returns one list of the supernodal representatives
   in topological order of the dfs that generates them. This list is
   a superset of the topological order of each individual column within
   the panel. 
   The location of the first nonzero in each supernodal segment
   (supernodal entry location) is also returned. Each column has a 
   separate list for this purpose.</pre><p>
<pre>   Two marker arrays are used for dfs:
     marker[i] == jj, if i was visited during dfs of current column jj;
     marker1[i] &gt;= jcol, if i was visited by earlier columns in this panel;</pre><p>
<pre>   marker: A-row --&gt; A-row/col (0/1)
   repfnz: SuperA-col --&gt; PA-row
   parent: SuperA-col --&gt; SuperA-col
   xplore: SuperA-col --&gt; index to L-structure
 </pre> 
</div>
</div><p>
<a class="anchor" name="9a5b1cc4e96708825cc21108ebbeb061"></a><!-- doxytag: member="slu_cdefs.h::cPivotGrowth" ref="9a5b1cc4e96708825cc21108ebbeb061" args="(int, SuperMatrix *, int *, SuperMatrix *, SuperMatrix *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cPivotGrowth           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======</pre><p>
<pre> Compute the reciprocal pivot growth factor of the leading ncols columns
 of the matrix, using the formula:
     min_j ( max_i(<a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(A_ij)</a>) / max_i(<a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(U_ij)</a>) )</pre><p>
<pre> Arguments
 =========</pre><p>
<pre> ncols    (input) int
          The number of columns of matrices A, L and U.</pre><p>
<pre> A        (input) SuperMatrix*
	    Original matrix A, permuted by columns, of dimension
          (A-&gt;nrow, A-&gt;ncol). The type of A can be:
          Stype = NC; Dtype = SLU_C; Mtype = GE.</pre><p>
<pre> L        (output) SuperMatrix*
          The factor L from the factorization Pr*A=L*U; use compressed row 
          subscripts storage for supernodes, i.e., L has type: 
          Stype = SC; Dtype = SLU_C; Mtype = TRLU.</pre><p>
<pre> U        (output) SuperMatrix*
	    The factor U from the factorization Pr*A*Pc=L*U. Use column-wise
          storage scheme, i.e., U has types: Stype = NC;
          Dtype = SLU_C; Mtype = TRU.
 </pre> 
</div>
</div><p>
<a class="anchor" name="4a31e35e95f28f69549ffa45bebd4499"></a><!-- doxytag: member="slu_cdefs.h::cpivotL" ref="4a31e35e95f28f69549ffa45bebd4499" args="(const int, const double, int *, int *, int *, int *, int *, GlobalLU_t *, SuperLUStat_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpivotL           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>usepr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>iperm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>iperm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======
   Performs the numerical pivoting on the current column of L,
   and the CDIV operation.</pre><p>
<pre>   Pivot policy:
   (1) Compute thresh = u * max_(i&gt;=j) <a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(A_ij)</a>;
   (2) IF user specifies pivot row k and <a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(A_kj)</a> &gt;= thresh THEN
           pivot row = k;
       ELSE IF <a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(A_jj)</a> &gt;= thresh THEN
           pivot row = j;
       ELSE
           pivot row = m;</pre><p>
<pre>   Note: If you absolutely want to use a given pivot order, then set u=0.0.</pre><p>
<pre>   Return value: 0      success;
                 i &gt; 0  U(i,i) is exactly zero.
 </pre> 
</div>
</div><p>
<a class="anchor" name="f091472c1fb3c085c384bf52b3bebd8d"></a><!-- doxytag: member="slu_cdefs.h::cPrint_CompCol_Matrix" ref="f091472c1fb3c085c384bf52b3bebd8d" args="(char *, SuperMatrix *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cPrint_CompCol_Matrix           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1cbad8400b16c776b112f20b8645757d"></a><!-- doxytag: member="slu_cdefs.h::cPrint_Dense_Matrix" ref="1cbad8400b16c776b112f20b8645757d" args="(char *, SuperMatrix *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cPrint_Dense_Matrix           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4f43048c524cbdac07232ab635e67364"></a><!-- doxytag: member="slu_cdefs.h::cprint_lu_col" ref="4f43048c524cbdac07232ab635e67364" args="(char *, int, int, int *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cprint_lu_col           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8482f76b710a91d26250bca719b9d00c"></a><!-- doxytag: member="slu_cdefs.h::cPrint_SuperNode_Matrix" ref="8482f76b710a91d26250bca719b9d00c" args="(char *, SuperMatrix *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cPrint_SuperNode_Matrix           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="65d7df9e58c2415f455dbe6db9a99f2b"></a><!-- doxytag: member="slu_cdefs.h::cpruneL" ref="65d7df9e58c2415f455dbe6db9a99f2b" args="(const int, const int *, const int, const int, const int *, const int *, int *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpruneL           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Glu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======
   Prunes the L-structure of supernodes whose L-structure
   contains the current pivot row "pivrow"
 </pre> 
</div>
</div><p>
<a class="anchor" name="7ac9ff71eef6bf8c52c41eb9209a0caf"></a><!-- doxytag: member="slu_cdefs.h::cQuerySpace" ref="7ac9ff71eef6bf8c52c41eb9209a0caf" args="(SuperMatrix *, SuperMatrix *, mem_usage_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cQuerySpace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mem_usage</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 mem_usage consists of the following fields:<ul>
<li>for_lu (float)
      The amount of space used in bytes for the L data structures.</li><li>total_needed (float)
      The amount of space needed in bytes to perform factorization.
 
</li></ul>
</pre>
</div>
</div><p>
<a class="anchor" name="34243c626347c973358d3d095802783b"></a><!-- doxytag: member="slu_cdefs.h::creadhb" ref="34243c626347c973358d3d095802783b" args="(int *, int *, int *, complex **, int **, int **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void creadhb           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="88701835280a367a90b9ea2a73f946f0"></a><!-- doxytag: member="slu_cdefs.h::creadmt" ref="88701835280a367a90b9ea2a73f946f0" args="(int *, int *, int *, complex **, int **, int **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void creadmt           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0cce050053c795f6b9c52174008bf775"></a><!-- doxytag: member="slu_cdefs.h::creadrb" ref="0cce050053c795f6b9c52174008bf775" args="(int *, int *, int *, complex **, int **, int **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void creadrb           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7c84a33df79e533f6167e4a1e9ce89cb"></a><!-- doxytag: member="slu_cdefs.h::creadtriple" ref="7c84a33df79e533f6167e4a1e9ce89cb" args="(int *, int *, int *, complex **, int **, int **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void creadtriple           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f3bbcd362fb260a0dba5488a3e4ee926"></a><!-- doxytag: member="slu_cdefs.h::cSetRWork" ref="f3bbcd362fb260a0dba5488a3e4ee926" args="(int, int, complex *, complex **, complex **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSetRWork           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> **&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ab1987caf36c8eedcf605b59e56a9d5d"></a><!-- doxytag: member="slu_cdefs.h::csnode_bmod" ref="ab1987caf36c8eedcf605b59e56a9d5d" args="(const int, const int, const int, complex *, complex *, GlobalLU_t *, SuperLUStat_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csnode_bmod           </td>
          <td>(</td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c98da7d6b5809dadb1cae9bc019619ce"></a><!-- doxytag: member="slu_cdefs.h::csnode_dfs" ref="c98da7d6b5809dadb1cae9bc019619ce" args="(const int, const int, const int *, const int *, const int *, int *, int *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csnode_dfs           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>kcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>asub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>xa_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>xa_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Glu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======
    <a class="el" href="csnode__dfs_8c.html#1c7b34abd214279177619773ad24b759">csnode_dfs()</a> - Determine the union of the row structures of those 
    columns within the relaxed snode.
    Note: The relaxed snodes are leaves of the supernodal etree, therefore, 
    the portion outside the rectangular supernode must be zero.</pre><p>
<pre> Return value
 ============
     0   success;
    &gt;0   number of bytes allocated when run out of memory.
 </pre> 
</div>
</div><p>
<a class="anchor" name="7061332d759d7e4d73c1b2e5cb0bf2bf"></a><!-- doxytag: member="slu_cdefs.h::fixupL" ref="7061332d759d7e4d73c1b2e5cb0bf2bf" args="(const int, const int *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fixupL           </td>
          <td>(</td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3e1230bff11a9e47c35555299bcdcf1b"></a><!-- doxytag: member="slu_cdefs.h::floatCalloc" ref="3e1230bff11a9e47c35555299bcdcf1b" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* floatCalloc           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="42361c3ce2ba81d149ffba01fbd6f138"></a><!-- doxytag: member="slu_cdefs.h::floatMalloc" ref="42361c3ce2ba81d149ffba01fbd6f138" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* floatMalloc           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="94b01af5a7e93ca2cc3cf52717e767a0"></a><!-- doxytag: member="slu_cdefs.h::ilu_ccolumn_dfs" ref="94b01af5a7e93ca2cc3cf52717e767a0" args="(const int, const int, int *, int *, int *, int *, int *, int *, int *, int *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_ccolumn_dfs           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>lsub_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Glu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======
   ILU_CCOLUMN_DFS performs a symbolic factorization on column jcol, and
   decide the supernode boundary.</pre><p>
<pre>   This routine does not use numeric values, but only use the RHS
   row indices to start the dfs.</pre><p>
<pre>   A supernode representative is the last column of a supernode.
   The nonzeros in U[*,j] are segments that end at supernodal
   representatives. The routine returns a list of such supernodal
   representatives in topological order of the dfs that generates them.
   The location of the first nonzero in each such supernodal segment
   (supernodal entry location) is also returned.</pre><p>
<pre> Local parameters
 ================
   nseg: no of segments in current U[*,j]
   jsuper: jsuper=EMPTY if column j does not belong to the same
	supernode as j-1. Otherwise, jsuper=nsuper.</pre><p>
<pre>   marker2: A-row --&gt; A-row/col (0/1)
   repfnz: SuperA-col --&gt; PA-row
   parent: SuperA-col --&gt; SuperA-col
   xplore: SuperA-col --&gt; index to L-structure</pre><p>
<pre> Return value
 ============
     0  success;
   &gt; 0  number of bytes allocated when run out of space.
 </pre> 
</div>
</div><p>
<a class="anchor" name="a9bf5072c6b1c6803b1dba973ac4be3e"></a><!-- doxytag: member="slu_cdefs.h::ilu_ccopy_to_ucol" ref="a9bf5072c6b1c6803b1dba973ac4be3e" args="(int, int, int *, int *, int *, complex *, int, milu_t, double, int, complex *, int *, GlobalLU_t *, float *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_ccopy_to_ucol           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#0cb73c13a7c2390c3a9a0a8913477ff0">milu_t</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cf639d4fcc71c90f3e966b47787ad834"></a><!-- doxytag: member="slu_cdefs.h::ilu_cdrop_row" ref="cf639d4fcc71c90f3e966b47787ad834" args="(superlu_options_t *, int, int, double, int, int *, double *, GlobalLU_t *, float *, float *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_cdrop_row           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ae8eb367a0a2fcdf734738bc9630df85"></a><!-- doxytag: member="slu_cdefs.h::ilu_countnz" ref="ae8eb367a0a2fcdf734738bc9630df85" args="(const int, int *, int *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilu_countnz           </td>
          <td>(</td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9f427fadf45d56409840775c99ce8967"></a><!-- doxytag: member="slu_cdefs.h::ilu_cpanel_dfs" ref="9f427fadf45d56409840775c99ce8967" args="(const int, const int, const int, SuperMatrix *, int *, int *, complex *, float *, int *, int *, int *, int *, int *, int *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilu_cpanel_dfs           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname"> <em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panel_lsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Glu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======</pre><p>
<pre>   Performs a symbolic factorization on a panel of columns [jcol, jcol+w).</pre><p>
<pre>   A supernode representative is the last column of a supernode.
   The nonzeros in U[*,j] are segments that end at supernodal
   representatives.</pre><p>
<pre>   The routine returns one list of the supernodal representatives
   in topological order of the dfs that generates them. This list is
   a superset of the topological order of each individual column within
   the panel.
   The location of the first nonzero in each supernodal segment
   (supernodal entry location) is also returned. Each column has a
   separate list for this purpose.</pre><p>
<pre>   Two marker arrays are used for dfs:
     marker[i] == jj, if i was visited during dfs of current column jj;
     marker1[i] &gt;= jcol, if i was visited by earlier columns in this panel;</pre><p>
<pre>   marker: A-row --&gt; A-row/col (0/1)
   repfnz: SuperA-col --&gt; PA-row
   parent: SuperA-col --&gt; SuperA-col
   xplore: SuperA-col --&gt; index to L-structure
 </pre> 
</div>
</div><p>
<a class="anchor" name="c4edc9f45dad6dd53caca13240690633"></a><!-- doxytag: member="slu_cdefs.h::ilu_cpivotL" ref="c4edc9f45dad6dd53caca13240690633" args="(const int, const double, int *, int *, int, int *, int *, int *, int *, double, milu_t, complex, GlobalLU_t *, SuperLUStat_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_cpivotL           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>usepr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>diagind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>iswap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>fill_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#0cb73c13a7c2390c3a9a0a8913477ff0">milu_t</a>&nbsp;</td>
          <td class="paramname"> <em>milu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&nbsp;</td>
          <td class="paramname"> <em>drop_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======
   Performs the numerical pivoting on the current column of L,
   and the CDIV operation.</pre><p>
<pre>   Pivot policy:
   (1) Compute thresh = u * max_(i&gt;=j) <a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(A_ij)</a>;
   (2) IF user specifies pivot row k and <a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(A_kj)</a> &gt;= thresh THEN
	     pivot row = k;
	 ELSE IF <a class="el" href="slamch_8c.html#3aa069ac3980707dae1e0530f50d59e4">abs(A_jj)</a> &gt;= thresh THEN
	     pivot row = j;
	 ELSE
	     pivot row = m;</pre><p>
<pre>   Note: If you absolutely want to use a given pivot order, then set u=0.0.</pre><p>
<pre>   Return value: 0	  success;
		   i &gt; 0  U(i,i) is exactly zero.
 </pre> 
</div>
</div><p>
<a class="anchor" name="97e43257315ae194779ffe9c3dc9c213"></a><!-- doxytag: member="slu_cdefs.h::ilu_cQuerySpace" ref="97e43257315ae194779ffe9c3dc9c213" args="(SuperMatrix *, SuperMatrix *, mem_usage_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_cQuerySpace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mem_usage</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 mem_usage consists of the following fields:<ul>
<li>for_lu (float)
      The amount of space used in bytes for the L data structures.</li><li>total_needed (float)
      The amount of space needed in bytes to perform factorization.
 
</li></ul>
</pre>
</div>
</div><p>
<a class="anchor" name="c4e46d9d75c94503e94b4599960479d7"></a><!-- doxytag: member="slu_cdefs.h::ilu_csnode_dfs" ref="c4e46d9d75c94503e94b4599960479d7" args="(const int, const int, const int *, const int *, const int *, int *, GlobalLU_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_csnode_dfs           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>kcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>asub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>xa_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>xa_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Glu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose
 =======
    <a class="el" href="ilu__csnode__dfs_8c.html#a6c4a4029db106e8dd56bc0fe1f0090b">ilu_csnode_dfs()</a> - Determine the union of the row structures of those
    columns within the relaxed snode.
    Note: The relaxed snodes are leaves of the supernodal etree, therefore,
    the portion outside the rectangular supernode must be zero.</pre><p>
<pre> Return value
 ============
     0   success;
    &gt;0   number of bytes allocated when run out of memory.
 </pre> 
</div>
</div><p>
<a class="anchor" name="ad0c06e9adc1e29a0ab2e78c38119bb4"></a><!-- doxytag: member="slu_cdefs.h::print_double_vec" ref="ad0c06e9adc1e29a0ab2e78c38119bb4" args="(char *, int, double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int print_double_vec           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7a41152a5800bc02bef17b56e070d0e6"></a><!-- doxytag: member="slu_cdefs.h::PrintPerf" ref="7a41152a5800bc02bef17b56e070d0e6" args="(SuperMatrix *, SuperMatrix *, mem_usage_t *, complex, complex, complex *, complex *, char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrintPerf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="47c1dd1b8332f4366d5c5112219fdb3a"></a><!-- doxytag: member="slu_cdefs.h::slamch_" ref="47c1dd1b8332f4366d5c5112219fdb3a" args="(char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float slamch_           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>cmach</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose   
    =======</pre><p>
<pre>    SLAMCH determines single precision machine parameters.</pre><p>
<pre>    Arguments   
    =========</pre><p>
<pre>    CMACH   (input) CHARACTER*1   
            Specifies the value to be returned by SLAMCH:   
            = 'E' or 'e',   SLAMCH := eps   
            = 'S' or 's ,   SLAMCH := sfmin   
            = 'B' or 'b',   SLAMCH := base   
            = 'P' or 'p',   SLAMCH := eps*base   
            = 'N' or 'n',   SLAMCH := t   
            = 'R' or 'r',   SLAMCH := rnd   
            = 'M' or 'm',   SLAMCH := emin   
            = 'U' or 'u',   SLAMCH := rmin   
            = 'L' or 'l',   SLAMCH := emax   
            = 'O' or 'o',   SLAMCH := rmax</pre><p>
<pre>            where</pre><p>
<pre>            eps   = relative machine precision   
            sfmin = safe minimum, such that 1/sfmin does not overflow   
            base  = base of the machine   
            prec  = eps*base   
            t     = number of (base) digits in the mantissa   
            rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise   
            emin  = minimum exponent before (gradual) underflow   
            rmin  = underflow threshold - base**(emin-1)   
            emax  = largest exponent before overflow   
            rmax  = overflow threshold  - (base**emax)*(1-eps)</pre><p>
<pre>   ===================================================================== 
</pre> 
</div>
</div><p>
<a class="anchor" name="0473a1696817ed02c501ca8af8ff0285"></a><!-- doxytag: member="slu_cdefs.h::sp_cgemm" ref="0473a1696817ed02c501ca8af8ff0285" args="(char *, char *, int, int, int, complex, SuperMatrix *, complex *, int, complex, complex *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sp_cgemm           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>transa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>transb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&nbsp;</td>
          <td class="paramname"> <em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ldc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Purpose   
   =======</pre><p>
<pre>   sp_c performs one of the matrix-matrix operations</pre><p>
<pre>      C := alpha*op( A )*op( B ) + beta*C,</pre><p>
<pre>   where  op( X ) is one of</pre><p>
<pre>      op( X ) = X   or   op( X ) = X'   or   op( X ) = conjg( X' ),</pre><p>
<pre>   alpha and beta are scalars, and A, B and C are matrices, with op( A ) 
   an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</pre><p>
<pre>   Parameters   
   ==========</pre><p>
<pre>   TRANSA - (input) char*
            On entry, TRANSA specifies the form of op( A ) to be used in 
            the matrix multiplication as follows:   
               TRANSA = 'N' or 'n',  op( A ) = A.   
               TRANSA = 'T' or 't',  op( A ) = A'.   
               TRANSA = 'C' or 'c',  op( A ) = conjg( A' ).   
            Unchanged on exit.</pre><p>
<pre>   TRANSB - (input) char*
            On entry, TRANSB specifies the form of op( B ) to be used in 
            the matrix multiplication as follows:   
               TRANSB = 'N' or 'n',  op( B ) = B.   
               TRANSB = 'T' or 't',  op( B ) = B'.   
               TRANSB = 'C' or 'c',  op( B ) = conjg( B' ).   
            Unchanged on exit.</pre><p>
<pre>   M      - (input) int   
            On entry,  M  specifies  the number of rows of the matrix 
	     op( A ) and of the matrix C.  M must be at least zero. 
	     Unchanged on exit.</pre><p>
<pre>   N      - (input) int
            On entry,  N specifies the number of columns of the matrix 
	     op( B ) and the number of columns of the matrix C. N must be 
	     at least zero.
	     Unchanged on exit.</pre><p>
<pre>   K      - (input) int
            On entry, K specifies the number of columns of the matrix 
	     op( A ) and the number of rows of the matrix op( B ). K must 
	     be at least  zero.   
           Unchanged on exit.</pre><p>
<pre>   ALPHA  - (input) <a class="el" href="structcomplex.html">complex</a>
            On entry, ALPHA specifies the scalar alpha.</pre><p>
<pre>   A      - (input) SuperMatrix*
            Matrix A with a sparse format, of dimension (A-&gt;nrow, A-&gt;ncol).
            Currently, the type of A can be:
                Stype = NC or NCP; Dtype = SLU_C; Mtype = GE. 
            In the future, more general A can be handled.</pre><p>
<pre>   B      - COMPLEX PRECISION array of DIMENSION ( LDB, kb ), where kb is 
            n when TRANSB = 'N' or 'n',  and is  k otherwise.   
            Before entry with  TRANSB = 'N' or 'n',  the leading k by n 
            part of the array B must contain the matrix B, otherwise 
            the leading n by k part of the array B must contain the 
            matrix B.   
            Unchanged on exit.</pre><p>
<pre>   LDB    - (input) int
            On entry, LDB specifies the first dimension of B as declared 
            in the calling (sub) program. LDB must be at least <a class="el" href="slamch_8c.html#ffe776513b24d84b39af8ab0930fef7f">max( 1, n )</a>.  
            Unchanged on exit.</pre><p>
<pre>   BETA   - (input) <a class="el" href="structcomplex.html">complex</a>
            On entry, BETA specifies the scalar beta. When BETA is   
            supplied as zero then C need not be set on input.</pre><p>
<pre>   C      - COMPLEX PRECISION array of DIMENSION ( LDC, n ).   
            Before entry, the leading m by n part of the array C must 
            contain the matrix C,  except when beta is zero, in which 
            case C need not be set on entry.   
            On exit, the array C is overwritten by the m by n matrix 
	     ( alpha*op( A )*B + beta*C ).</pre><p>
<pre>   LDC    - (input) int
            On entry, LDC specifies the first dimension of C as declared 
            in the calling (sub)program. LDC must be at least <a class="el" href="slamch_8c.html#ffe776513b24d84b39af8ab0930fef7f">max(1,m)</a>.   
            Unchanged on exit.</pre><p>
<pre>   ==== Sparse Level 3 Blas routine.   
 </pre> 
</div>
</div><p>
<a class="anchor" name="59e320a29e9ded59a46e8d64619ffac6"></a><!-- doxytag: member="slu_cdefs.h::sp_cgemv" ref="59e320a29e9ded59a46e8d64619ffac6" args="(char *, complex, SuperMatrix *, complex *, int, complex, complex *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sp_cgemv           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&nbsp;</td>
          <td class="paramname"> <em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>incy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>  
   Purpose   
   =======</pre><p>
<pre>   <a class="el" href="csp__blas2_8c.html#1adbbd2f478e6a22843d82a07d42fb63" title="Performs one of the matrix-vector operations y := alpha*A*x + beta*y, or y := alpha*A&#39;*x...">sp_cgemv()</a>  performs one of the matrix-vector operations   
      y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   
   where alpha and beta are scalars, x and y are vectors and A is a
   sparse A-&gt;nrow by A-&gt;ncol matrix.</pre><p>
<pre>   Parameters   
   ==========</pre><p>
<pre>   TRANS  - (input) char*
            On entry, TRANS specifies the operation to be performed as   
            follows:   
               TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.   
               TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.   
               TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.</pre><p>
<pre>   ALPHA  - (input) <a class="el" href="structcomplex.html">complex</a>
            On entry, ALPHA specifies the scalar alpha.</pre><p>
<pre>   A      - (input) SuperMatrix*
            Before entry, the leading m by n part of the array A must   
            contain the matrix of coefficients.</pre><p>
<pre>   X      - (input) complex*, array of DIMENSION at least   
            ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'   
           and at least   
            ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.   
            Before entry, the incremented array X must contain the   
            vector x.</pre><p>
<pre>   INCX   - (input) int
            On entry, INCX specifies the increment for the elements of   
            X. INCX must not be zero.</pre><p>
<pre>   BETA   - (input) <a class="el" href="structcomplex.html">complex</a>
            On entry, BETA specifies the scalar beta. When BETA is   
            supplied as zero then Y need not be set on input.</pre><p>
<pre>   Y      - (output) complex*,  array of DIMENSION at least   
            ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'   
            and at least   
            ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.   
            Before entry with BETA non-zero, the incremented array Y   
            must contain the vector y. On exit, Y is overwritten by the 
            updated vector y.</pre><p>
<pre>   INCY   - (input) int
            On entry, INCY specifies the increment for the elements of   
            Y. INCY must not be zero.</pre><p>
<pre>    ==== Sparse Level 2 Blas routine.   
 </pre> 
</div>
</div><p>
<a class="anchor" name="8299a994a223b7178314fe7faff74508"></a><!-- doxytag: member="slu_cdefs.h::sp_ctrsv" ref="8299a994a223b7178314fe7faff74508" args="(char *, char *, char *, SuperMatrix *, SuperMatrix *, complex *, SuperLUStat_t *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sp_ctrsv           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
   Purpose
   =======</pre><p>
<pre>   <a class="el" href="csp__blas2_8c.html#51cbd689a51632885b9b034002631a6e" title="Solves one of the systems of equations A*x = b, or A&#39;*x = b.">sp_ctrsv()</a> solves one of the systems of equations   
       A*x = b,   or   A'*x = b,
   where b and x are n element vectors and A is a sparse unit , or   
   non-unit, upper or lower triangular matrix.   
   No test for singularity or near-singularity is included in this   
   routine. Such tests must be performed before calling this routine.</pre><p>
<pre>   Parameters   
   ==========</pre><p>
<pre>   uplo   - (input) char*
            On entry, uplo specifies whether the matrix is an upper or   
             lower triangular matrix as follows:   
                uplo = 'U' or 'u'   A is an upper triangular matrix.   
                uplo = 'L' or 'l'   A is a lower triangular matrix.</pre><p>
<pre>   trans  - (input) char*
             On entry, trans specifies the equations to be solved as   
             follows:   
                trans = 'N' or 'n'   A*x = b.   
                trans = 'T' or 't'   A'*x = b.
                trans = 'C' or 'c'   A^H*x = b.</pre><p>
<pre>   diag   - (input) char*
             On entry, diag specifies whether or not A is unit   
             triangular as follows:   
                diag = 'U' or 'u'   A is assumed to be unit triangular.   
                diag = 'N' or 'n'   A is not assumed to be unit   
                                    triangular.</pre><p>
<pre>   L       - (input) SuperMatrix*
	       The factor L from the factorization Pr*A*Pc=L*U. Use
             compressed row subscripts storage for supernodes,
             i.e., L has types: Stype = SC, Dtype = SLU_C, Mtype = TRLU.</pre><p>
<pre>   U       - (input) SuperMatrix*
	        The factor U from the factorization Pr*A*Pc=L*U.
	        U has types: Stype = NC, Dtype = SLU_C, Mtype = TRU.</pre><p>
<pre>   x       - (input/output) complex*
             Before entry, the incremented array X must contain the n   
             element right-hand side vector b. On exit, X is overwritten 
             with the solution vector x.</pre><p>
<pre>   info    - (output) int*
             If *info = -i, the i-th argument had an illegal value.
 </pre> 
</div>
</div><p>
<a class="anchor" name="98d44fe59660f87330b0172151a76141"></a><!-- doxytag: member="slu_cdefs.h::sqselect" ref="98d44fe59660f87330b0172151a76141" args="(int, float *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sqselect           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 25 13:43:49 2011 for SuperLU by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>

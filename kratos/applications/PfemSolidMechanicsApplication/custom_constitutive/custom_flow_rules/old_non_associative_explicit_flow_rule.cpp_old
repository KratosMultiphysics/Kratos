////

#include "../PfemSolidMechanicsApplication/custom_constitutive/custom_flow_rules/non_associative_explicit_plastic_flow_rule.hpp"


namespace Kratos
{


NonAssociativeExplicitPlasticFlowRule::NonAssociativeExplicitPlasticFlowRule()
{

}

NonAssociativeExplicitPlasticFlowRule::NonAssociativeExplicitPlasticFlowRule(const NonAssociativeExplicitPlasticFlowRule& rOther)
  :FlowRule(rOther)
{

}


NonAssociativeExplicitPlasticFlowRule::~NonAssociativeExplicitPlasticFlowRule()
{
}

NonAssociativeExplicitPlasticFlowRule::CalculateReturnMapping(RadialReturnVariables& rReturnMappingVariables,  Matrix & rStressMatrix)
{

   //1- Initialize some variables
   Vector StressVector = ZeroVector(6);
   InternalVariables PlasticVariables = mInternalVariables,
   PlasticVariables.DeltaPlasticStrain = 0.0;
   rReturnMappingVariables.Control.PlasticRegion = false;
   
   //mElasticLeftCauchyGreen
   Vector PreviousElasticHenckyStrain = ZeroVector(6);
   Vector DeltaHenckyStrain = ZeroVector(6);


   //computed with the actual 
   Vector NewElasticHenckyStrain = Vector(6);
   double Tolerance = 1E-3;

   // Previous Kirchhoff stress vector
   const Vector& PreviousStressVector = mActualStressVector;

   //2- Check for yield Condition (at the beggining)
   rReturnMappingVariables.TrialStateFunction = mpYieldCriterion->CalculateYieldCondition(rReturnMappingVariables.TrialStateFunction, ActualStressVector, PlasticVariables.EquivalentPlasticStrain)

    //1. Compute an Elastic Trial State
    double StressErrorMeasure;
    this->CalculateOneExplicitStep(DeltaHenckyStrain, PreviousElasticHenckyStrain, PlasticVariables, NewElasticHenckyStrain, NewStressVector, false, StressErrorMeasure);
    

    //2. Check if the Trial State is elastic
    double ElasticTrialStateFunction = 0.0;
    ElasticTrialStateFunction = mpYieldCriterion->CalculateYieldCondition(ElasticTrialStateFunction, NewStressVector, PlasticVariables.EquivalentPlasticStrain);

    //if ElasticStep
    if (rReturnMappingVariables.TrialStateFunction < Tolerance)  {

        if (StressErrorMeasure < Tolerance) {
		// YA LO TENEMOS HECHO
            rReturnMappingVariables.TrialStateFunction = ElasticTrialStateFunction; 
        }

        //Maybe elastic but error control did not converge
        else { 
	    //2.b Recalculate with an adaptive timeStep
            this->CalculateExplicitSolution(DeltaHenckyStrain, PreviousElasticHenckyStrain, PreviousStressVector, PreviousHardeningParameters, NewElasticHenckyStrain, NewStressVector, NewHardeningParameters, false, Tolerance); 
             
            rReturnMappingVariables.TrialStateFunction = mpYieldCriterion->CalculateYieldCondition(rReturnMappingVariables.TrialStateFunction, NewStressVector, ....);
            if (rReturnMappingVariables.TrialStateFunction > Tolerance) {
                  //2b.b From elastic to plastic
                  this->CalculateExplicitSolutionWithChange(DeltaHenckyStrain, PreviousElasticHenckyStrain, PreviousStressVector, PreviousHardeningParameters, NewElasticHenckyStrain, NewStressVector, NewHardeningParameters, Tolerance);
            }
        }

    }
    // Elastoplastic Step 
    else {
	//Its clear there is a transition
        if ((rReturnMappingVariables.TrialStateFunction < Tolerance) && (ElasticTrialStateFunction > Tolerance)) {
             this->CalculateExplicitSoluctionWithChange();
        }


	else if (( fabs(rReturnMappingVariables.TrialStateFunction)<Tolerance ) && (ElasticTrialStateFunction > Tolerance)) {
	   double Cosinus = 0.0;
           double AuxNorma1 = 0.0;
	   double AuxNorma2 = 0.0;
	   for (unsigned int i = 0; i<6; i++) {
                 Cosinus   += AuxiliarDerivatives.YieldFunctionD(i)* (NewStressVector(i)-PreviousStressVector(i));
                 AuxNorma1 +=  ((NewStressVector(i)-PreviousStressVector(i)))^2;
                 AuxNorma2 += (AuxiliarDerivatives.YieldFuncionD(i))^2;
           }
	   Cosinus /= sqrt(AuxNorma1*AuxNorma2);

           if (Cosinus > -AngleTolerance) {
                // Pure Plastic Increment
                this->CalculateExplicitSolution(DeltaHenckyStrain, PreviousElasticHenckyStrian, PreviousStressVector, PreviousHardeningParameters, NewElasticHenckyStrain, NewStressVector, NewHardeiningParameters, true, Tolerance);
           }

           else {
		//Elasto-Plastic Unloading etc.
                this->CalculateExplicitSolutionWithChange(DeltaHenckyStrain, PreviousElasticHenckyStrain, PreviousStressVector, PreviousHardeningParameters, NewElasticHenckyStrain, NewStressVector, NewHardeningParameters, Tolerance);
                //Lo tengo solucionado con el tema de que F0 = -1
           }
        }

        else {
	   std::cout << "The Newcastle Group thinks that you can not enter here " << std::endl;
          //No es posible según Newcastle
        }
    }

}



//********************* UPDATES ONE STRAIN INCREMENT THE STRESS ****************
//******************************************************************************
    this->CalculateOneExplicitStep(DeltaHenckyStrain, PreviousElasticHenckyStrain, PlasticVariables, NewElasticHenckyStrain, NewStressVector, false, StressErrorMeasure);
NonAssociativeExplicitPlasticFlowRule::CalculateOneExplicitStep(const Vector& rHenckyStrainIncrement, const Vector& rPreviousElasticHenckyStrain, InternalVariables& rPlasticVariables, Vector& rNewElasticHenckyStrain, Vector& rNewStressVector, const& rElastoPlasticBool, double rStressErrorMeasure)
{
  
////// ATENCIÓ, AIXÒ ESTÀ FENT ABANS DE QUE RELLEGIS, cOM QUE ES TRACTA DE HYPERELASTIC s = s(epsilon);
// No fa falta calcular matrius tangents
// La pc també té equació explícita 
    
    // Runge Kutta Variables (Bogacki-Shampine)
    int nRK = 4;
    Vector  CRK = ZeroVector(nRK);
    CRK = [0.0 , 1.0/2.0 , 3.0/4.0, 1.0]
    Matrix ARK = ZeroMatrix(nRK)
    ARK(1,0) = 1.0/2.0;
    ARK(2,0) = 0.0;     ARK(2,1) = 3.0/4.0;
    ARK(3,0) = 2.0/9.0; ARK(3,1) = 1.0/3.0; ARK(3,2) = 4.0/9.0;
    Vector  b1 = ZeroVector(nRK);
    Vector  b2 = ZeroVector(nRK);
    b1 = [2.0/9.0, 1.0/3.0, 4.0/9.0, 0.0];
    b2 = [7.0/24.0, 1.0/4.0, 1.0/3.0, 1.0/8.0];

    Vector  StressVector = ZeroVector(6);
    Vector  ElasticStrainVector = ZeroVector(6);
    Vector  HardeningVector = ZeroVector(nH);

    //RK increments are saved in a matrix
    Matrix  StressMatrix  = ZeroMatrix(6, nRK);
    Matrix  ElasticStrainMatrix = ZeroMatrix(6, nRK);
    Matrix  HardeningMatrix = ZeroMatrix(nH, nRK);
    Matrix  ElasticMatrix = ZeroMatrix(6);

    Vector TotalStrainIncrement = ZeroVector(6);
    Vector StressIncrement = ZeroVector(6);
    Vector ElasticStrainIncrement = ZeroVector(6);
    Vector HardeningIncrement = ZeroVector(nH);

    double DeltaGamma;

    for (unsigned int iRK =0 ; i<nRK; ++iRK)
    {
        //Compute the stress and strain (at the Step iRK of RK) 
        StressVector = rPreviousStressVector;      
        ElasticStrainVector = rPreviousElasticHenckyStrain;
        HardeningVector = rPreviousHardeningParameters;
        for (unsigned int i = 0; i<iRK, ++i){
	   for (unsigned int j = 0; j < 6; ++j) {
	      StressVector(j) +=a(iRK,i)*StressMatrix(j,i);
              ElasticStrainVector(j) +=a(iRK,i)*ElasticStrainMatrix(j,i);
           }
           for (unsigned int j = 0; j<nH; ++j) 
              HardeningVector(j) += a(iRK, i)*HardeningMatrix(j,i);

        }
        TotalStrainIncrement = ARK(i)*rHenckyStrainIncrement;

        // Compute the ElastoPlastic Matrix, Elastic Incremental deformation and Hardening Parameters
    	this->ComputeElasticMatrix(StressVector, ElasticMatrix);

    	if ( rElastoPlasticBool){

       	  AuxiliarDerivativeStructure AuxiliarDerivatives;
       	  this->UpdateDerivatives(StressVector, HardeningVector, AuxiliarDerivatives);

          double H;
          this->ComputePlasticHardeningParameter(StressVector, H);
          DeltaGamma = prod( trans(AuxiliarDerivatives.YieldFunctionD), prod(ElasticMatrix, TotalStrainIncrement));
          double auxDenominador = H + prod(trans(AuxiliarDerivatives.YieldFunctionD), prod(ElasticMatrix, AuxiliarDerivatives.PlasticPotentialD));
	  DeltaGamma /= auxDenominador;

          ElasticStrainIncrement = TotalStrainIncrement - deltaGamma*AuxiliarDerivatives.PlasticPotentialD;
          rNewHardeningParameters += deltaGamma*...;

        }
	else {
 	   ElasticStrainIncrement = TotalStrainIncrement;
        }
	
	//Compute The Stress Increment
        StressIncrement = prod(ElasticMatrix, ElasticStrainIncrement);

        //Save the Increments
	for (usinged int j = 0; j < 6; ++j) {
	    StressMatrix(j,iRK) = StressIncrement(j);
            ElasticStrainMatrix(j,iRK) = ElasticStrainIncrement(j);
        }
        if (rElastoPlasticBool) {
            for (unsigned int j = 0; j<6; ++j) 
	       HardeningMatrix(j, iRK) = HardeningVector(j);
        }
     }  //END FOR COMPUTE INCREMENTS


    StressVector = rPreviousStressVector;
    ElasticStrainVector = rPreviousElasticHenckyStrain;
    HardeningVector = rPreviousHardeningParameters;
     
    rNewHardeningParameters = rPreviousHardeningParameters;
    rNewStressVector = rPreviousStressVector;
    rNewElasticHenckyStrain = rPreviousElasticHenckyStrain;

    for (unsigned int iRK = 0; i<nRK; ++i) {
	for (unsigned int j = 0; j < 6; ++j) {
 	    StressVector(j)     += b1(iRK)*StressMatrix(j,iRK);
	    rNewStressVector(j) += b2(iRK)*StressMatrix(j,iRK);

	    ElasticStrainVector(j)     += b1(iRK)*ElasticStrainMatrix(j, iRK);
            rNewElasticHenckyStrain(j) += b2(iRK)*ElasticStrainMatrix(j, iRK);
         }
         for (unsigned int j = 0; j < nH; ++j) {
            HardeningVector(j)         += b1(iRK)*HardeningMatrix(j, iRK);
 	    rNewHardeningParameters(j) += b2(iRK)*HardemingMatrix(j, iRK);
         }
   }     
   //COMPUTE AN ERROR MEASURE
   rStressErrorMeasure = 0.0;
   double denom = 0.0;
   for (unsigned int j = 0; j<6; ++j) {
       rStressErrorMeasure += (StressVector(j) - rNewStressVector(j) )^2;
       denom += rNewStressVector(j)^2;
   }
   rStressErrorMeasure /= denom;
 
 
}


NonAssociativeExplicitPlasticFlowRule::CalculateExplicitSolution(const Vector& rHenckyStrainIncrement, const Vector& rPreviousElasticHenckyStrain, const Vector& rPreviousStressVector, const Vector& rPreviousHardeningParameters, Vector& rNewElasticHenckyStrain, Vector& rNewStressVector,  Vector& rNewHardeningParameters , const& rElastoPlasticBool, const double & rTolerance)
{

   double TimeStep = 0.5;
   double MinTimeStep = 1e-5;
   double DoneTimeStep = 0.0;

   Vector DeltaHenckyStrain = ZeroVector(6);
   Vector PreviousElasticHenckyStrain = rPreviousElasticStrain;
   Vector PreviousStressVector = rPreviousStressVector;
   Vector PreviousHardeningParameters = rPreviousHardenindParameters;
   

   double StressErrorMeasure = 0.0;

   while (DoneTimeStep < 1.0)
   {
	if (DoneTimeStep + TimeStep >= 1.0) {
	   TimeStep = 1.0 - DoneTimeStep; 
       }

       DeltaHenckyStrain = TimeStep * rHenckyStrainIncrement;
 
       this->CalculateOneExplicitStep(DeltaHenckyStrain, PreviousElasticHenckyStrain, PreviousStressVector, PreviousHardeningParameters, rNewElasticHenckyStrain, rNewStressVector, rNewHardeningParameters, rElastoPlasticBool, StressErrorMeasure);

       // Converge el step, (reasignar)
       if (StressErrorMeasure < rTolerance) {
 	  PreviousElasticHenckyStrain = rNewElasticHenckyStrain;
	  PreviousStressVector        = rNewStressVector;
          PreviousHardeningParameters = rNewHardeningParameters;
          DoneTimeStep += TimeStep;


       }
       // El step no converge
       else {
	  if (TimeStep == MinTimeStep) {
	    //No converge el step

	     std::cout << "Explicit Stress Integration did not converge " << std::endl;
 	     PreviousElasticHenckyStrain = rNewElasticHenckyStrain;
             PreviousStressVector        = rNewStressVector;
             PreviousHardeningParameters = rNewHardeningParameters;
             DoneTimeStep += TimeStep;
          }
       } 
      
       TimeStep *= 0.9* (( rTolerance / StressErrorMeasure ) ^0.5);
       TimeStep = max(TimeStep, MinTimeStep);

   }

}


NonAssociativePlasticFlowRule::CalculateExplicitSolutionWithChange(const Vector& rHenckyStrainIncrement, const Vector& rPreviousElasticHenckyStrian, const Vector& rPreviousStressVector, const Vector& rPreviousHardeningParameters, Vector& rNewElasticHenckyStrain, Vector& rNewStressVector, Vector& rNewHardeningParameters, const double& rTolerance)
{
    // To perform the bisection in order to obtain the 
    int NumberOfSubsteps = 10;
    double IncrementalAlpha = 1/double(NumberOfSubsteps);

    double AlphaEndOfElastic = 0.0;
    Vector StrainAtAlpha = rPreviousElasticHenckyStrain;
    Vector StressAtAlpha = rPreviousStressVector;
    Vector HardeningAtAlpha = rPreviousHardeningParameters;


    double StateFuncionEndSubstep;
    for (unsigned int iSubstep = 0; i<NumberOfSubsteps; ++iSubstep)
    {

	this->CalculateExplicitSolution(IncrementalAlpha*rHenckyStrainIncrement, StrainAtAlpha, StressAtAlpha, HardeningAtAlpha rNewElasticHenckyStrain, rNewStressVector, rNewHardeningParameters, false, rTolerance); 
             
        StateFunctionEndSubstep = mpYieldCriterion->CalculateYieldCondition(StateFunctionEndSubsep, rNewStressVector, rNewHardeningParameters);

	//Elastic Substep, add and continue
        if (StateFunctionEndSubset < rTolerance)
        {
	    AlphaEndOfElastic += IncrementalAlpha;
	    StrainAtAlpha = rNewElasticHenckyStrain;
	    StressAtAlpha = rNewStressVector;
	    HardeningAtAlpha = rNewHardeningParameters;

	    if ( iSubstep == (NumberOfSubsteps -1) ) {
		return;
	    }
	}

	//ElastoPlastic Substep
	else {

   	  double StateFunction0 = -1.0; 
	  double StateFunctionHalf; 

	  double HalfSubstep = 0.5*(IncrementalAlpha);
	
	  bool convergence = false;

	//1. Bisection, calculate Ee just at the yield surface
	  while (! convergence) {
	
	     this->CalculateExplicitSolution( HalfSubstep*rHenckyStrainIncrement, StrainAtAlpha, StressAtAlpha, HardeningAtAlpha rNewElasticHenckyStrain, rNewStressVector, rNewHardeningParameters, false, rTolerance); 
 
             StateFunctionHalf = mpYieldCriterion->CalculateYieldCondition(StateFunctionHalf, rNewStressVector, rNewHardeningParameters);

	     if ( StateFunctionHalf < rTolerance)   {

	       AlphaEndOfElastic += HalfSubstep;
	       StrainAtAlpha = rNewElasticHenckyStrain;
	       StressAtAlpha = rNewStressVector;
	       HardeningAtAlpha = rNewHardeningParameters;
	       StateFunction0 = StateFunctionHalf;
	       HalfSubstep *= 0.5;

             }
	     else {
               StateFunctionEndSubStep = StateFunctionHalf;
               HalfSubstep *= 0.5;
	     }

	     if ((HalfSubstep == 1E-5) || (fabs(StateFunction0) < rTolerance))  {
	        converged = true;
	        //We are at the yield surface, let's continue elastoplastically//
	     }
          } //End While Bisection 
	
	  this->CalculateExplicitSolution( (1-AlphaEndOfElastic)*rHenckyStrainIncrement, StrainAtAlpha, StressAtAlpha, HardeningAtAlpha, rNewElasticHenckyStrain, rNewStressVector, rNewHardeningParameters, true, rTolerance);
       }

    } //End for gran

    std::cout << "NOt supposed to be here " << std::endl;

}



} //End Namespace Kratos

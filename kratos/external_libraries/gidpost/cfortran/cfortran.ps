%!PS-Adobe-3.0
%%Title: cfortran.doc
%%For: Jorge Suit Perez Ronda
%%Creator: a2ps version 4.13
%%CreationDate: Mon Nov 25 18:56:47 2002
%%BoundingBox: 24 24 571 818
%%DocumentData: Clean7Bit
%%Orientation: Landscape
%%Pages: 17
%%PageOrder: Ascend
%%DocumentMedia: A4 595 842 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-BoldOblique
%%+ font Courier-Oblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black 
%%DocumentSuppliedResources: procset a2ps-a2ps-hdr
%%+ procset a2ps-black+white-Prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontMatrix get 3 get 1000 mul
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    % We use `load' because sometimes BBox is executable, sometimes not.
    % Since we need 4 numbers an not an array avoid BBox from being executed
    /FontBBox load aload pop
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Define these in case they're not in the FontInfo (also, here
    % they're easier to get to.
    /UnderlinePosition 1 def
    /UnderlineThickness 1 def
    
    % Get the underline position and thickness if they're defined.
    currentdict /FontInfo known {
      FontInfo
      
      dup /UnderlinePosition known {
	dup /UnderlinePosition get
	0 exch FontMatrix transform exch pop
	/UnderlinePosition exch def
      } if
      
      dup /UnderlineThickness known {
	/UnderlineThickness get
	0 exch FontMatrix transform exch pop
	/UnderlineThickness exch def
      } if
      
    } if
    currentdict 
  end 
} bind def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%BeginResource: procset a2ps-a2ps-hdr 2.0 2
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.95 setgray
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def
%%EndResource
%%BeginResource: procset a2ps-black+white-Prolog 2.0 1

% Function T(ab), jumps to the n-th tabulation in the current line
/T { 
  cw mul x0 add y0 moveto
} bind def

% Function n: move to the next line
/n { %def
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
}  bind def

/S {
  Show
} bind def

/p {
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  false UL
  false BX
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/K {
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/C {
  false UL
  false BX
  fCourier-BoldOblique bfs scalefont setfont
  Show 
} bind def

/l {
  false UL
  false BX
  fHelvetica bfs scalefont setfont
  Show
} bind def

/L {
  false UL
  false BX
  fHelvetica-Bold bfs scalefont setfont
  Show 
} bind def

/str{
  false UL
  false BX
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  false UL
  true BX
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Times-Roman
%%IncludeResource: font Symbol
%%IncludeResource: font Courier-BoldOblique
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
% Initialize page description variables.
/sh 595 def
/sw 842 def
/llx 24 def
/urx 818 def
/ury 571 def
/lly 24 def
/#copies 1 def
/th 15.000000 def
/fnfs 11 def
/bfs 8.005733 def
/cw 4.803440 def

% Dictionary for ISO-8859-1 support
/iso1dict 8 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fCourier-BoldOblique ISO-8859-1Encoding /Courier-BoldOblique reencode_font
  /fCourier-Oblique ISO-8859-1Encoding /Courier-Oblique reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 81.400000 mul
def
/ph
   501.959430 th add
def
/pmw urx llx sub pw 2 mul sub 1 div def
/pmh 0 def
/v 0 def
/x [
  0
  dup pmw add pw add
] def
/y [
  pmh ph add 0 mul ph add
  dup
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 0 def
/tab 8 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1-2) 1
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(cfortran.doc  4.3) p n
(http://www-zeus.desy.de/~burow/cfortran/) N
(Burkhard Burow  burow@desy.de                 1990 - 2001.) N
() N
(              cfortran.h :  Interfacing C or C++ and FORTRAN) N
() N
(Supports: Alpha and VAX VMS, Alpha OSF, DECstation and VAX Ultrix, IBM RS/6000, ) N
(          Silicon Graphics, Sun, CRAY, Apollo, HP9000, LynxOS, Convex, Absoft,) N
(          f2c, g77, NAG f90, PowerStation Fortran with Visual C++, NEC SX-4,) N
(          Portland Group.) N
() N
(C and C++ are generally equivalent as far as cfortran.h is concerned.) N
(Unless explicitly noted otherwise, mention of C implicitly includes C++.) N
(C++ compilers tested include: ) N
(  SunOS> CC +p +w      # Clean compiles.) N
(  IRIX>  CC            # Clean compiles.) N
(  IRIX>  CC -fullwarn  # Still some warnings to be overcome.) N
(  GNU>   g++ -Wall     # Compiles are clean, other than warnings for unused) N
(                       #   cfortran.h static routines.) N
() N
(N.B.: The best documentation on interfacing C or C++ and Fortran is in) N
(      the chapter named something like 'Interfacing C and Fortran') N
(      to be found in the user's guide of almost every Fortran compiler.) N
(      Understanding this information for one or more Fortran compilers) N
(      greatly clarifies the aims and actions of cfortran.h.) N
(      Such a chapter generally also addresses issues orthogonal to cfortran.h,) N
(      for example the order of array indices, the index of the first element,) N
(      as well as compiling and linking issues.) N
() N
() N
(0 Short Summary of the Syntax Required to Create the Interface) N
(--------------------------------------------------------------) N
() N
(e.g. Prototyping a FORTRAN subroutine for C:) N
() N
(/* PROTOCCALLSFSUBn is optional for C, but mandatory for C++. */) N
() N
(                 PROTOCCALLSFSUB2\(SUB_NAME,sub_name,STRING,PINT\)) N
(#define SUB_NAME\(A,B\) CCALLSFSUB2\(SUB_NAME,sub_name,STRING,PINT, A,B\)) N
() N
(                                ^     -                                       -) N
(       number of arguments _____|    |   STRING   BYTE    PBYTE       BYTEV\(..\)|) N
(                                  /  |   STRINGV  DOUBLE  PDOUBLE   DOUBLEV\(..\)|) N
(                                 /   |  PSTRING   FLOAT   PFLOAT     FLOATV\(..\)|) N
(        types of arguments ____ /    | PNSTRING   INT     PINT         INTV\(..\)|) N
(                                \\    | PPSTRING   LOGICAL PLOGICAL LOGICALV\(..\)|) N
(                                 \\   |  PSTRINGV  LONG    PLONG       LONGV\(..\)|) N
(                                  \\  |   ZTRINGV  SHORT   PSHORT     SHORTV\(..\)|) N
(                                     |  PZTRINGV  ROUTINE PVOID      SIMPLE    |) N
(                                      -                                       -) N
() N
() N
(e.g. Prototyping a FORTRAN function for C:) N
(/* PROTOCCALLSFFUNn is mandatory for both C and C++. */) N
(PROTOCCALLSFFUN1\(INT,FUN_NAME,fun_name,STRING\)) N
(#define FUN_NAME\(A\)  CCALLSFFUN1\(FUN_NAME,fun_name,STRING, A\)) N
() N
(e.g. calling FUN_NAME from C:    {int a; a = FUN_NAME\("hello"\);}) N
() N
() N
(e.g. Creating a FORTRAN-callable wrapper for) N
(     a C function returning void, with a 7 dimensional integer array argument:) N
(cfortran.doc) (Page 1/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(     [Not supported from C++.]) p n
(FCALLSCSUB1\(csub_name,CSUB_NAME,csub_name,INTVVVVVVV\)) N
() N
() N
(e.g. Creating a FORTRAN-callable wrapper for other C functions:) N
(FCALLSCFUN1\(STRING,cfun_name,CFUN_NAME,cfun_name,INT\)) N
(           [ ^-- BYTE, DOUBLE, FLOAT, INT, LOGICAL, LONG, SHORT, VOID  ) N
(             are other types returned by functions.       ]) N
(       ) N
() N
(e.g. COMMON BLOCKs:) N
(FORTRAN:                         common /fcb/  v,w,x) N
(                                 character *\(13\) v, w\(4\), x\(3,2\)) N
(C:) N
(typedef struct { char v[13],w[4][13],x[2][3][13]; } FCB_DEF;) N
(#define FCB COMMON_BLOCK\(FCB,fcb\)) N
(COMMON_BLOCK_DEF\(FCB_DEF,FCB\);) N
(FCB_DEF FCB;    /* Define, i.e. allocate memory, in exactly one *.c file. */) N
() N
(e.g. accessing FCB in C:          printf\("%.13s",FCB.v\);) N
() N
() N
() N
(I Introduction) N
(--------------) N
() N
(cfortran.h is an easy-to-use powerful bridge between C and FORTRAN.) N
(It provides a completely transparent, machine independent interface between) N
(C and FORTRAN routines \(= subroutines and/or functions\) and global data,) N
(i.e. structures and COMMON blocks.) N
() N
(The complete cfortran.h package consists of 4 files: the documentation in) N
(cfortran.doc, the engine cfortran.h, examples in cfortest.c and ) N
(cfortex.f/or. [cfortex.for under VMS, cfortex.f on other machines.]) N
() N
(The cfortran.h package continues to be developed. The most recent version is) N
(available via www at http://www-zeus.desy.de/~burow/cfortran/) N
() N
(The examples may be run using one of the following sets of instructions:) N
() N
(N.B. Unlike earlier versions, cfortran.h 3.0 and later versions) N
(     automatically uses the correct ANSI ## or pre-ANSI /**/) N
(     preprocessor operator as required by the C compiler.) N
() N
(N.B. As a general rule when trying to determine how to link C and Fortran,) N
(     link a trivial Fortran program using the Fortran compilers verbose option,) N
(     in order to see how the Fortran compiler drives the linker. e.g.) N
(       unix> cat f.f) N
(                END) N
(       unix> f77 -v f.f) N
(       .. lots of info. follows ...) N
() N
(N.B. If using a C main\(\), i.e. Fortran PROGRAM is not entry of the executable,) N
(     and if the link bombs with a complaint about) N
(     a missing "MAIN" \(e.g. MAIN__, MAIN_, f90_main or similar\),) N
(     then Fortran has hijacked the entry point to the executable) N
(     and wishes to call the rest of the executable via "MAIN".) N
(     This can usually be satisfied by doing e.g. 'cc -Dmain=MAIN__ ...') N
(     but often kills the command line arguments in argv and argc.) N
(     The f77 verbose option, usually -v, may point to a solution.) N
(     ) N
() N
(cfortran.doc) (Page 2/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (1/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 2
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(RS/6000> # Users are strongly urged to use f77 -qextname and cc -Dextname) p n
(RS/6000> # Use -Dextname=extname if extname is a symbol used in the C code.) N
(RS/6000> xlf -c -qextname cfortex.f) N
(RS/6000> cc  -c -Dextname cfortest.c) N
(RS/6000> xlf -o cfortest cfortest.o cfortex.o && cfortest ) N
() N
(DECFortran> #Only DECstations with DECFortran for Ultrix RISC Systems.) N
(DECFortran> cc -c -DDECFortran cfortest.c) N
(DECFortran> f77 -o cfortest cfortest.o cfortex.f  &&  cfortest) N
() N
(IRIX xxxxxx 5.2 02282015 IP20 mips) N
(MIPS> # DECstations and Silicon Graphics using the MIPS compilers.) N
(MIPS> cc -o cfortest cfortest.c cfortex.f -lI77 -lU77 -lF77  &&  cfortest) N
(MIPS> # Can also let f77 drive linking, e.g.) N
(MIPS> cc -c cfortest.c) N
(MIPS> f77 -o cfortest cfortest.o cfortex.f  &&  cfortest) N
() N
(Apollo> # Some 'C compiler 68K Rev6.8' break. [See Section II o\) Notes: Apollo]) N
(Apollo> f77 -c cfortex.f && cc -o cfortest cfortest.c cfortex.o  &&  cfortest) N
() N
(VMS> define lnk$library sys$library:vaxcrtl) N
(VMS> cc cfortest.c) N
(VMS> fortran cfortex.for) N
(VMS> link/exec=cfortest cfortest,cfortex) N
(VMS> run cfortest) N
() N
(OSF1 xxxxxx V3.0 347 alpha) N
(Alpha/OSF> # Probably better to let cc drive linking, e.g.) N
(Alpha/OSF> f77 -c cfortex.f) N
(Alpha/OSF> cc  -o cfortest cfortest.c cfortex.o -lUfor -lfor -lFutil -lots -lm) N
(Alpha/OSF> cfortest) N
(Alpha/OSF> # Else may need 'cc -Dmain=MAIN__' to let f77 drive linking.) N
() N
(Sun> # Some old cc\(1\) need a little help. [See Section II o\) Notes: Sun]) N
(Sun> f77 -o cfortest cfortest.c cfortex.f -lc -lm  &&  cfortest) N
(Sun> # Some older f77 may require 'cc -Dmain=MAIN_'.) N
() N
(CRAY> cft77 cfortex.f) N
(CRAY> cc -c cfortest.c) N
(CRAY> segldr -o cfortest.e cfortest.o cfortex.o) N
(CRAY> ./cfortest.e) N
() N
(NEC> cc -c -Xa cfortest.c) N
(NEC> f77 -o cfortest cfortest.o cfortex.f  &&  cfortest) N
() N
(VAX/Ultrix/cc> # For cc on VAX Ultrix only, do the following once to cfortran.h.) N
(VAX/Ultrix/cc> mv cfortran.h cftmp.h && grep -v "^#pragma" <cftmp.h >cfortran.h) N
(                                            ) N
(VAX/Ultrix/f77> # In the following, 'CC' is either 'cc' or 'gcc -ansi'. NOT'vcc') N
(VAX/Ultrix/f77> CC -c -Dmain=MAIN_ cfortest.c) N
(VAX/Ultrix/f77> f77 -o cfortest cfortex.f cfortest.o  &&  cfortest) N
() N
(LynxOS> # In the following, 'CC' is either 'cc' or 'gcc -ansi'.) N
(LynxOS> # Unfortunately cc is easily overwhelmed by cfortran.h,) N
(LynxOS> #  and won't compile some of the cfortest.c demos.) N
(LynxOS> f2c -R cfortex.f) N
(LynxOS> CC -Dlynx -o cfortest cfortest.c cfortex.c -lf2c  &&  cfortest) N
() N
(HP9000> # Tested with HP-UX 7.05 B 9000/380 and with A.08.07 A 9000/730) N
(HP9000> # CC may be either 'c89 -Aa' or 'cc -Aa') N
(HP9000> #    Depending on the compiler version, you may need to include the) N
(HP9000> #    option '-tp,/lib/cpp' or worse, you'll have to stick to the K&R C.) N
(cfortran.doc) (Page 3/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(HP9000> #    [See Section II o\) Notes: HP9000]) p n
(HP9000> # Users are strongly urged to use f77 +ppu and cc -Dextname) N
(HP9000> # Use -Dextname=extname if extname is a symbol used in the C code.) N
(HP9000> CC  -Dextname -c cfortest.c) N
(HP9000> f77 +ppu         cfortex.f  -o cfortest cfortest.o && cfortest) N
(HP9000> # Older f77 may need) N
(HP9000> f77 -c cfortex.f) N
(HP9000> CC -o cfortest cfortest.c cfortex.o -lI77 -lF77 && cfortest) N
() N
(HP0000> # If old-style f77 +800 compiled objects are required:) N
(HP9000> # #define hpuxFortran800) N
(HP9000> cc -c -Aa -DhpuxFortran800 cfortest.c) N
(HP9000> f77 +800 -o cfortest cfortest.o cfortex.f) N
() N
(f2c> # In the following, 'CC' is any C compiler.) N
(f2c> f2c -R cfortex.f) N
(f2c> CC -o cfortest -Df2cFortran cfortest.c cfortex.c -lf2c  &&  cfortest) N
() N
(Portland Group $ # Presumably other C compilers also work.) N
(Portland Group $ pgcc -DpgiFortran -c cfortest.c) N
(Portland Group $ pgf77 -o cfortest cfortex.f cfortest.o && cfortest) N
() N
(NAGf90> # cfortex.f is distributed with Fortran 77 style comments.) N
(NAGf90> # To convert to f90 style comments do the following once to cfortex.f: ) N
(NAGf90> mv cfortex.f cf_temp.f && sed 's/^C/\\!/g' cf_temp.f > cfortex.f) N
(NAGf90> # In the following, 'CC' is any C compiler.) N
(NAGf90> CC -c -DNAGf90Fortran cfortest.c) N
(NAGf90> f90 -o cfortest cfortest.o cfortex.f &&  cfortest) N
() N
(PC> # On a PC with PowerStation Fortran and Visual_C++) N
(PC> cl /c cftest.c) N
(PC> fl32  cftest.obj cftex.for) N
() N
(GNU> # GNU Fortran) N
(GNU> # See Section VI caveat on using 'gcc -traditional'.) N
(GNU> gcc -ansi -Wall -O -c -Df2cFortran cfortest.c) N
(GNU> g77 -ff2c -o cfortest cfortest.o cfortex.f &&  cfortest) N
() N
(AbsoftUNIX> # Absoft Fortran for all UNIX based operating systems.) N
(AbsoftUNIX> # e.g. Linux or Next on Intel or Motorola68000.) N
(AbsoftUNIX> # Absoft f77 -k allows Fortran routines to be safely called from C.) N
(AbsoftUNIX> gcc -ansi -Wall -O -c -DAbsoftUNIXFortran cfortest.c) N
(AbsoftUNIX> f77 -k -o cfortest cfortest.o cfortex.f && cfortest) N
() N
(AbsoftPro> # Absoft Pro Fortran for MacOS) N
(AbsoftPro> # Use #define AbsoftProFortran) N
() N
(CLIPPER> # INTERGRAPH CLIX using CLIPPER C and Fortran compilers.) N
(CLIPPER> # N.B. - User, not cfortran.h, is responsible for) N
(CLIPPER> #        f77initio\(\) and f77uninitio\(\) if required.) N
(CLIPPER> #      - LOGICAL values are not mentioned in CLIPPER doc.s,) N
(CLIPPER> #        so they may not yet be correct in cfortran.h.) N
(CLIPPER> #      - K&R mode \(-knr or Ac=knr\) breaks FLOAT functions) N
(CLIPPER> #        \(see CLIPPER doc.s\) and cfortran.h does not fix it up.) N
(CLIPPER> #        [cfortran.h ok for old sun C which made the same mistake.]) N
(CLIPPER> acc cfortest.c -c -DCLIPPERFortran) N
(CLIPPER> af77 cfortex.f cfortest.o -o cfortest) N
() N
() N
(By changing the SELECTion ifdef of cfortest.c and recompiling one can try out) N
(a few dozen different few-line examples.) N
() N
(cfortran.doc) (Page 4/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (2/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 3
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
() N
(The benefits of using cfortran.h include:) N
(1. Machine/OS/compiler independent mixing of C and FORTRAN.) N
() N
(2. Identical \(within syntax\) calls across languages, e.g.) N
(C FORTRAN) N
(      CALL HBOOK1\(1,'pT spectrum of pi+',100,0.,5.,0.\)) N
(/* C*/) N
(           HBOOK1\(1,"pT spectrum of pi+",100,0.,5.,0.\);) N
() N
(3. Each routine need only be set up once in its lifetime. e.g.) N
(/* Setting up a FORTRAN routine to be called by C.) N
(   ID,...,VMX are merely the names of arguments.) N
(   These tags must be unique w.r.t. each other but are otherwise arbitrary. */) N
(PROTOCCALLSFSUB6\(HBOOK1,hbook1,INT,STRING,INT,FLOAT,FLOAT,FLOAT\)) N
(#define HBOOK1\(ID,CHTITLE,NX,XMI,XMA,VMX\)                        \\) N
(     CCALLSFSUB6\(HBOOK1,hbook1,INT,STRING,INT,FLOAT,FLOAT,FLOAT, \\) N
(               ID,CHTITLE,NX,XMI,XMA,VMX\) ) N
() N
(4. Source code is NOT required for the C routines exported to FORTRAN, nor for) N
(   the FORTRAN routines imported to C. In fact, routines are most easily) N
(   prototyped using the information in the routines' documentation.) N
() N
(5. Routines, and the code calling them, can be coded naturally in the language) N
(   of choice. C routines may be coded with the natural assumption of being ) N
(   called only by C code. cfortran.h does all the required work for FORTRAN ) N
(   code to call C routines. Similarly it also does all the work required for C) N
(   to call FORTRAN routines. Therefore:) N
(     - C programmers need not embed FORTRAN argument passing mechanisms into ) N
(       their code.) N
(     - FORTRAN code need not be converted into C code. i.e. The honed and ) N
(       time-honored FORTRAN routines are called by C.) N
() N
(6. cfortran.h is a single ~1700 line C include file; portable to most) N
(   remaining, if not all, platforms.) N
() N
(7. STRINGS and VECTORS of STRINGS along with the usual simple arguments to ) N
(   routines are supported as are functions returning STRINGS or numbers. Arrays) N
(   of pointers to strings and values of structures as C arguments, will soon be) N
(   implemented. After learning the machinery of cfortran.h, users can expand ) N
(   it to create custom types of arguments. [This requires no modification to) N
(   cfortran.h, all the preprocessor directives required to implement the) N
(   custom types can be defined outside cfortran.h]) N
() N
(8. cfortran.h requires each routine to be exported to be explicitly set up. ) N
(   While is usually only be done once in a header file it would be best if) N
(   applications were required to do no work at all in order to cross languages.) N
(   cfortran.h's simple syntax could be a convenient back-end for a program) N
(   which would export FORTRAN or C routines directly from the source code. ) N
() N
() N
(                                    -----) N
() N
(Example 1 - cfortran.h has been used to make the C header file hbook.h, ) N
(            which then gives any C programmer, e.g. example.c, full and ) N
(            completely transparent access to CERN's HBOOK library of routines.) N
(            Each HBOOK routine required about 3 lines of simple code in) N
(            hbook.h. The example also demonstrates how FORTRAN common blocks) N
(            are defined and used.) N
() N
(/* hbook.h */) N
(cfortran.doc) (Page 5/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include "cfortran.h") p n
(        :) N
(PROTOCCALLSFSUB6\(HBOOK1,hbook1,INT,STRING,INT,FLOAT,FLOAT,FLOAT\)) N
(#define HBOOK1\(ID,CHTITLE,NX,XMI,XMA,VMX\)                        \\) N
(     CCALLSFSUB6\(HBOOK1,hbook1,INT,STRING,INT,FLOAT,FLOAT,FLOAT, \\) N
(               ID,CHTITLE,NX,XMI,XMA,VMX\) ) N
(        :) N
(/* end hbook.h */) N
() N
(/* example.c */) N
(#include "hbook.h") N
(        :) N
(typedef struct {) N
(  int lines;  ) N
(  int status[SIZE];) N
(  float p[SIZE];  /* momentum */) N
(} FAKE_DEF;) N
(#define FAKE COMMON_BLOCK\(FAKE,fake\)) N
(COMMON_BLOCK_DEF\(FAKE_DEF,FAKE\);) N
(        :) N
(main \(\)) N
({) N
(        :) N
(           HBOOK1\(1,"pT spectrum of pi+",100,0.,5.,0.\);) N
(/* c.f. the call in FORTRAN:) N
(      CALL HBOOK1\(1,'pT spectrum of pi+',100,0.,5.,0.\)) N
(*/) N
(        :) N
(  FAKE.p[7]=1.0;) N
() S 8 T (:) N
(}           ) N
() N
(N.B. i\) The routine is language independent.) N
(    ii\) hbook.h is machine independent.  ) N
(   iii\) Applications using routines via cfortran.h are machine independent.) N
() N
(                                    -----) N
() N
(Example 2 - Many VMS System calls are most easily called from FORTRAN, but) N
(            cfortran.h now gives that ease in C.) N
() N
(#include "cfortran.h") N
() N
(PROTOCCALLSFSUB3\(LIB$SPAWN,lib$spawn,STRING,STRING,STRING\)) N
(#define LIB$SPAWN\(command,input_file,output_file\)          \\) N
(     CCALLSFSUB3\(LIB$SPAWN,lib$spawn,STRING,STRING,STRING, \\) N
(                  command,input_file,output_file\)) N
() N
(main \(\)) N
({) N
(LIB$SPAWN\("set term/width=132","",""\);) N
(}) N
() N
(Obviously the cfortran.h command above could be put into a header file along) N
(with the description of the other system calls, but as this example shows, it's) N
(not much hassle to set up cfortran.h for even a single call.) N
() N
(                                    -----) N
() N
(Example 3 - cfortran.h and the source cstring.c create the cstring.obj library ) N
(            which gives FORTRAN access to all the functions in C's system ) N
(            library described by the system's C header file string.h.) N
(cfortran.doc) (Page 6/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (3/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (7-8) 4
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(C     EXAMPLE.FOR) N
(      PROGRAM EXAMPLE) N
(      DIMENSION I\(20\), J\(30\)) N
(        :) N
(      CALL MEMCPY\(I,J,7\)) N
(        :) N
(      END) N
() N
(/* cstring.c */) N
(#include <string.h>             /* string.h prototypes memcpy\(\) */) N
(#include "cfortran.h") N
() N
(        :) N
(FCALLSCSUB3\(memcpy,MEMCPY,memcpy,PVOID,PVOID,INT\)) N
(        :) N
() N
() N
(The simplicity exhibited in the above example exists for many but not all) N
(machines. Note 4. of Section II ii\) details the limitations and describes tools) N
(which try to maintain the best possible interface when FORTRAN calls C) N
(routines.) N
() N
(                                    -----) N
() N
() N
(II Using cfortran.h) N
(-------------------) N
() N
(The user is asked to look at the source files cfortest.c and cfortex.f) N
(for clarification by example.) N
() N
(o\) Notes: ) N
() N
(o Specifying the Fortran compiler) N
(  cfortran.h generates interfaces for the default Fortran compiler. The default) N
(can be overridden by defining, ) N
(     . in the code,              e.g.: #define    NAGf90Fortran) N
(  OR . in the compile directive, e.g.: unix> cc -DNAGf90Fortran) N
(one of the following before including cfortran.h:) N
( NAGf90Fortran   f2cFortran  hpuxFortran  apolloFortran  sunFortran) N
(  IBMR2Fortran  CRAYFortran  mipsFortran     DECFortran  vmsFortran) N
( CONVEXFortran       PowerStationFortran          AbsoftUNIXFortran) N
(     SXFortran   pgiFortran                        AbsoftProFortran) N
(This also allows crosscompilation.) N
(If wanted, NAGf90Fortran, f2cFortran, DECFortran, AbsoftUNIXFortran,) N
(AbsoftProFortran and pgiFortran must be requested by the user.) N
() N
(o /**/) N
(  cfortran.h \(ab\)uses the comment kludge /**/ when the ANSI C preprocessor) N
(catenation operator ## doesn't exist. In at least MIPS C, this kludge is) N
(sensitive to  blanks surrounding arguments to macros.) N
(  Therefore, for applications using non-ANSI C compilers, the argtype_i,) N
(routine_name, routine_type and common_block_name arguments to the) N
(PROTOCCALLSFFUNn, CCALLSFSUB/FUNn, FCALLSCSUB/FUNn and COMMON_BLOCK macros ) N
(--- MUST NOT --- be followed by any white space characters such as) N
(blanks, tabs or newlines.) N
() N
(o LOGICAL) N
(  FORTRAN LOGICAL values of .TRUE. and .FALSE. do not agree with the C) N
(representation of TRUE and FALSE on all machines. cfortran.h does the) N
(conversion for LOGICAL and PLOGICAL arguments and for functions returning) N
(cfortran.doc) (Page 7/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(LOGICAL. Users must convert arrays of LOGICALs from C to FORTRAN with the ) p n
(C2FLOGICALV\(array_name, elements_in_array\); macro. Similarly, arrays of LOGICAL) N
(values may be converted from the FORTRAN into C representation by using) N
(F2CLOGICALV\(array_name, elements_in_array\);) N
() N
(  When C passes or returns LOGICAL values to FORTRAN, by default cfortran.h ) N
(only makes the minimal changes required to the value. [e.g. Set/Unset the ) N
(single relevant bit or do nothing for FORTRAN compilers which use 0 as FALSE) N
(and treat all other values as TRUE.] Therefore cfortran.h will pass LOGICALs) N
(to FORTRAN which do not have an identical representation to .TRUE. or .FALSE.) N
(This is fine except for abuses of FORTRAN/77 in the style of:) N
(       logical l) N
(       if \(l .eq. .TRUE.\)     ! \(1\)) N
(instead of the correct:) N
(       if \(l .eqv. .TRUE.\)    ! \(2\)) N
(or:) N
(       if \(l\)                 ! \(3\)) N
(For FORTRAN code which treats LOGICALs from C in the method of \(1\),) N
(LOGICAL_STRICT must be defined before including cfortran.h, either in the) N
(code, "#define LOGICAL_STRICT", or compile with "cc -DLOGICAL_STRICT".) N
(There is no reason to use LOGICAL_STRICT for FORTRAN code which does not do \(1\).) N
(At least the IBM's xlf and the Apollo's f77 do not even allow code along the) N
(lines of \(1\).) N
() N
(  DECstations' DECFortran and MIPS FORTRAN compilers use different internal) N
(representations for LOGICAL values. [Both compilers are usually called f77,) N
(although when both are installed on a single machine the MIPS' one is usually) N
(renamed. \(e.g. f772.1 for version 2.10.\)] cc doesn't know which FORTRAN) N
(compiler is present, so cfortran.h assumes MIPS f77. To use cc with DECFortran) N
(define the preprocessor constant 'DECFortran'.) N
(e.g.        i\)  cc -DDECFortran -c the_code.c) N
(        or  ii\) #define DECFortran  /* in the C code or add to cfortran.h. */) N
() N
(  MIPS f77 [SGI and DECstations], f2c, and f77 on VAX Ultrix treat) N
(.eqv./.neqv. as .eq./.ne.. Therefore, for these compilers, LOGICAL_STRICT is) N
(defined by default in cfortran.h. [The Sun and HP compilers have not been) N
(tested, so they may also require LOGICAL_STRICT as the default.]) N
() N
(o SHORT and BYTE ) N
(  They are irrelevant for the CRAY where FORTRAN has no equivalent to C's short.) N
(Similarly BYTE is irrelevant for f2c and for VAX Ultrix f77 and fort. The) N
(author has tested SHORT and BYTE with a modified cfortest.c/cfortex.f on all) N
(machines supported except for the HP9000 and the Sun.) N
() N
(  BYTE is a signed 8-bit quantity, i.e. values are -128 to 127, on all machines) N
(except for the SGI [at least for MIPS Computer Systems 2.0.] On the SGI it is) N
(an unsigned 8-bit quantity, i.e. values are 0 to 255, although the SGI 'FORTRAN) N
(77 Programmers Guide' claims BYTE is signed. Perhaps MIPS 2.0 is dated, since) N
(the DECstations using MIPS 2.10 f77 have a signed BYTE.) N
() N
(  To minimize the difficulties of signed and unsigned BYTE, cfortran.h creates) N
(the type 'INTEGER_BYTE' to agree with FORTRAN's BYTE. Users may define ) N
(SIGNED_BYTE or UNSIGNED_BYTE, before including cfortran.h, to specify FORTRAN's) N
(BYTE. If neither is defined, cfortran.h assumes SIGNED_BYTE.) N
() N
(o CRAY) N
(  The type DOUBLE in cfortran.h corresponds to FORTRAN's DOUBLE PRECISION.) N
(  The type FLOAT  in cfortran.h corresponds to FORTRAN's REAL.) N
() N
(On a classic CRAY [i.e. all models except for the t3e]:) N
(\( 64 bit\) C float       == C double == Fortran REAL) N
(\(128 bit\) C long double             == Fortran DOUBLE PRECISION) N
(cfortran.doc) (Page 8/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (4/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (9-10) 5
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(Therefore when moving a mixed C and FORTRAN app. to/from a classic CRAY,) p n
(either the C code will have to change,) N
(or the FORTRAN code and cfortran.h declarations will have to change.) N
(DOUBLE_PRECISION is a cfortran.h macro which provides the former option,) N
(i.e. the C code is automatically changed.) N
(DOUBLE_PRECISION is 'long double' on classic CRAY and 'double' elsewhere.) N
(DOUBLE_PRECISION thus corresponds to FORTRAN's DOUBLE PRECISION) N
(on all machines, including classic CRAY.) N
() N
(On a classic CRAY with the fortran compiler flag '-dp':) N
(Fortran DOUBLE PRECISION thus is also the faster 64bit type.) N
(\(This switch is often used since the application is usually satisfied by) N
( 64 bit precision and the application needs the speed.\)) N
(DOUBLE_PRECISION is thus not required in this case,) N
(since the classic CRAY behaves like all other machines.) N
(If DOUBLE_PRECISION is used nonetheless, then on the classic CRAY) N
(the default cfortran.h behavior must be overridden,) N
(for example by the C compiler option '-DDOUBLE_PRECISION=double'.) N
() N
(On a CRAY t3e:) N
(\(32 bit\) C float                   == Fortran Unavailable) N
(\(64 bit\) C double == C long double == Fortran REAL == Fortran DOUBLE PRECISION) N
(Notes:) N
(- \(32 bit\) is available as Fortran REAL*4 and) N
(  \(64 bit\) is available as Fortran REAL*8.) N
(  Since cfortran.h is all about more portability, not about less portability,) N
(  the use of the nonstandard REAL*4 and REAL*8 is strongly discouraged.) N
(- Fortran DOUBLE PRECISION is folded to REAL with the following warning:) N
(    'DOUBLE PRECISION is not supported on this platform.  REAL will be used.') N
(  Similarly, Fortran REAL*16 is mapped to REAL*8 with a warning.) N
(This behavior differs from that of other machines, including the classic CRAY.) N
(FORTRAN_REAL is thus introduced for the t3e,) N
(just as DOUBLE_PRECISION is introduced for the classic CRAY.) N
(FORTRAN_REAL is 'double' on t3e and 'float' elsewhere.) N
(FORTRAN_REAL thus corresponds to FORTRAN's REAL on all machines, including t3e.) N
() N
() N
(o f2c) N
(  f2c, by default promotes REAL functions to double. cfortran.h does not \(yet\)) N
(support this, so the f2c -R option must be used to turn this promotion off.) N
() N
(o f2c) N
([Thanks to Dario Autiero for pointing out the following.]) N
(f2c has a strange feature in that either one or two underscores are appended) N
(to a Fortran name of a routine or common block,) N
(depending on whether or not the original name contains an underscore.) N
() N
(   S.I. Feldman et al., "A fortran to C converter",) N
(   Computing Science Technical Report No. 149.) N
() N
(   page 2, chapter 2: INTERLANGUAGE conventions) N
(   ...........) N
(   To avoid conflict with the names of library routines and with names that) N
(   f2c generates,) N
(   Fortran names may have one or two underscores appended. Fortran names are) N
(   forced to lower case \(unless the -U option described in Appendix B is in) N
(   effect\); external names, i.e. the names of fortran procedures and common) N
(   blocks, have a single underscore appended if they do not contain any) N
(   underscore and have a pair of underscores appended if they do contain) N
(   underscores. Thus fortran subroutines names ABC, A_B_C and A_B_C_ result) N
(   in C functions named abc_, a_b_c__ and a_b_c___.) N
(   ...........) N
(cfortran.doc) (Page 9/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(cfortran.h is unable to change the naming convention on a name by name basis.) N
(Fortran routine and common block names which do not contain an underscore) N
(are unaffected by this feature.) N
(Names which do contain an underscore may use the following work-around:) N
() N
(/* First 2 lines are a completely standard cfortran.h interface) N
(   to the Fortran routine E_ASY . */) N
(                  PROTOCCALLSFSUB2\(E_ASY,e_asy, PINT, INT\)) N
(#define E_ASY\(A,B\)     CCALLSFSUB2\(E_ASY,e_asy, PINT, INT, A, B\)) N
(#ifdef f2cFortran) N
(#define e_asy_ e_asy__) N
(#endif) N
(/* Last three lines are a work-around for the strange f2c naming feature. */) N
() N
(o NAG f90) N
(  The Fortran 77 subset of Fortran 90 is supported. Extending cfortran.h to ) N
(interface C with all of Fortran 90 has not yet been examined.) N
(  The NAG f90 library hijacks the main\(\) of any program and starts the user's ) N
(program with a call to: void f90_main\(void\);) N
(While this in itself is only a minor hassle, a major problem arises because) N
(NAG f90 provides no mechanism to access command line arguments.) N
(  At least version 'NAGWare f90 compiler Version 1.1\(334\)' appended _CB to) N
(common block names instead of the usual _. To fix, add this to cfortran.h:) N
(#ifdef old_NAG_f90_CB_COMMON) N
(#define COMMON_BLOCK                 CFC_  /* for all other Fortran compilers */) N
(#else) N
(#define COMMON_BLOCK\(UN,LN\)          _\(LN,_CB\)) N
(#endif) N
() N
(o RS/6000) N
(  Using "xlf -qextname ...", which appends an underscore, '_', to all FORTRAN) N
(external references, requires "cc -Dextname ..." so that cfortran.h also) N
(generates these underscores.) N
(Use -Dextname=extname if extname is a symbol used in the C code.) N
(The use of "xlf -qextname" is STRONGLY ENCOURAGED, since it allows for) N
(transparent naming schemes when mixing C and Fortran.) N
() N
(o HP9000) N
(  Using "f77 +ppu      ...", which appends an underscore, '_', to all FORTRAN) N
(external references, requires "cc -Dextname ..." so that cfortran.h also) N
(generates these underscores.) N
(Use -Dextname=extname if extname is a symbol used in the C code.) N
(The use of "f77 +ppu"      is STRONGLY ENCOURAGED, since it allows for) N
(transparent naming schemes when mixing C and Fortran.) N
() N
(  At least one release of the HP /lib/cpp.ansi preprocessor is broken and will) N
(go into an infinite loop when trying to process cfortran.h with the) N
(## catenation operator. The K&R version of cfortran.h must then be used and the) N
(K&R preprocessor must be specified. e.g.) N
(                                         HP9000> cc -Aa -tp,/lib/cpp -c source.c) N
(The same problem with a similar solution exists on the Apollo.) N
(An irrelevant error message '0: extraneous name /usr/include' will appear for) N
(each source file due to another HP bug, and can be safely ignored.) N
(e.g. 'cc -v -c -Aa -tp,/lib/cpp cfortest.c' will show that the driver passes) N
('-I /usr/include' instead of '-I/usr/include' to /lib/cpp) N
() N
(On some machines the above error causes compilation to stop; one must then use) N
(K&R C, as with old HP compilers which don't support function prototyping.) N
(cfortran.h has to be informed that K&R C is to being used, e.g.) N
(HP9000> cc -D__CF__KnR -c source.c) N
() N
(cfortran.doc) (Page 10/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (5/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (11-12) 6
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(o AbsoftUNIXFortran) p n
(By default, cfortran.h follows the default AbsoftUNIX/ProFortran and prepends _C) N
(to each COMMON BLOCK name. To override the cfortran.h behavior) N
(#define COMMON_BLOCK\(UN,LN\) before #including cfortran.h.) N
([Search for COMMON_BLOCK in cfortran.h for examples.]) N
() N
(o Apollo) N
(On at least one release, 'C compiler 68K Rev6.8\(168\)', the default C ) N
(preprocessor, from cc -A xansi or cc -A ansi, enters an infinite loop when ) N
(using cfortran.h. This Apollo bug can be circumvented by using:) N
(     . cc -DANSI_C_preprocessor=0 to force use of /**/, instead of '##'.) N
( AND . The pre-ANSI preprocessor, i.e. use cc -Yp,/usr/lib) N
(The same problem with a similar solution exists on the HP.) N
() N
(o Sun) N
(Old versions of cc\(1\), say <~1986, may require help for cfortran.h applications:) N
( . #pragma may not be understood, hence cfortran.h and cfortest.c may require) N
(   sun> mv cfortran.h cftmp.h && grep -v "^#pragma" <cftmp.h >cfortran.h) N
(   sun> mv cfortest.c cftmp.c && grep -v "^#pragma" <cftmp.c >cfortest.c) N
( . Old copies of math.h may not include the following from a newer math.h.) N
(   [For an ancient math.h on a 386 or sparc, get similar from a new math.h.]) N
(   #ifdef mc68000     /* 5 lines Copyright \(c\) 1988 by Sun Microsystems, Inc. */) N
(   #define FLOATFUNCTIONTYPE) S 32 T (int) N
(   #define RETURNFLOAT\(x\) ) S 32 T () S 40 T (return \(*\(int *\)\(&\(x\)\)\)) N
(   #define ASSIGNFLOAT\(x,y\)) S 32 T (*\(int *\)\(&x\) = y) N
(   #endif) N
() N
(o CRAY, Sun, Apollo [pre 6.8 cc], VAX Ultrix and HP9000) N
(  Only FORTRAN routines with less than 15 arguments can be prototyped for C,) N
(since these compilers don't allow more than 31 arguments to a C macro. This can) N
(be overcome, [see Section IV], with access to any C compiler without this) N
(limitation, e.g. gcc, on ANY machine.) N
() N
(o VAX Ultrix) N
(  vcc \(1\) with f77 is not supported. Although: ) N
(VAXUltrix> f77 -c cfortex.f) N
(VAXUltrix> vcc -o cfortest cfortest.c cfortex.o -lI77 -lU77 -lF77  &&  cfortest) N
(will link and run. However, the FORTRAN standard I/O is NOT merged with the) N
(stdin and stdout of C, and instead uses the files fort.6 and fort.5. For vcc,) N
(f77 can't drive the linking, as for gcc and cc, since vcc objects must be) N
(linked using lk \(1\).  f77 -v doesn't tell much, and without VAX Ultrix manuals,) N
(the author can only wait for the info. required.) N
() N
(  fort \(1\) is not supported. Without VAX Ultrix manuals the author cannot ) N
(convince vcc/gcc/cc and fort to generate names of routines and COMMON blocks) N
(that match at the linker, lk \(1\). i.e. vcc/gcc/cc prepend a single underscore) N
(to external references, e.g. NAME becomes _NAME, while fort does not modify the) N
(references. So ... either fort has prepend an underscore to external) N
(references, or vcc/gcc/cc have to generate unmodified names. man 1 fort) N
(mentions JBL, is JBL the only way?) N
() N
(o VAX VMS C) N
(  The compiler 'easily' exhausts its table space and generates:) N
(%CC-F-BUGCHECK, Compiler bug check during parser phase    .) N
(                Submit an SPR with a problem description.) N
(                At line number 777 in DISK:[DIR]FILE.C;1.) N
(where the line given, '777', includes a call across C and FORTRAN via) N
(cfortran.h, usually with >7 arguments and/or very long argument expressions.) N
(This SPR can be staved off, with the simple modification to cfortran.h, such) N
(that the relevant CCALLSFSUBn \(or CCALLSFFUNn or FCALLSCFUNn\) is not) N
(cascaded up to CCALLSFSUB14, and instead has its own copy of the contents of ) N
(CCALLSFSUB14. [If these instructions are not obvious after examining cfortran.h) N
(cfortran.doc) (Page 11/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(please contact the author.]) p n
([Thanks go to Mark Kyprianou \(kyp@stsci.edu\) for this solution.]) N
() N
(o Mips compilers) N
(  e.g. DECstations and SGI, require applications with a C main\(\) and calls to) N
(GETARG\(3F\), i.e. FORTRAN routines returning the command line arguments, to use) N
(two macros as shown:) N
(        :) N
(CF_DECLARE_GETARG;              /* This must be external to all routines.     */) N
(        :) N
(main\(int argc, char *argv[]\)) N
({) N
(        :) N
(CF_SET_GETARG\(argc,argv\);       /* This must precede any calls to GETARG\(3F\). */) N
(        :) N
(}) N
(The macros are null and benign on all other systems. Sun's GETARG\(3F\) also) N
(doesn't work with a generic C main\(\) and perhaps a workaround similar to the) N
(Mips' one exists.) N
() N
(o Alpha/OSF) N
(Using the DEC Fortran and the DEC C compilers of DEC OSF/1 [RT] V1.2 \(Rev. 10\),) N
(Fortran, when called from C, has occasional trouble using a routine received as) N
(a dummy argument.) N
() N
(e.g. In the following the Fortran routine 'e' will crash when it tries to use) N
(     the C routine 'c' or the Fortran routine 'f'.) N
(     The example works on other systems.) N
() N
(C FORTRAN                           /* C */) N
(      integer function f\(\)          #include <stdio.h>) N
(      f = 2                         int f_\(\);) N
(      return                        int e_\(int \(*u\)\(\)\);) N
(      end) N
(                                    int c\(\){ return 1;}) N
(      integer function e\(u\)         int d \(int \(*u\)\(\)\) { return u\(\);}) N
(      integer u) N
(      external u                    main\(\)) N
(      e=u\(\)                         {         /* Calls to d  work.  */) N
(      return                        printf\("d \(c \) returns %d.\\n",d \(c \)\);) N
(      end                           printf\("d \(f_\) returns %d.\\n",d \(f_\)\);) N
(                                              /* Calls to e_ crash. */) N
(                                    printf\("e_\(c \) returns %d.\\n",e_\(c \)\);) N
(                                    printf\("e_\(f_\) returns %d.\\n",e_\(f_\)\);) N
(                                    }) N
() N
(Solutions to the problem are welcomed!) N
(A kludge which allows the above example to work correctly, requires an extra) N
(argument to be given when calling the dummy argument function.) N
(i.e. Replacing 'e=u\(\)' by 'e=u\(1\)' allows the above example to work.) N
() N
() N
(o The FORTRAN routines are called using macro expansions, therefore the usual) N
(caveats for expressions in arguments apply. The expressions to the routines may) N
(be evaluated more than once, leading to lower performance and in the worst case) N
(bizarre bugs.) N
() N
(o For those who wish to use cfortran.h in large applications. [See Section IV.]) N
(This release is intended to make it easy to get applications up and running. ) N
(This implies that applications are not as efficient as they could be:) N
(- The current mechanism is inefficient if a single header file is used to) N
(  describe a large library of FORTRAN functions. Code for a static wrapper fn.) N
(cfortran.doc) (Page 12/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (6/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (13-14) 7
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  is generated in each piece of C source code for each FORTRAN function ) p n
(  specified with the CCALLSFFUNn statement, irrespective of whether or not the) N
(  function is ever called. ) N
(- Code for several static utility routines internal to cfortran.h is placed ) N
(  into any source code which #includes cfortran.h. These routines should) N
(  probably be in a library.) N
() N
() N
(i\) Calling FORTRAN routines from C:) N
(   --------------------------------) N
() N
(The FORTRAN routines are defined by one of the following two instructions:) N
() N
(for a SUBROUTINE:) N
(/* PROTOCCALLSFSUBn is optional for C, but mandatory for C++. */) N
(PROTOCCALLSFSUBn\(ROUTINE_NAME,routine_name,argtype_1,...,argtype_n\)) N
(#define     Routine_name\(argname_1,..,argname_n\)               \\) N
(CCALLSFSUBn\(ROUTINE_NAME,routine_name,argtype_1,...,argtype_n, \\) N
(                         argname_1,..,argname_n\) ) N
() N
(for a FUNCTION:) N
(PROTOCCALLSFFUNn\(routine_type,ROUTINE_NAME,routine_name,argtype_1,...,argtype_n\)) N
(#define     Routine_name\(argname_1,..,argname_n\)               \\) N
(CCALLSFFUNn\(ROUTINE_NAME,routine_name,argtype_1,...,argtype_n, \\) N
(                         argname_1,..,argname_n\) ) N
() N
(Where:) N
('n' = 0->14 [SUBROUTINE's ->27] \(easily expanded in cfortran.h to > 14 [27]\) is ) N
(    the number of arguments to the routine.) N
(Routine_name = C       name of the routine \(IN UPPER CASE LETTERS\).[see 2.below]) N
(ROUTINE_NAME = FORTRAN name of the routine \(IN UPPER CASE LETTERS\).) N
(routine_name = FORTRAN name of the routine \(IN lower case LETTERS\).) N
(routine_type = the type of argument returned by FORTRAN functions.) N
(             = BYTE, DOUBLE, FLOAT, INT, LOGICAL, LONG, SHORT, STRING, VOID.) N
(               [Instead of VOID one would usually use CCALLSFSUBn.) N
(                VOID forces a wrapper function to be used.]) N
(argtype_i    = the type of argument passed to the FORTRAN routine and must be) N
(               consistent in the definition and prototyping of the routine s.a.) N
(             = BYTE, DOUBLE, FLOAT, INT, LOGICAL, LONG, SHORT, STRING.) N
(             For vectors, i.e. 1 dim. arrays use ) N
(             = BYTEV, DOUBLEV, FLOATV, INTV, LOGICALV, LONGV, SHORTV, ) N
(               STRINGV, ZTRINGV.) N
(             For vectors of vectors, i.e. 2 dim. arrays use) N
(             = BYTEVV, DOUBLEVV, FLOATVV, INTVV, LOGICALVV, LONGVV, SHORTVV.) N
(             For n-dim. arrays, 1<=n<=7 [7 is the maximum in Fortran 77],) N
(             = BYTEV..nV's..V, DOUBLEV..V, FLOATV..V, INTV..V, LOGICALV..V, ) N
(               LONGV..V, SHORTV..V.) N
(                N.B. Array dimensions and types are checked by the C compiler.) N
(             For routines changing the values of an argument, the keyword is ) N
(                  prepended by a 'P'.) N
(             = PBYTE, PDOUBLE, PFLOAT, PINT, PLOGICAL, PLONG, PSHORT,) N
(               PSTRING, PSTRINGV, PZTRINGV.) N
(             For EXTERNAL procedures passed as arguments use) N
(             = ROUTINE.) N
(             For exceptional arguments which require no massaging to fit the) N
(                  argument passing mechanisms use) N
(             = PVOID.) N
(                The argument is cast and passed as \(void *\).) N
(                Although PVOID could be used to describe all array arguments on) N
(                most \(all?\) machines , it shouldn't be because the C compiler) N
(                can no longer check the type and dimension of the array.) N
(argname_i    = any valid unique C tag, but must be consistent in the definition ) N
(cfortran.doc) (Page 13/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(               as shown.) p n
() N
(Notes:) N
() N
(1. cfortran.h may be expanded to handle a more argument type. To suppport new) N
(arguments requiring complicated massaging when passed  between Fortran and C,) N
(the user will have to understand cfortran.h and follow its code and mechanisms.) N
() N
(To define types requiring little or no massaging when passed between Fortran ) N
(and C, the pseudo argument type SIMPLE may be used.) N
(For a user defined type called 'newtype', the definitions required are:) N
() N
(/* The following 7 lines are required verbatim.) N
(   'newtype' is the name of the new user defined argument type.) N
(*/) N
(#define newtype_cfV\(  T,A,B,F\)       SIMPLE_cfV\(T,A,B,F\)) N
(#define newtype_cfSEP\(T,  B\)         SIMPLE_cfSEP\(T,B\)) N
(#define newtype_cfINT\(N,A,B,X,Y,Z\)   SIMPLE_cfINT\(N,A,B,X,Y,Z\)) N
(#define newtype_cfSTR\(N,T,A,B,C,D,E\) SIMPLE_cfSTR\(N,T,A,B,C,D,E\)) N
(#define newtype_cfCC\( T,A,B\)         SIMPLE_cfCC\(T,A,B\)) N
(#define newtype_cfAA\( T,A,B\)         newtype_cfB\(T,A\) /* Argument B not used. */) N
(#define newtype_cfU\(  T,A\)           newtype_cfN\(T,A\)) N
() N
(/* 'parameter_type\(A\)' is a declaration for 'A' and describes the type of the ) N
(parameter expected by the Fortran function.  This type will be used in the) N
(prototype for the function, if  using ANSI C, and to declare the argument used) N
(by the intermediate function if calling a Fortran FUNCTION.) N
(Valid 'parameter_type\(A\)' include: int A) N
(                                   void \(*A\)\(\)) N
(                                   double A[17]) N
(*/) N
(#define newtype_cfN\(  T,A\)     parameter_type\(A\)      /* Argument T not used. */) N
() N
(/* Before any argument of the new type is passed to the Fortran routine, it may) N
(be massaged as given by 'massage\(A\)'.) N
(*/) N
(#define newtype_cfB\(  T,A\)     massage\(A\)             /* Argument T not used. */) N
() N
(An example of a simple user defined type is given cfortex.f and cfortest.c.) N
(Two uses of SIMPLE user defined types are [don't show the 7 verbatim #defines]:) N
() N
(/* Pass the address of a structure, using a type called PSTRUCT */) N
(#define PSTRUCT_cfN\(  T,A\)        void *A) N
(#define PSTRUCT_cfB\(  T,A\)       \(void *\) &\(A\)) N
() N
(/* Pass an integer by value, \(not standard F77 \), using a type called INTVAL */) N
(#define INTVAL_cfN\(   T,A\)      int A) N
(#define INTVAL_cfB\(   T,A\)         \(A\)) N
() N
([If using VAX VMS, surrounding the #defines with "#pragma \(no\)standard" allows) N
( the %CC-I-PARAMNOTUSED messages to be avoided.]) N
() N
(Upgrades to cfortran.h try to be, and have been, backwards compatible. This) N
(compatibility cannot be offered to user defined types. SIMPLE user defined ) N
(types are less of a risk since they require so little effort in their creation.) N
(If a user defined type is required in more than one C header file of interfaces) N
(to libraries of Fortran routines, good programming practice, and ease of code) N
(maintenance, suggests keeping any user defined type within a single file which) N
(is #included as required. To date, changes to the SIMPLE macros were introduced) N
(in versions 2.6, 3.0 and 3.2 of cfortran.h.) N
() N
() N
(cfortran.doc) (Page 14/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (7/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (15-16) 8
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(2. Routine_name is the name of the macro which the C programmer will use in) p n
(order to call a FORTRAN routine. In theory Routine_name could be any valid and) N
(unique name, but in practice, the name of the FORTRAN routine in UPPER CASE) N
(works everywhere and would seem to be an obvious choice.) N
() N
() N
(3. <BYTE|DOUBLE|BYTE|DOUBLE|FLOAT|INT|LOGICAL|LONG|SHORT><V|VV|VVV|...>) N
() N
(cfortran.h encourages the exact specification of the type and dimension of) N
(array parameters because it allows the C compiler to detect errors in the) N
(arguments when calling the routine.) N
() N
(cfortran.h does not strictly require the exact specification since the argument ) N
(is merely the address of the array and is passed on to the calling routine.) N
(Any array parameter could be declared as PVOID, but this circumvents) N
(C's compiletime ability to check the correctness of arguments and is therefore) N
(discouraged.) N
() N
(Passing the address of these arguments implies that PBYTEV, PFLOATV, ... ,) N
(PDOUBLEVV, ... don't exist in cfortran.h, since by default the routine and the) N
(calling code share the same array, i.e. the same values at the same memory) N
(location.) N
() N
(These comments do NOT apply to arrays of \(P\)S/ZTRINGV. For these parameters,) N
(cfortran.h passes a massaged copy of the array to the routine. When the routine) N
(returns, S/ZTRINGV ignores the copy, while PS/ZTRINGV replaces the calling) N
(code's original array with copy, which may have been modified by the called) N
(routine.) N
() N
() N
(4. \(P\)STRING\(V\):) N
(- STRING - If the argument is a fixed length character array, e.g. char ar[8];,) N
(the string is blank, ' ', padded on the right to fill out the array before) N
(being passed to the FORTRAN routine. The useful size of the string is the same) N
(in both languages, e.g. ar[8] is passed as character*7. If the argument is a) N
(pointer, the string cannot be blank padded, so the length is passed as) N
(strlen\(argument\). On return from the FORTRAN routine, pointer arguments are not) N
(disturbed, but arrays have the terminating '\\0' replaced to its original) N
(position. i.e. The padding blanks are never visible to the C code.) N
() N
(- PSTRING - The argument is massaged as with STRING before being passed to the) N
(FORTRAN routine. On return, the argument has all trailing blanks removed,) N
(regardless of whether the argument was a pointer or an array.) N
() N
(- \(P\)STRINGV - Passes a 1- or 2-dimensional char array. e.g. char a[7],b[6][8];) N
(STRINGV may thus also pass a string constant, e.g. "hiho".) N
(\(P\)STRINGV does NOT pass a pointer, e.g. char *, to either a 1- or a) N
(2-dimensional array, since it cannot determine the array dimensions.) N
(A pointer can only be passed using \(P\)ZTRINGV.) N
(N.B. If a C routine receives a character array argument, e.g. char a[2][3],) N
(     such an argument is actually a pointer and my thus not be passed by) N
(     \(P\)STRINGV. Instead \(P\)ZTRINGV must be used.) N
() N
(- STRINGV - The elements of the argument are copied into space malloc'd, and) N
(each element is padded with blanks. The useful size of each element is the same) N
(in both languages. Therefore char bb[6][8]; is equivalent to character*7 bb\(6\).) N
(On return from the routine the malloc'd space is simply released.) N
() N
(- PSTRINGV - Since FORTRAN has no trailing '\\0', elements in an array of) N
(strings are contiguous. Therefore each element of the C array is padded with) N
(blanks and strip out C's trailing '\\0'. After returning from the routine, the) N
(trailing '\\0' is reinserted and kill the trailing blanks in each element.) N
(cfortran.doc) (Page 15/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(- SUMMARY: STRING\(V\) arguments are blank padded during the call to the FORTRAN) N
(routine, but remain original in the C code. \(P\)STRINGV arguments are blank) N
(padded for the FORTRAN call, and after returning from FORTRAN trailing blanks) N
(are stripped off.) N
() N
() N
(5. \(P\)ZTRINGV:) N
(- \(P\)ZTRINGV - is identical to \(P\)STRINGV,) N
(except that the dimensions of the array of strings is explicitly specified,) N
(which thus also allows a pointer to be passed.) N
(\(P\)ZTRINGV can thus pass a 1- or 2-dimensional char array, e.g. char b[6][8],) N
(or it can pass a pointer to such an array, e.g. char *p;.) N
(ZTRINGV may thus also pass a string constant, e.g. "hiho".) N
(If passing a 1-dimensional array, routine_name_ELEMS_j \(see below\) must be 1.) N
([Users of \(P\)ZTRINGV should examine cfortest.c for examples.]:) N
() N
(- \(P\)ZTRINGV must thus be used instead of \(P\)STRINGV whenever sizeof\(\)) N
(can't be used to determine the dimensions of the array of string or strings.) N
(e.g. when calling FORTRAN from C with a char * received by C as an argument.) N
() N
(- There is no \(P\)ZTRING type, since \(P\)ZTRINGV can pass a 1-dimensional) N
(array or a pointer to such an array, e.g. char a[7], *b;) N
(If passing a 1-dimensional array, routine_name_ELEMS_j \(see below\) must be 1.) N
() N
(- To specify the numbers of elements,) N
(routine_name_ELEMS_j and routine_name_ELEMLEN_j must be defined as shown below) N
(before interfacing the routine with CCALLSFSUBn, PROTOCCALLSFFUNn, etc.) N
() N
(#define routine_name_ELEMS_j   ZTRINGV_ARGS\(k\)       ) N
(                                 [..ARGS for subroutines, ..ARGF for functions.]) N
(or) N
(#define routine_name_ELEMS_j   ZTRINGV_NUM\(l\)) N
(Where: routine_name is as above.) N
(       j            [1-n], is the argument being specifying.) N
(       k            [1-n], the value of the k'th argument is the dynamic number) N
(                    of elements for argument j. The k'th argument must be) N
(                    of type BYTE, DOUBLE, FLOAT, INT, LONG or SHORT.) N
(       l            the number of elements for argument j. This must be an) N
(                    integer constant available at compile time.) N
(                    i.e. it is static.) N
() N
(- Similarly to specify the useful length, [i.e. don't count C's trailing '\\0',]) N
(of each element:) N
(#define routine_name_ELEMLEN_j ZTRINGV_ARGS\(m\)) N
(                                 [..ARGS for subroutines, ..ARGF for functions.]) N
(or) N
(#define routine_name_ELEMLEN_j ZTRINGV_NUM\(q\)) N
(Where: m            [1-n], as for k but this is the length of each element. ) N
(       q            as for l but this is the length of each element. ) N
() N
() N
(6. ROUTINE) N
(The argument is an EXTERNAL procedure.) N
() N
(When C passes a routine to Fortran, the language of the function must be) N
(specified as follows:  [The case of some_*_function must be given as shown.]) N
() N
(When C passes a C routine to a Fortran: ) N
(    FORTRAN_ROUTINE\(arg1, .... ,       ) N
(                    C_FUNCTION\(SOME_C_FUNCTION,some_c_function\),) N
(                    ...., argn\);) N
(cfortran.doc) (Page 16/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (8/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (17-18) 9
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(and similarly when C passes a Fortran routine to Fortran:) N
(    FORTRAN_ROUTINE\(arg1, .... ,) N
(                    FORTRAN_FUNCTION\(SOME_FORT_FUNCTION,some_fort_function\),) N
(                    ...., argn\);) N
() N
(If fcallsc has been redefined; the same definition of fcallsc used when creating) N
(the wrapper for 'some_c_function' must also be defined when C_FUNCTION is used.) N
(See ii\) 4. of this section for when and how to redefine fcallsc.) N
() N
(ROUTINE was introduced with cfortran.h version 2.6. Earlier versions of) N
(cfortran.h used PVOID to pass external procedures as arguments. Using PVOID for) N
(this purpose is no longer recommended since it won't work 'as is' for) N
(apolloFortran, hpuxFortran800, AbsoftUNIXFortran, AbsoftProFortran.) N
() N
(7. CRAY only: ) N
(In a given piece of source code, where FFUNC is any FORTRAN routine,) N
(FORTRAN_FUNCTION\(FFUNC,ffunc\)) N
(disallows a previous ) N
(#define FFUNC\(..\) CCALLSFSUBn\(FFUNC,ffunc,...\) [ or CCALLSFFUNn]) N
(in order to make the UPPER CASE FFUNC callable from C.) N
(#define Ffunc\(..\) ... is OK though, as are obviously any other names.) N
() N
() N
(ii\) Calling C routines from FORTRAN:) N
(    --------------------------------) N
() N
(Each of the following two statements to export a C routine to FORTRAN create) N
(FORTRAN 'wrappers', written in C, which must be compiled and linked along with) N
(the original C routines and with the FORTRAN calling code.) N
() N
(FORTRAN callable 'wrappers' may also be created for C macros. i.e. in this) N
(section, the term 'C function' may be replaced by 'C macro'.) N
() N
(for C functions returning void:) N
(FCALLSCSUBn\(             Routine_name,ROUTINE_NAME,routine_name,argtype_1,...,ar) N
(gtype_n\)) N
() N
(for all other C functions:) N
(FCALLSCFUNn\(routine_type,Routine_name,ROUTINE_NAME,routine_name,argtype_1,...,ar) N
(gtype_n\)) N
() N
(Where:) N
('n' = 0->27 \(easily expanded to > 27\) stands for the number of arguments to the ) N
(    routine.) N
(Routine_name = the C       name of the routine. [see 9. below]) N
(ROUTINE_NAME = the FORTRAN name of the routine \(IN UPPER CASE LETTERS\).) N
(routine_name = the FORTRAN name of the routine \(IN lower case LETTERS\).) N
(routine_type = the type of argument returned by C functions.) N
(             = BYTE, DOUBLE, FLOAT, INT, LOGICAL, LONG, SHORT, STRING, VOID.) N
(               [Instead of VOID, FCALLSCSUBn is recommended.]) N
(argtype_i    = the type of argument passed to the FORTRAN routine and must be) N
(               consistent in the definition and prototyping of the routine) N
(             = BYTE, DOUBLE, FLOAT, INT, LOGICAL, LONG, SHORT, STRING.) N
(             For vectors, i.e. 1 dim. arrays use ) N
(             = BYTEV, DOUBLEV, FLOATV, INTV, LOGICALV, LONGV, SHORTV, STRINGV.) N
(             For vectors of vectors, 2 dim. arrays use) N
(             = BYTEVV, DOUBLEVV, FLOATVV, INTVV, LOGICALVV, LONGVV, SHORTVV.) N
(             For n-dim. arrays use) N
(             = BYTEV..nV's..V, DOUBLEV..V, FLOATV..V, INTV..V, LOGICALV..V, ) N
(               LONGV..V, SHORTV..V.) N
(             For routines changing the values of an argument, the keyword is ) N
(cfortran.doc) (Page 17/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                  prepended by a 'P'.) p n
(             = PBYTE, PDOUBLE, PFLOAT, PINT, PLOGICAL, PLONG, PSHORT, ) N
(               PSTRING, PNSTRING, PPSTRING, PSTRINGV.) N
(             For EXTERNAL procedures passed as arguments use) N
(             = ROUTINE.) N
(             For exceptional arguments which require no massaging to fit the) N
(                  argument passing mechanisms use) N
(             = PVOID.) N
(                The argument is cast and passed as \(void *\).) N
() N
() N
(Notes:) N
() N
(0. For Fortran calling C++ routines, C++ does NOT easily allow support for: ) N
(   STRINGV.) N
(   BYTEVV, DOUBLEVV, FLOATVV, INTVV, LOGICALVV, LONGVV, SHORTVV.) N
(   BYTEV..V, DOUBLEV..V, FLOATV..V, INTV..V, LOGICALV..V, LONGV..V, SHORTV..V.) N
(Though there are ways to get around this restriction,) N
(the restriction is not serious since these types are unlikely to be used as) N
(arguments for a C++ routine.) N
() N
(1. FCALLSCSUB/FUNn expect that the routine to be 'wrapped' has been properly) N
(prototyped, or at least declared.) N
() N
() N
(2. cfortran.h may be expanded to handle a new argument type not already among) N
(the above. ) N
() N
() N
(3. <BYTE|DOUBLE|BYTE|DOUBLE|FLOAT|INT|LOGICAL|LONG|SHORT><V|VV|VVV|...>) N
() N
(cfortran.h encourages the exact specification of the type and dimension of) N
(array parameters because it allows the C compiler to detect errors in the) N
(arguments when declaring the routine using FCALLSCSUB/FUNn, assuming the) N
(routine to be 'wrapped' has been properly prototyped.) N
() N
(cfortran.h does not strictly require the exact specification since the argument ) N
(is merely the address of the array and is passed on to the calling routine.) N
(Any array parameter could be declared as PVOID, but this circumvents) N
(C's compiletime ability to check the correctness of arguments and is therefore) N
(discouraged.) N
() N
(Passing the address of these arguments implies that PBYTEV, PFLOATV, ... ,) N
(PDOUBLEVV, ... don't exist in cfortran.h, since by default the routine and the) N
(calling code share the same array, i.e. the same values at the same memory) N
(location.) N
() N
(These comments do NOT apply to arrays of \(P\)STRINGV. For these parameters,) N
(cfortran.h passes a massaged copy of the array to the routine. When the routine) N
(returns, STRINGV ignores the copy, while PSTRINGV replaces the calling) N
(code's original array with copy, which may have been modified by the called) N
(routine.) N
() N
() N
(4. \(P\(N\)\)STRING arguments have any trailing blanks removed before being passed) N
(to C, the same holds true for each element in \(P\)STRINGV. Space is malloc'd in) N
(all cases big enough to hold the original string \(elements\) as well as C's) N
(terminating '\\0'. i.e. The useful size of the string \(elements\) is the same in) N
(both languages. P\(N\)STRING\(V\) => the string \(elements\) will be copied from the) N
(malloc'd space back into the FORTRAN bytes. If one of the two escape mechanisms) N
(mentioned below for PNSTRING has been used, the copying back to FORTRAN is) N
(obviously not relevant.) N
(cfortran.doc) (Page 18/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (9/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (19-20) 10
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
() N
(5. \(PN\)STRING's, [NOT PSTRING's nor \(P\)STRINGV's,] behavior may be overridden) N
(in two cases.  In both cases PNSTRING and STRING behave identically.) N
() N
(a\) If a \(PN\)STRING argument's first 4 bytes are all the NUL character,) N
(i.e. '\\0\\0\\0\\0' the NULL pointer is passed to the C routine.) N
() N
(b\) If the characters of a \(PN\)STRING argument contain at least one HEX-00, i.e.) N
(the NUL character, i.e. C strings' terminating '\\0', the address of the string) N
(is simply passed to the C routine. i.e. The argument is treated in this case as) N
(it would be with PPSTRING, to which we refer the reader for more detail.) N
() N
(Mechanism a\) overrides b\). Therefore, to use this mechanism to pass the NULL) N
(string, "", to C, the first character of the string must obviously be the NUL) N
(character, but of the first 4 characters in the string, at least one must not) N
(be HEX-00.) N
() N
(Example:) N
(C FORTRAN                         /* C */) N
(      character*40 str            #include "cfortran.h") N
(C Set up a NULL as :              void cs\(char *s\) {if \(s\) printf\("%s.\\n",s\);}) N
(C    i\)  4 NUL characters.        FCALLSCSUB1\(cs,CS,cs,STRING\)) N
(C    ii\) NULL pointer.) N
(      character*4 NULL        ) N
(      NULL = CHAR\(0\)//CHAR\(0\)//CHAR\(0\)//CHAR\(0\)) N
() N
(      data str/'just some string'/) N
() N
(C Passing the NULL pointer to cs.) N
(      call cs\(NULL\)) N
(C Passing a copy of 'str' to cs.) N
(      call cs\(str\)) N
(C Passing address of 'str' to cs. Trailing blanks NOT killed.) N
(      str\(40:\) = NULL) N
(      call cs\(str\)) N
(      end) N
() N
(Strings passed from Fortran to C via \(PN\)STRING must not have undefined) N
(contents, otherwise undefined behavior will result, since one of the above two) N
(escape mechanisms may occur depending on the contents of the string.) N
() N
(This is not be a problem for STRING arguments, which are read-only in the C) N
(routine and hence must have a well defined value when being passed in.) N
() N
(PNSTRING arguments require special care. Even if they are write-only in the C) N
(routine, PNSTRING's above two escape mechanisms require that the value of the) N
(argument be well defined when being passed in from Fortran to C. Therefore,) N
(unless one or both of PNSTRING's escape mechanisms are required, PSTRING should) N
(be used instead of PNSTRING.) N
(Prior to version 2.8, PSTRING did have the above two escape mechanisms,) N
(but they were removed from PSTRING to allow strings with undefined contents to) N
(be passed in. PNSTRING behaves like the old PSTRING.) N
([Thanks go to Paul Dubois \(dubios@icf.llnl.gov\) for pointing out that PSTRING) N
( must allow for strings with undefined contents to be passed in.]) N
() N
(Example:) N
(C FORTRAN                         /* C */) N
(      character*10 s,sn           #include "cfortran.h") N
(                                  void ps\(char *s\) {strcpy\(s,"hello"\);}) N
(C Can   call ps  with undef. s.   FCALLSCSUB1\(ps,PS,ps,PSTRING\)) N
(      call ps\(s\)                  FCALLSCSUB1\(ps,PNS,pns,PNSTRING\)) N
(cfortran.doc) (Page 19/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      print *,s,'=s') p n
(                              ) N
(C Can't call pns with undef. s.) N
(C e.g. If first 4 bytes of s were) N
(C      "\\0\\0\\0\\0", ps would try) N
(C      to copy to NULL because) N
(C      of PNSTRING mechanism.) N
(      sn = "") N
(      call pns\(sn\)) N
(      print *,sn,'=sn') N
(                                               ) N
(      end) N
() N
() N
(6. PPSTRING) N
(The address of the string argument is simply passed to the C routine. Therefore) N
(the C routine and the FORTRAN calling code share the same string at the same) N
(memory location. If the C routine modifies the string, the string will also be) N
(modified for the FORTRAN calling code.) N
(The user is responsible for negociating the differences in representation of a) N
(string in Fortran and in C, i.e. the differences are not automatically resolved) N
(as they are for \(P\(N\)STRING\(V\).) N
(This mechanism is provided for two reasons:) N
(   - Some C routines require the string to exist at the given memory location, ) N
(     after the C routine has exited. Recall that for the usual \(P\(N\)STRING\(V\)) N
(     mechanism, a copy of the FORTRAN string is given to the C routine, and this) N
(     copy ceases to exist after returning to the FORTRAN calling code.) N
(   - This mechanism can save runtime CPU cycles over \(P\(N\)STRING\(V\), since it) N
(     does not perform their malloc, copy and kill trailing blanks of the string) N
(     to be passed.) N
(     Only in a small minority of cases does the potential benefit of the saved) N
(     CPU cycles outweigh the programming effort required to manually resolve) N
(     the differences in representation of a string in Fortran and in C.) N
() N
(For arguments passed via PPSTRING, the argument passed may also be an array of) N
(strings.) N
() N
() N
(7. ROUTINE) N
(ANSI C requires that the type of the value returned by the routine be known,) N
(For all ROUTINE arguments passed from Fortran to C, the type of ROUTINE is) N
(specified by defining a cast as follows:) N
() N
(#undef  ROUTINE_j) N
(#define ROUTINE_j   \(cast\)) N
(where:) N
(       j            [1-n], is the argument being specifying.) N
(       \(cast\)       is a cast matching that of the argument expected by the C) N
(                    function protoytpe for which a wrapper is being defined.) N
() N
(e.g. To create a Fortran wrapper for qsort\(3C\):) N
(#undef  ROUTINE_4) N
(#define ROUTINE_4 \(int \(*\)\(void *,void *\)\)) N
(FCALLSCSUB4\(qsort,FQSORT,fqsort,PVOID,INT,INT,ROUTINE\)) N
() N
(In order to maintain backward compatibility, cfortran.h defines a generic cast) N
(for ROUTINE_1, ROUTINE_2, ..., ROUTINE_27. The user's definition is therefore) N
(strictly required only for DEC C, which at the moment is the only compiler) N
(which insists on the correct cast for pointers to functions.) N
() N
(When using the ROUTINE argument inside some Fortran code:) N
(- it is difficult to pass a C routine as the parameter,) N
(cfortran.doc) (Page 20/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (10/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (21-22) 11
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  since in many Fortran implementations,) p n
(  Fortran has no access to the normal C namespace.) N
(  e.g. For most UNIX,) N
(       Fortran implicitly only has access to C routines ending in _.) N
(  If the calling Fortran code receives the routine as a parameter) N
(  it can of course easily pass it along.) N
(- if a Fortran routine is passed directly as the parameter,) N
(  the called C routine must call the parameter routine) N
(  using the Fortran argument passing conventions.) N
(- if a Fortran routine is to be passed as the parameter,) N
(  but if Fortran can be made to pass a C routine as the parameter,) N
(  then it may be best to pass a C-callable wrapper for the Fortran routine.) N
(  The called C routine is thus spared all Fortran argument passing conventions.) N
(  cfortran.h can be used to create such a C-callable wrapper) N
(  to the parameter Fortran routine.) N
() N
(ONLY PowerStationFortran:) N
(This Fortran provides no easy way to pass a Fortran routine as an argument to a) N
(C routine. The problem arises because in Fortran the stack is cleared by the) N
(called routine, while in C/C++ it is cleared by the caller.) N
(The C/C++ stack clearing behavior can be changed to that of Fortran by using) N
(stdcall__ in the function prototype. The stdcall__ cannot be applied in this) N
(case since the called C routine expects the ROUTINE parameter to be a C routine) N
(and does not know that it should apply stdcall__.) N
(In principle the cfortran.h generated Fortran callable wrapper for the called C) N
(routine should be able to massage the ROUTINE argument such that stdcall__ is) N
(performed, but it is not yet known how this could be easily done.) N
() N
() N
(8. THE FOLLOWING INSTRUCTIONS ARE NOT REQUIRED FOR VAX VMS) N
(                                  ------------) N
(\(P\)STRINGV information [NOT required for VAX VMS]: cfortran.h cannot convert) N
(the FORTRAN vector of STRINGS to the required C vector of STRINGS without) N
(explicitly knowing the number of elements in the vector. The application must) N
(do one of the following for each \(P\)STRINGV argument in a routine before that) N
(routine's FCALLSCFUNn/SUBn is called:) N
() N
(#define routine_name_STRV_Ai NUM_ELEMS\(j\)) N
( or) N
(#define routine_name_STRV_Ai NUM_ELEM_ARG\(k\)) N
( or) N
(#define routine_name_STRV_Ai TERM_CHARS\(l,m\)) N
() N
(where: routine_name     is as above.) N
(       i [i=1->n.]      specifies the argument number of a STRING VECTOR.) N
(       j                would specify a fixed number of elements. ) N
(       k [k=1->n. k!=i] would specify an integer argument which specifies the) N
(                        number of elements.) N
(       l [char]         the terminating character at the beginning of an) N
(                        element, indicating to cfortran.h that the preceding) N
(                        elements in the vector are the valid ones.) N
(       m [m=1-...]      the number of terminating characters required to appear) N
(                        at the beginning of the terminating string element.) N
(                        The terminating element is NOT passed on to ) N
(                        the C routine.) N
() N
(e.g.      #define ce_STRV_A1 TERM_CHARS\(' ',2\)) N
(          FCALLSCSUB1\(ce,CE,ce,STRINGV\)) N
() N
(cfortran.h will pass on all elements, in the 1st and only argument to the C) N
(routine ce, of the STRING VECTOR until, but not including, the first string) N
(element beginning with 2 blank, ' ', characters.) N
(cfortran.doc) (Page 21/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
() N
(9. INSTRUCTIONS REQUIRED ONLY FOR FORTRAN COMPILERS WHICH GENERATE) N
(                -------------     ) N
(   ROUTINE NAMES WHICH ARE UNDISTINGUISHABLE FROM C ROUTINE NAMES) N
(   i.e. VAX VMS) N
(        AbsoftUNIXFortran \(AbsoftProFortran ok, since it uses Uppercase names.\)) N
(        HP9000      if not using the +ppu      option of f77) N
(        IBM RS/6000 if not using the -qextname option of xlf) N
(   Call them the same_namespace compilers.) N
() N
(FCALLSCSUBn\(...\) and FCALLSCFUNn\(...\), when compiled, are expanded into) N
('wrapper' functions, so called because they wrap around the original C ) N
(functions and interface the format of the original C functions' arguments and) N
(return values with the format of the FORTRAN call.) N
() N
(Ideally one wants to be able to call the C routine from FORTRAN using the same) N
(name as the original C name. This is not a problem for FORTRAN compilers which) N
(append an underscore, '_', to the names of routines, since the original C) N
(routine has the name 'name', and the FORTRAN wrapper is called 'name_'.) N
(Similarly, if the FORTRAN compiler generates upper case names for routines, the) N
(original C routine 'name' can have a wrapper called 'NAME', [Assuming the C) N
(routine name is not in upper case.] For these compilers, e.g. Mips, CRAY, IBM) N
(RS/6000 'xlf -qextname', HP-UX 'f77 +ppu', the naming of the wrappers is done) N
(automatically.) N
() N
(For same_namespace compilers things are not as simple, but cfortran.h tries to) N
(provide tools and guidelines to minimize the costs involved in meeting their) N
(constraints. The following two options can provide same_namespace compilers) N
(with distinct names for the wrapper and the original C function.) N
() N
(These compilers are flagged by cfortran.h with the CF_SAME_NAMESPACE  constant,) N
(so that the change in the C name occurs only when required.) N
() N
(For the remainder of the discussion, routine names generated by FORTRAN) N
(compilers are referred to in lower case, these names should be read as upper) N
(case for the appropriate compilers.) N
() N
() N
(HP9000: \(When f77 +ppu is not used.\)) N
(f77 has a -U option which forces uppercase external names to be generated.) N
(Unfortunately, cc does not handle recursive macros. Hence, if one wished to use) N
(-U for separate C and FORTRAN namespaces, one would have to adopt a different) N
(convention of naming the macros which allow C to call FORTRAN subroutines.) N
(\(Functions are not a problem.\) The macros are currently the uppercase of the) N
(original FORTRAN name, and would have to be changed to lower case or mixed) N
(case, or to a different name. \(Lower case would of course cause conflicts on) N
(many other machines.\) Therefore, it is suggested that f77 -U  not be used, and) N
(instead that Option a\) or Option b\) outlined below be used.) N
() N
() N
(VAX/VMS:) N
(For the name used by FORTRAN in calling a C routine to be the same as that of) N
(the C routine, the source code of the C routine is required. A preprocessor) N
(directive can then force the C compiler to generate a different name for the C) N
(routine. ) N
(e.g.                #if defined\(vms\)) N
(                    #define name name_) N
(                    #endif) N
(                    void name\(\) {printf\("name: was called.\\n"\);}) N
(                    FCALLSCSUB0\(name,NAME,name\)) N
() N
(cfortran.doc) (Page 22/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (11/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (23-24) 12
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(In the above, the C compiler generates the original routine with the name) p n
('name_' and a wrapper called 'NAME'. This assumes that the name of the routine,) N
(as seen by the C programmer, is not in upper case. The VAX VMS linker is not) N
(case sensitive, allowing cfortran.h to export the upper case name as the) N
(wrapper, which then doesn't conflict with the routine name in C. Since the IBM,) N
(HP and AbsoftUNIXFortran platforms have case sensitive linkers) N
(this technique is not available to them.) N
() N
(The above technique is required even if the C name is in mixed case, see ) N
(Option a\) for the other compilers, but is obviously not required when ) N
(Option b\) is used.) N
() N
() N
(Option a\) Mixed Case names for the C routines to be called by FORTRAN.) N
() N
(If the original C routines have mixed case names, there are no name space) N
(conflicts.) N
() N
(Nevertheless for VAX/VMS, the technique outlined above must also used.) N
() N
() N
(Option b\) Modifying the names of C routines when used by FORTRAN:) N
() N
(The more robust naming mechanism, which guarantees portability to all machines, ) N
('renames' C routines when called by FORTRAN. Indeed, one must change the names) N
(on same_namespace compilers when FORTRAN calls C routines for which the source) N
(is unavailable. [Even when the source is available, renaming may be preferable) N
(to Option a\) for large libraries of C routines.]) N
() N
(Obviously, if done for a single type of machine, it must be done for all) N
(machines since the names of routines used in FORTRAN code cannot be easily) N
(redefined for different machines.) N
() N
(The simplest way to achieve this end is to do explicitly give the modified) N
(FORTRAN name in the FCALLSCSUBn\(...\) and FCALLSCFUNn\(...\) declarations. e.g.) N
() N
(FCALLSCSUB0\(name,CFNAME,cfname\)) N
() N
(This allows FORTRAN to call the C routine 'name' as 'cfname'. Any name can of) N
(course be used for a given routine when it is called from FORTRAN, although) N
(this is discouraged due to the confusion it is sure to cause.  e.g. Bizarre,) N
(but valid and allowing C's 'call_back' routine to be called from FORTRAN as) N
('abcd':) N
() N
(FCALLSCSUB0\(call_back,ABCD,abcd\)) N
() N
() N
(cfortran.h also provides preprocessor directives for a systematic 'renaming' of) N
(the C routines when they are called from FORTRAN. This is done by redefining) N
(the fcallsc macro before the FCALLSCSUB/FUN/n declarations as follows:) N
() N
(#undef  fcallsc) N
(#define fcallsc\(UN,LN\) preface_fcallsc\(CF,cf,UN,LN\)) N
() N
(FCALLSCSUB0\(hello,HELLO,hello\)) N
() N
(Will cause C's routine 'hello' to be known in FORTRAN as 'cfhello'. Similarly) N
(all subsequent FCALLSCSUB/FUN/n declarations will generate wrappers to allow) N
(FORTRAN to call C with the C routine's name prefaced by 'cf'. The following has) N
(the same effect, with subsequent FCALLSCSUB/FUN/n's appending the modifier to) N
(the original C routines name.) N
() N
(cfortran.doc) (Page 23/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#undef  fcallsc) p n
(#define fcallsc\(UN,LN\) append_fcallsc\(Y,y,UN,LN\)) N
() N
(FCALLSCSUB0\(Xroutine,ROUTINE,routine\)) N
() N
(Hence, C's Xroutine is called from FORTRAN as:) N
(       CALL XROUTINEY\(\)) N
() N
(The original behavior of FCALLSCSUB/FUN/n, where FORTRAN routine names are left) N
(identical to those of C, is returned using:) N
() N
(#undef  fcallsc) N
(#define fcallsc\(UN,LN\) orig_fcallsc\(UN,LN\)) N
() N
() N
(In C, when passing a C routine, i.e. its wrapper, as an argument to a FORTRAN) N
(routine, the FORTRAN name declared is used and the correct fcallsc must be in) N
(effect. E.g. Passing 'name' and 'routine' of the above examples to the FORTRAN) N
(routines, FT1 and FT2, respectively:) N
() N
(/* This might not be needed if fcallsc is already orig_fcallsc. */) N
(#undef  fcallsc) N
(#define fcallsc\(UN,LN\) orig_fcallsc\(UN,LN\)) N
(FT1\(C_FUNCTION\(CFNAME,cfname\)\);) N
() N
(#undef  fcallsc) N
(#define fcallsc\(UN,LN\) append_fcallsc\(Y,y,UN,LN\)) N
(FT1\(C_FUNCTION\(XROUTINE,xroutine\)\);) N
() N
(If the names of C routines are modified when used by FORTRAN, fcallsc would) N
(usually be defined once in a header_file.h for the application. This definition) N
(would then be used and be valid for the entire application and fcallsc would at) N
(no point need to be redefined.) N
() N
() N
(ONCE AGAIN: THE DEFINITIONS, INSTRUCTIONS, DECLARATIONS AND DIFFICULTIES) N
(DESCRIBED HERE, NOTE 9. of II ii\), ) N
(APPLY ONLY FOR VAX VMS,) N
(               IBM RS/6000 WITHOUT THE -qextname OPTION FOR xlf, OR) N
(               HP-UX       WITHOUT THE +ppu      OPTION FOR f77) N
(               AbsoftUNIXFortran) N
(AND APPLY ONLY WHEN CREATING WRAPPERS WHICH ENABLE FORTRAN TO CALL C ROUTINES.) N
() N
() N
() N
(iii\) Using C to manipulate FORTRAN COMMON BLOCKS:) N
(     -------------------------------------------------------) N
() N
(FORTRAN common blocks are set up with the following three constructs:) N
() N
(1.) N
(#define Common_block_name COMMON_BLOCK\(COMMON_BLOCK_NAME,common_block_name\)) N
() N
(Common_block_name is in UPPER CASE. ) N
(COMMON_BLOCK_NAME is in UPPER CASE.) N
(common_block_name is in lower case. ) N
([Common_block_name actually follows the same 'rules' as Routine_name in Note 2.) N
( of II i\).] This construct exists to ensure that C code accessing the common) N
(block is machine independent.) N
() N
(2.) N
(COMMON_BLOCK_DEF\(TYPEDEF_OF_STRUCT, Common_block_name\);) N
(cfortran.doc) (Page 24/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (12/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (25-26) 13
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(where ) N
(typedef { ... } TYPEDEF_OF_STRUCT;) N
(declares the structure which maps on to the common block. The #define of) N
(Common_block_name must come before the use of COMMON_BLOCK_DEF.) N
() N
(3.) N
(In exactly one of the C source files, storage should be set aside for the) N
(common block with the definition: ) N
() N
(TYPEDEF_OF_STRUCT  Common_block_name;) N
() N
(The above definition may have to be omitted on some machines for a common block) N
(which is initialized by Fortran BLOCK DATA or is declared with a smaller size) N
(in the C routines than in the Fortran routines.) N
() N
(The rules for common blocks are not well defined when linking/loading a mixture) N
(of C and Fortran, but the following information may help resolve problems.) N
() N
(From the 2nd or ANSI ed. of K&R C, p.31, last paragraph:) N
(i\)) N
( An external variable must be defined, exactly once, outside of any function;) N
( this sets aside storage for it.) N
(ii\)) N
( The variable must also be declared in each function that wants to access it;) N
( ...) N
( The declaration ... may be implicit from context.) N
() N
(In Fortran, every routine says 'common /bar/ foo',) N
(i.e. part ii\) of the above, but there's no part i\) requirement.) N
(cc/ld on some machines don't require i\) either.) N
(Therefore, when handling Fortran, and sometimes C,) N
(the loader/linker must automagically set aside storage for common blocks.) N
() N
(Some loaders, including at least one for the CRAY, turn off the) N
('automagically set aside storage' capability for Fortran common blocks,) N
(if any C object declares that common block.) N
(Therefore, C code should define, i.e. set aside storage,) N
(for the the common block as shown above.) N
() N
(e.g.) N
(C Fortran) N
(      common /fcb/  v,w,x) N
(      character *\(13\) v, w\(4\), x\(3,2\)) N
() N
(/* C */) N
(typedef struct { char v[13],w[4][13],x[2][3][13]; } FCB_DEF;) N
(#define Fcb COMMON_BLOCK\(FCB,fcb\)) N
(COMMON_BLOCK_DEF\(FCB_DEF,Fcb\);) N
(FCB_DEF Fcb;      /* Definition, which sets aside storage for Fcb, */) N
(                  /* may appear in at most one C source file.      */) N
() N
() N
(C programs can place a string \(or a multidimensional array of strings\) into a) N
(FORTRAN common block using the following call:) N
() N
(C2FCBSTR\( CSTR, FSTR,DIMENSIONS\);) N
() N
(where:) N
() N
(CSTR is a pointer to the first element of C's copy of the string \(array\). ) N
(     The C code must use a duplicate of, not the original, common block string,) N
(cfortran.doc) (Page 25/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(     because the FORTRAN common block does not allocate space for C strings') p n
(     terminating '\\0'.) N
() N
(FSTR is a pointer to the first element of the string \(array\) in the common) N
(     block.) N
() N
(DIMENSIONS is the number of dimensions of string array. ) N
(     e.g. char a[10]      has DIMENSIONS=0.) N
(          char aa[10][17] has DIMENSIONS=1.) N
(          etc...) N
() N
(C2FCBSTR will copy the string \(array\) from CSTR to FSTR, padding with blanks, ) N
(' ', the trailing characters as required. C2FCBSTR uses DIMENSIONS and FSTR to) N
(determine the lengths of the individual string elements and the total number of) N
(elements in the string array.) N
() N
(Note that:) N
(- the number of string elements in CSTR and FSTR are identical.) N
(- for arrays of strings, the useful lengths of strings in CSTR and FSTR must be) N
(  the same. i.e. CSTR elements each have 1 extra character to accommodate the) N
(  terminating '\\0'.) N
(- On most non-ANSI compilers, the DIMENSION argument cannot be prepended by any) N
(  blanks.) N
() N
() N
(FCB2CSTR\( FSTR, CSTR,DIMENSIONS\)) N
() N
(is the inverse of C2FCBSTR, and shares the same arguments and caveats.) N
(FCB2CSTR copies each string element of FSTR to CSTR, minus FORTRAN strings') N
(trailing blanks.) N
() N
() N
(cfortran.h USERS ARE STRONGLY URGED TO EXAMINE THE COMMON BLOCK EXAMPLES IN) N
(cfortest.c AND cfortex.f. The use of strings in common blocks is) N
(demonstrated, along with a suggested way for C to imitate FORTRAN EQUIVALENCE'd) N
(variables.) N
() N
() N
(              ===> USERS OF CFORTRAN.H NEED READ NO FURTHER <===) N
() N
() N
(III Some Musings) N
(----------------) N
() N
(cfortran.h is simple enough to be used by the most basic of applications, i.e.) N
(making a single C/FORTRAN routine available to the FORTRAN/C programmers. Yet) N
(cfortran.h is powerful enough to easily make entire C/FORTRAN libraries) N
(available to FORTRAN/C programmers. ) N
() N
() N
(cfortran.h is the ideal tool for FORTRAN libraries which are being \(re\)written) N
(in C, but are to \(continue to\) support FORTRAN users. It allows the routines to) N
(be written in 'natural C', without having to consider the FORTRAN argument) N
(passing mechanisms of any machine. It also allows C code accessing these) N
(rewritten routines, to use the C entry point. Without cfortran.h, one risks the) N
(perverse practice of C code calling a C function using FORTRAN argument passing) N
(mechanisms!) N
() N
() N
(Perhaps the philosophy and mechanisms of cfortran.h could be used and extended) N
(to create other language bridges such as ADAFORTRAN, CPASCAL, COCCAM, etc.) N
() N
(cfortran.doc) (Page 26/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (13/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (27-28) 14
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(The code generation machinery inside cfortran.h, i.e. the global structure is) N
(quite good, being clean and workable as seen by its ability to meet the needs) N
(and constraints of many different compilers. Though the individual instructions) N
(of the A..., C..., T..., R... and K... tables deserve to be cleaned up.) N
() N
() N
() N
(IV  Getting Serious with cfortran.h) N
(-----------------------------------) N
() N
(cfortran.h is set up to be as simple as possible for the casual user. While) N
(this ease of use will always be present, 'hooks', i.e. preprocessor directives,) N
(are required in cfortran.h so that some of the following 'inefficiencies' can) N
(be eliminated if they cause difficulties:) N
() N
(o cfortran.h contains a few small routines for string manipulation. These) N
(routines are declared static and are included and compiled in all source code) N
(which uses cfortran.h. Hooks should be provided in cfortran.h to create an) N
(object file of these routines, allowing cfortran.h to merely prototypes) N
(these routines in the application source code. This is the only 'problem' which) N
(afflicts both halves of cfortran.h. The remaining discussion refers to the C) N
(calls FORTRAN half only.) N
() N
(o Similar to the above routines, cfortran.h generates code for a 'wrapper') N
(routine for each FUNCTION exported from FORTRAN. Again cfortran.h needs) N
(preprocessor directives to create a single object file of these routines,) N
(and to merely prototype them in the applications.) N
() N
(o Libraries often contain hundreds of routines. While the preprocessor makes) N
(quick work of generating the required interface code from cfortran.h and the) N
(application.h's, it may be convenient for very large stable libraries to have) N
(final_application.h's which already contain the interface code, i.e. these) N
(final_application.h's would not require cfortran.h. [The convenience can be) N
(imagined for the VAX VMS CC compiler which has a fixed amount of memory for) N
(preprocessor directives. Not requiring cfortran.h, with its hundreds of) N
(directives, could help prevent this compiler from choking on its internal) N
(limits quite so often.]) N
() N
(With a similar goal in mind, cfortran.h defines 100's of preprocessor) N
(directives. There is always the potential that these will clash with other tags) N
(in the users code, so final_applications.h, which don't require cfortran.h,) N
(also provide the solution.) N
() N
(In the same vein, routines with more than 14 arguments can not be interfaced by) N
(cfortran.h with compilers which limit C macros to 31 arguments. To resolve this) N
(difficulty, final_application.h's can be created on a compiler without this) N
(limitation.) N
() N
(Therefore, new machinery is required to do:) N
() N
(application.h + cfortran.h => final_application.h) N
() N
(The following example may help clarify the means and ends:) N
() N
(If the following definition of the HBOOK1 routine, the /*commented_out_part*/,) N
(is passed through the preprocessor [perhaps #undefing and #defining preprocessor) N
(constants if creating an application.h for compiler other than that of the) N
(preprocessor being used, e.g. cpp -Umips -DCRAY ... ] :) N
() N
(#include "cfortran.h") N
(PROTOCCALLSFSUB6\(HBOOK1,hbook1,INT,STRING,INT,FLOAT,FLOAT,FLOAT\)) N
(cfortran.doc) (Page 27/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/*#define HBOOK1\(ID,CHTITLE,NX,XMI,XMA,VMX\)                 \\*/) p n
(     CCALLSFSUB6\(HBOOK1,hbook1,INT,STRING,INT,FLOAT,FLOAT,FLOAT, \\) N
(                 ID,CHTITLE,NX,XMI,XMA,VMX\) ) N
() N
(A function prototype is produced by the PROTOCCALLSFSUB6\(...\).) N
(Interface code is produced, based on the 'variables', ) N
(ID,CHTITLE,NX,XMI,XMA,VMX, which will correctly massage a HBOOK1 call.) N
(Therefore, adding the #define line:) N
() N
('prototype code') N
(#define HBOOK1\(ID,CHTITLE,NX,XMI,XMA,VMX\)                 \\) N
( 'interface code'\(ID,CHTITLE,NX,XMI,XMA,VMX\)) N
() N
(which is placed into final_application.h.) N
() N
(The only known limitation of the above method does not allow the 'variable') N
(names to include B1,B2,...,B9,BA,BB,... ) N
() N
(Obviously the machinery to automatically generate final_applications.h from) N
(cfortran.h and applications.h needs more than just some preprocessor) N
(directives, but a fairly simple unix shell script should be sufficient. Any) N
(takers?) N
() N
() N
() N
(V Machine Dependencies of cfortran.h) N
(------------------------------------) N
() N
(Porting cfortran.h applications, e.g. the hbook.h and cstring.c mentioned) N
(above, to other machines is trivial since they are machine independent. Porting) N
(cfortran.h requires a solid knowledge of the new machines C preprocessor, and) N
(its FORTRAN argument passing mechanisms. Logically cfortran.h exists as two) N
(halves, a "C CALLS FORTRAN" and a "FORTRAN CALLS C" utility. In some cases it) N
(may be perfectly reasonable to port only 'one half' of cfortran.h onto a new) N
(system.) N
() N
() N
(The lucky programmer porting cfortran.h to a new machine, must discover the) N
(FORTRAN argument passing mechanisms. A safe starting point is to assume that) N
(variables and arrays are simply passed by reference, but nothing is guaranteed.) N
(Strings, and n-dimensional arrays of strings are a different story. It is) N
(doubtful that any systems do it quite like VAX VMS does it, so that a UNIX or) N
(f2c versions may provide an easier starting point.) N
() N
() N
(cfortran.h uses and abuses the preprocessor's ## operator. Although the ##) N
(operator does not exist in many compilers, many kludges do. cfortran.h uses) N
(/**/ with no space allowed between the slashes, '/', and the macros or tags) N
(to be concatenated. e.g.) N
(#define concat\(a,b\) a/**/b   /* works*/) N
(main\(\)) N
({) N
(  concat\(pri,ntf\)\("hello"\);           /* e.g. */) N
(}) N
(N.B. On some compilers without ##, /**/ may also not work. The author may be) N
(able to offer alternate kludges.) N
() N
() N
() N
(VI Bugs in vendors C compilers and other curiosities) N
(----------------------------------------------------) N
() N
(cfortran.doc) (Page 28/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (14/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (29-30) 15
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(1. ULTRIX xxxxxx 4.3 1 RISC) p n
() N
(Condolences to long suffering ultrix users!) N
(DEC supplies a working C front end for alpha/OSF, but not for ultrix.) N
() N
(From K&R ANSI C p. 231:) N
(   ultrix> cat cat.c) N
(   #define cat\(x, y\) x ## y) N
(   #define xcat\(x,y\) cat\(x,y\)) N
(   cat\(cat\(1,2\),3\)) N
(   xcat\(xcat\(1,2\),3\)) N
(   ultrix> cc -E cat.c) N
(   123                  <---- Should be: cat\(1,2\)3) N
(   123                  <---- Correct.) N
(   ultrix> ) N
() N
(The problem for cfortran.h, preventing use of -std and -std1:) N
(   ultrix> cat c.c) N
(   #define cat\(x, y\) x ## y) N
(   #define xcat\(x,y\) cat\(x,y\)) N
(   #define AB\(X\) X+X) N
(   #define C\(E,F,G\)  cat\(E,F\)\(G\)) N
(   #define X\(E,F,G\) xcat\(E,F\)\(G\)) N
(   C\(A,B,2\)) N
(   X\(A,B,2\)) N
(   ultrix> cc -std1 -E c.c) N
(   2+2  ) N
(   AB  \(2\)              <---- ?????????????) N
(   ultrix>) N
(   ultrix> cc -std0 -E c.c) N
(   2+2  ) N
(   AB\(2\)                <---- ?????????????) N
(   ultrix>) N
() N
(Due to further ultrix preprocessor problems,) N
(for all definitions of definitions with arguments,) N
(cfortran.h >= 3.0 includes the arguments and recommends the same,) N
(even though it is not required by ANSI C.) N
(e.g. Users are advised to do) N
(   #define fcallsc\(UN,LN\) orig_fcallsc\(UN,LN\)) N
(instead of) N
(   #define fcallsc        orig_fcallsc) N
(since ultrix fails to properly preprocess the latter example.) N
(CRAY used to \(still does?\) occasionally trip up on this problem.) N
() N
() N
(2. ConvexOS convex C210 11.0 convex) N
() N
(In a program with a C main, output to LUN=6=* from Fortran goes into) N
($pwd/fort.6 instead of stdout. Presumably, a magic incantation can be called) N
(from the C main in order to properly initialize the Fortran I/O.) N
() N
() N
(3. SunOS 5.3 Generic_101318-69 sun4m sparc) N
() N
(The default data and code alignments produced by cc, gcc and f77 are compatible.) N
(If deviating from the defaults, consistent alignment options must be used) N
(across all objects compiled by cc and f77. [Does gcc provide such options?]) N
() N
() N
(4. SunOS 5.3 Generic_101318-69 sun4m sparc with cc: SC3.0.1 13 Jul 1994) N
(   or equivalently) N
(cfortran.doc) (Page 29/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   ULTRIX 4.4 0 RISC using cc -oldc) p n
(   are K&R C preprocessors that suffer from infinite loop macros, e.g.) N
() N
(  zedy03> cat src.c) N
(  #include "cfortran.h") N
(                            PROTOCCALLSFFUN1\(INT,FREV,frev, INTV\)) N
(  #define FREV\(A1\)               CCALLSFFUN1\(    FREV,frev, INTV, A1\)) N
(  /* To avoid the problem, deletete these ---^^^^--- spaces.    */) N
(  main\(\) { static int a[] = {1,2}; FREV\(a\); return EXIT_SUCCESS; }) N
() N
(  zedy03> cc -c -Xs -v -DMAX_PREPRO_ARGS=31 -D__CF__KnR src.c) N
(  "src.c", line 4: FREV: actuals too long) N
(  "src.c", line 4: FREV: actuals too long) N
(  .... 3427 more lines of the same message) N
(  "src.c", line 4: FREV: actuals too long) N
(  cc : Fatal error in /usr/ccs/lib/cpp) N
(  Segmentation fault \(core dumped\) ) N
() N
() N
(5. Older sun C compilers) N
() N
(To link to f77 objects, older sun C compilers require the math.h macros:) N
() N
(#define RETURNFLOAT\(x\)   { union {double _d; float _f; } _kluge; \\) N
(                           _kluge._f = \(x\); return _kluge._d;   }) N
(#define ASSIGNFLOAT\(x,y\) { union {double _d; float _f; } _kluge; \\) N
(                           _kluge._d = \(y\); x = _kluge._f;      }) N
() N
(Unfortunately, in at least some copies of the sun math.h, the semi-colon) N
(for 'float _f;' is left out, leading to compiler warnings.) N
() N
(The solution is to correct math.h, or to change cfortran.h to #define ) N
(RETURNFLOAT\(x\) and ASSIGNFLOAT\(x,y\) instead of including math.h.) N
() N
() N
(6. gcc version 2.6.3 and probably all other versions as well) N
() N
(Unlike all other C compilers supported by cfortran.h,) N
('gcc -traditional' promotes to double all functions returning float) N
(as demonstrated bu the following example.) N
() N
(/* m.c */) N
(#include <stdio.h>) N
(int main\(\) { FLOAT_FUNCTION d\(\); float f; f = d\(\); printf\("%f\\n",f\); return 0; }) N
() N
(/* d.c */) N
(float d\(\) { return -123.124; }) N
() N
(burow[29] gcc -c -traditional d.c) N
(burow[30] gcc -DFLOAT_FUNCTION=float m.c d.o && a.out) N
(0.000000) N
(burow[31] gcc -DFLOAT_FUNCTION=double m.c d.o && a.out) N
(-123.124001) N
(burow[32]) N
() N
(Thus, 'gcc -traditional' is not supported by cfortran.h.) N
(Support would require the same RETURNFLOAT, etc. macro machinery) N
(present in old sun math.h, before sun gave up the same promotion.) N
() N
() N
(7. CRAY) N
() N
(cfortran.doc) (Page 30/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (15/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (31-32) 16
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(At least some versions of the t3e and t3d C preprocessor are broken) p n
(in the fashion described below.) N
(At least some versions of the t90 C preprocessor do not have this problem.) N
() N
(On the CRAY, all Fortran names are converted to uppercase.) N
(Generally the uppercase name is also used for the macro interface) N
(created by cfortran.h.) N
() N
(For example, in the following interface,) N
(EASY is both the name of the macro in the original C code) N
(and EASY is the name of the resulting function to be called.) N
() N
(#define EASY\(A,B\)      CCALLSFSUB2\(EASY,easy, PINT, INTV, A, B\)) N
() N
(The fact that a macro called EASY\(\) expands to a function called EASY\(\)) N
(is not a problem for a working C preprocessor.) N
(From Kernighan and Ritchie, 2nd edition, p.230:) N
() N
(    In both kinds of macro, the replacement token sequence is repeatedly) N
(  rescanned for more identifiers. However, once a given identifier has been) N
(  replaced in a given expansion, it is not replaced if it turns up again during) N
(  rescanning; instead it is left unchanged.) N
() N
(Unfortunately, some CRAY preprocessors are broken and don't obey the above rule.) N
(A work-around is for the user to NOT use the uppercase name) N
(of the name of the macro interface provided by cfortran.h. For example:) N
() N
(#define Easy\(A,B\)      CCALLSFSUB2\(EASY,easy, PINT, INTV, A, B\)) N
() N
(Luckily, the above work-around is not required since the following) N
(work-around within cfortran.h also circumvents the bug:) N
() N
(   /* \(UN\), not UN, is required in order to get around  CRAY preprocessor bug.*/) N
(   #define CFC_\(UN,LN\)            \(UN\)      /* Uppercase FORTRAN symbols.     */) N
() N
(Aside: The Visual C++ compiler is happy with UN, but barfs on \(UN\),) N
(       so either \(UN\) causes nonstandard C/C++ or Visual C++ is broken.) N
() N
() N
(VII History and Acknowledgements) N
(--------------------------------) N
() N
(1.0 - Supports VAX VMS using C 3.1 and FORTRAN 5.4.                    Oct. '90.) N
(1.0 - Supports Silicon Graphics w. Mips Computer 2.0 f77 and cc.       Feb. '91.) N
(          [Port of C calls FORTRAN half only.]) N
(1.1 - Supports Mips Computer System 2.0 f77 and cc.                    Mar. '91.) N
(          [Runs on at least: Silicon Graphics IRIX 3.3.1) N
(                             DECstations with Ultrix V4.1]) N
(1.2 - Internals made simpler, smaller, faster, stronger.               May  '91.) N
(    - Mips version works on IBM RS/6000, this is now called the unix version.) N
(1.3 - UNIX and VAX VMS versions are merged into a single cfortran.h.   July '91.) N
(    - C can help manipulate \(arrays of\) strings in FORTRAN common blocks.) N
(    - Dimensions of string arrays arguments can be explicit.) N
(    - Supports Apollo DomainOS 10.2 \(sys5.3\) with f77 10.7 and cc 6.7.) N
() N
(2.0 - Improved code generation machinery creates K&R or ANSI C.        Aug. '91.) N
(    - Supports Sun, CRAY. f2c with vcc on VAX Ultrix.) N
(    - cfortran.h macros now require routine and COMMON block names in both ) N
(      upper and lower case. No changes required to applications though.) N
(    - PROTOCCALLSFSUBn is eliminated, with no loss to cfortran.h performance.) N
(    - Improved tools and guidelines for naming C routines called by FORTRAN.) N
(2.1 - LOGICAL correctly supported across all machines.                 Oct. '91.) N
(cfortran.doc) (Page 31/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    - Improved support for DOUBLE PRECISION on the CRAY.) p n
(    - HP9000 fully supported.) N
(    - VAX Ultrix cc or gcc with f77 now supported.) N
(2.2 - SHORT, i.e. INTEGER*2, and BYTE now supported.                   Dec. '91.) N
(    - LOGICAL_STRICT introduced. More compact and robust internal tables.) N
(    - typeV and typeVV for type = BYTE, DOUBLE, FLOAT, INT, LOGICAL, LONG,SHORT.) N
(    - FORTRAN passing strings and NULL pointer to C routines improved. ) N
(2.3 - Extraneous arguments removed from many internal tables.          May  '92.) N
(    - Introduce pseudo argument type SIMPLE for user defined types.) N
(    - LynxOS using f2c supported. \(Tested with LynxOS 2.0 386/AT.\)) N
(2.4 - Separation of internal C and Fortran compilation directives.     Oct. '92.) N
(    - f2c and NAG f90 supported on all machines.) N
(2.5 - Minor mod.s to source and/or doc for HP9000, f2c, and NAG f90.   Nov. '92.) N
(2.6 - Support external procedures as arguments with type ROUTINE.      Dec. '92.) N
(2.7 - Support Alpha VMS. Support HP9000 f77 +ppu                       Jan. '93.) N
(    - Support arrays with up to 7 dimensions.) N
(    - Minor mod. of Fortran NULL to C via \(P\)STRING.) N
(    - Specify the type of ROUTINE passed from Fortran to C [ANSI C requirement.]) N
(    - Macros never receive a null parameter [RS/6000 requirement.]) N
(2.8 - PSTRING for Fortran calls C no longer provides escape to pass    April'93.) N
(      NULL pointer nor to pass address of original string.) N
(      PNSTRING introduced with old PSTRING's behavior.) N
(      PPSTRING introduced to always pass original address of string.) N
(    - Support Alpha/OSF.) N
(    - Document that common blocks used in C should be declared AND defined.) N
() N
(3.0 - Automagic handling of ANSI ## versus K&R /**/ preprocessor op.   March'95.) N
(    - Less chance of name space collisions between cfortran.h and other codes.) N
(    - SIMPLE macros, supporting user defined types, have changed names.) N
(3.1 - Internal macro name _INT not used. Conflicted with IRIX 5.3.     May  '95.) N
(    - SunOS, all versions, should work out of the box.) N
(    - ZTRINGV_ARGS|F\(k\) may no longer point to a PDOUBLE or PFLOAT argument.) N
(    - ConvexOS 11.0 supported.) N
(3.2 - __hpux no longer needs to be restricted to MAX_PREPRO_ARGS=31.   Oct. '95.) N
(    - PSTRING bug fixed.) N
(    - ZTRINGV_ARGS|F\(k\) may not point to a PBYTE,PINT,PLONG or PSHORT argument.) N
(    - \(P\)ZTRINGV machinery improved. Should lead to fewer compiler warnings.) N
(      \(P\)ZTRINGV no longer limits recursion or the nesting of routines.) N
(    - SIMPLE macros, supporting user defined types, have changed slightly.) N
(3.3 - Supports PowerStation Fortran with Visual C++.                   Nov. '95.) N
(    - g77 should work using f2cFortran, though no changes made for it.) N
(    - \(PROTO\)CCALLSFFUN10 extended to \(PROTO\)CCALLSFFUN14.) N
(    - FCALLSCFUN10 and SUB10 extended to FCALLSCFUN14 and SUB14.) N
(3.4 - C++ supported,                                                   Dec. '95.) N
(      but it required the reintroduction of PROTOCCALLSFSUBn for users.) N
(    - HP-UX f77 +800 supported.) N
(3.5 - Absoft UNIX Fortran supported.                                   Sept.'96.) N
(3.6 - Minor corrections to cfortran.doc.                               Oct. '96.) N
(    - Fixed bug for 15th argument. [Thanks to Tom Epperly at Aspen Tech.]) N
(    - For AbsoftUNIXFortran, obey default of prepending _C to COMMON BLOCK name.) N
(    - Fortran calling C with ROUTINE argument fixed and cleaned up.) N
(3.7 - Circumvent IBM and HP "null argument" preprocessor warning.      Oct. '96) N
(3.8 - \(P\)STRINGV and \(P\)ZTRINGV can pass a 1- or 2-dim. char array.    Feb. '97) N
(      \(P\)ZTRINGV thus effectively also provides \(P\)ZTRING.) N
(    - \(P\)ZTRINGV accepts a \(char *\) pointer.) N
(3.9 - Bug fixed for *VVVVV.                                            May  '97) N
(    - f2c: Work-around for strange underscore-dependent naming feature.) N
(    - NEC SX-4 supported.) N
(    - CRAY: LOGICAL conversion uses _btol and _ltob from CRAY's fortran.h.) N
(    - CRAY: Avoid bug of some versions of the C preprocessor.) N
(    - CRAY T3E: FORTRAN_REAL introduced.) N
() N
(cfortran.doc) (Page 32/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (16/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (33-34) 17
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(4.0 - new/delete now used for C++. malloc/free still used for C.       Jan. '98) p n
(    - FALSE no longer is defined by cfortran.h .) N
(    - Absoft Pro Fortran for MacOS supported.) N
(4.1 - COMMA and COLON no longer are defined by cfortran.h .            April'98) N
(    - Bug fixed when 10th arg. or beyond is a string.) N
(      [Rob Lucchesi of NASA-Goddard pointed out this bug.]) N
(    - CCALLSFSUB/FUN extended from 14 to 27 arguments.) N
(    - Workaround SunOS CC 4.2 cast bug. [Thanks to Savrak SAR of CERN.]) N
(4.2 - Portland Group needs -DpgiFortran . [Thank George Lai of NASA.]  June '98) N
(4.3 - \(PROTO\)CCALLSFSUB extended from 20 to 27 arguments.              July '98) N
() N
() N
(['Support' implies these and more recent releases of the respective) N
( OS/compilers/linkers can be used with cfortran.h. ) N
( Earlier releases may also work.]) N
() N
() N
(Acknowledgements:) N
(- CERN very generously sponsored a week in 1994 for me to work on cfortran.h.) N
(- M.L.Luvisetto \(Istituto Nazionale Fisica Nucleare - Centro Nazionale) N
(  Analisi Fotogrammi, Bologna, Italy\) provided all the support for the port to) N
(  the CRAY. Marisa's encouragement and enthusiasm was also much appreciated.) N
(- J.Bunn \(CERN\) supported the port to PowerStation Fortran with Visual C++.) N
(- Paul Schenk \(UC Riverside, CERN PPE/OPAL\) in June 1993 extended cfortran.h 2.7) N
(  to have C++ call Fortran. This was the starting point for full C++ in 3.4.) N
(- Glenn P.Davis of University Corp. for Atmospheric Research \(UCAR\) / Unidata) N
(  supported the NEC SX-4 port and helped understand the CRAY.) N
(- Tony Goelz of Absoft Corporation ported cfortran.h to Absoft.) N
(- Though cfortran.h has been created in my 'copious' free time, I thank ) N
(  NSERC for their generous support of my grad. student and postdoc years.) N
(- Univ.Toronto, DESY, CERN and others have provided time on their computers.) N
() N
() N
(THIS PACKAGE, I.E. CFORTRAN.H, THIS DOCUMENT, AND THE CFORTRAN.H EXAMPLE) N
(PROGRAMS ARE PROPERTY OF THE AUTHOR WHO RESERVES ALL RIGHTS. THIS PACKAGE AND) N
(THE CODE IT PRODUCES MAY BE FREELY DISTRIBUTED WITHOUT FEES, SUBJECT TO THE) N
(FOLLOWING RESTRICTIONS:) N
(- YOU MUST ACCOMPANY ANY COPIES OR DISTRIBUTION WITH THIS \(UNALTERED\) NOTICE.) N
(- YOU MAY NOT RECEIVE MONEY FOR THE DISTRIBUTION OR FOR ITS MEDIA ) N
(  \(E.G. TAPE, DISK, COMPUTER, PAPER.\)) N
(- YOU MAY NOT PREVENT OTHERS FROM COPYING IT FREELY.) N
(- YOU MAY NOT DISTRIBUTE MODIFIED VERSIONS WITHOUT CLEARLY DOCUMENTING YOUR) N
(  CHANGES AND NOTIFYING THE AUTHOR.) N
(- YOU MAY NOT MISREPRESENTED THE ORIGIN OF THIS SOFTWARE, EITHER BY EXPLICIT) N
(  CLAIM OR BY OMISSION.) N
() N
(THE INTENT OF THE ABOVE TERMS IS TO ENSURE THAT THE CFORTRAN.H PACKAGE NOT BE) N
(USED FOR PROFIT MAKING ACTIVITIES UNLESS SOME ROYALTY ARRANGEMENT IS ENTERED) N
(INTO WITH ITS AUTHOR.) N
(              ) N
(THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER) N
(EXPRESSED OR IMPLIED. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE) N
(SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST) N
(OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. THE AUTHOR IS NOT RESPONSIBLE) N
(FOR ANY SUPPORT OR SERVICE OF THE CFORTRAN.H PACKAGE.) N
() N
(                                              Burkhard Burow ) N
(                                              burow@desy.de) N
() N
(P.S. Your comments and questions are welcomed and usually promptly answered.) N
() N
(VAX VMS and Ultrix, Alpha, OSF, Silicon Graphics \(SGI\), DECstation, Mips RISC,) N
(cfortran.doc) (Page 33/34) (Nov 25, 02 18:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(Sun, CRAY, Convex, IBM RS/6000, Apollo DomainOS, HP, LynxOS, f2c, NAG, Absoft,) p n
(NEC SX-4, PowerStation and Visual C++ are registered trademarks of their) N
(respective owners.) N
(        ) N
(/* end: cfortran.doc */) N
(cfortran.doc) (Page 34/34) (Nov 25, 02 18:29) title
border
grestore
(Printed by Jorge Suit Perez Ronda) rhead
(cfortran.doc) (17/17) (Monday November 25, 2002) footer
end % of iso1dict
pagesave restore
showpage

%%Trailer
end
%%EOF

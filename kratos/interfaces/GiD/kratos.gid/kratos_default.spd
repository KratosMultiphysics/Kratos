<?xml version="1.0" encoding="utf-8"?><!-- -*- coding: utf-8; mode: SGML -*- -->
<Kratos_data version='5.0'> 
  <groups/>
  <units>
  </units>
  <!-- Fill this fields to automatically active an App without the init window -->
  <hiddenfield n="activeapp" active="0" v="" state="disabled"/>
  <value n="nDim" pn="Dimension" un="nDim" v="undefined" state="disabled" values="undefined,2D,2Da,3D" dict="undefined,Undefined,2D,2D,2Da,2D axisymmetric,3D,3D"/>
  
  <appLink n="Structural" pn="Structural" active="0" appid="Structural" prefix="ST" release="1"/>
  <appLink n="Solid" pn="Solid" active="0" appid="Solid" prefix="SL"/>
  <appLink n="Fluid" pn="Fluid" active="0" appid="Fluid" prefix="FL"  release="1"/>
  <appLink n="Pfem" pn="Pfem" active="0" appid="Pfem" prefix="PFEM_"/>
  <blockdata n="units" pn="Units" icon="units">
    <value n='units_mesh' pn='Mesh units' unit_mesh_definition="1"/>
    <value n='units_system' pn='Units system' units_system_definition="1">
      <dependencies node="//*[@unit_definition or @unit_mesh_definition='1']" att1='change_units_system' v1='{@v}'/> 
    </value>      
    <container n="basic_units" pn="Basic units" icon="units" help="Basic units to be used in the analysis.">
      <value n='units_length' pn='Length' unit_definition="L"/>     
      <value n='units_mass' pn='Mass' unit_definition="M"/>          
    </container>
  </blockdata>     
  <procs>
	<proc n='GetElements' args='args'>
	  <![CDATA[
	  return [spdAux::ProcGetElements $domNode $args]
	  ]]>
	</proc>
	
	<proc n='GetSolutionStrategies' args='args'>
	  <![CDATA[
	  return [spdAux::ProcGetSolutionStrategies $domNode $args]
	  ]]>
	</proc>
	    <proc n='GetSchemes' args='args'>
	  <![CDATA[
		return [spdAux::ProcGetSchemes $domNode $args]
	  ]]>
	</proc>
		
	<proc n='GetConstitutiveLaws' args='args'>
	  <![CDATA[
	  return [spdAux::ProcGetConstitutiveLaws $domNode $args]
	  ]]>
	</proc>
		<proc n='GetSolvers' args='args'>
	  <![CDATA[
	return [spdAux::ProcGetSolvers $domNode $args]
	  ]]>
	</proc>
	  <proc n='CheckNodalConditionState' args='args'>
	  <![CDATA[
		return [spdAux::ProcCheckNodalConditionState $domNode $args]
	  ]]>
	</proc>
	  <proc n='CheckNodalConditionOutputState' args='args'>
	  <![CDATA[
		return [spdAux::ProcCheckNodalConditionOutputState $domNode $args]
	  ]]>
	</proc>
	  <proc n='RefreshTree' args='args'>
	  <![CDATA[
		spdAux::RequestRefresh
	  ]]>
	</proc>

	  <proc n='checkStateByUniqueName' args='args'>
	  <![CDATA[
		return [spdAux::ProccheckStateByUniqueName $domNode $args]
	  ]]>
	</proc>
	  	  <proc n='SolverParamState' args='args'>
	  <![CDATA[
		return [spdAux::ProcSolverParamState $domNode $args]
	  ]]>
	</proc>
	<proc n='PartParamValue' args='args'>
	  <![CDATA[
		return [spdAux::ProcPartParamValue $domNode $args]
	  ]]>
	</proc>
	  <proc n='PartParamState' args='args'>
	  <![CDATA[
		return [spdAux::ProcPartParamState $domNode $args]
	  ]]>
	</proc>
	  	  <proc n='SolverEntryState' args='args'>
	  <![CDATA[
		return [spdAux::ProcSolverEntryState $domNode $args]
	  ]]>
	</proc>
	<proc n='CheckDimension' args='args'>
	  <![CDATA[
		return [spdAux::ProcCheckDimension $domNode $args]
	  ]]>
	  
	</proc>
	<proc n='getStateFromXPathValue' args='args'>
	  <![CDATA[
	  return [spdAux::ProcgetStateFromXPathValue $domNode $args]
	  ]]>
	</proc>
    <proc n='give_materials_list' args='args'>
      <![CDATA[
      set optional {
      { -has_container container_name "" }
      { -icon icon_name material16 }
      { -types_icon types_icon_name ""}
      { -database database_name materials }
      }        
      
      set compulsory ""
      parse_args $optional $compulsory $args      
      set restList ""    
      
      proc database_append_list { parentNode database_name level container_name icon_name types_icon_name } {
      set l ""       
      # We guess the keywords of the levels of the database        
      set level_names [give_levels_name $parentNode $database_name]
      set primary_level [lindex $level_names 0]
      set secondary_level [lindex $level_names 1]
      
      if {$secondary_level eq "" && $container_name ne "" && $level == "0"} {
      error [_ "The has_container flag is not available for the database %s (the different types of materials \
      should be distributed in several containers)" $database_name]     
      }
      
      foreach domNode [$parentNode childNodes] {
      set name [$domNode @pn ""]
      if { $name eq "" } { set name [$domNode @name] }
      if { [$domNode @n] eq "$secondary_level" } {
      set ret [database_append_list $domNode  $database_name \
      [expr {$level+1}] $container_name $icon_name $types_icon_name]
      if { [llength $ret] } {
      lappend l [list $level $name $name $types_icon_name 0]
      eval lappend l $ret
      }
      } elseif {[$domNode @n] eq "$primary_level"} {
      set good 1
      if { $container_name ne "" } {
      set xp [format_xpath {container[@n=%s]} $container_name]
      if { [$domNode selectNodes $xp] eq "" } { set good 0 }
      }
      if { $good } {
      lappend l [list $level $name $name $icon_name 1]
      }
      }
      }
      return $l
      }  
      
      proc give_caption_name { domNode xp database_name } {     
      set first_time 1   
      foreach gNode [$domNode selectNodes $xp] {        
      if {$first_time} {
      set caption_name [$gNode @n]
      set first_time 0 
      continue  
      }
      if {[$gNode @n] ne $caption_name} {
      error [_ "Please check the n attributes of the database %s" $database_name]   
      }     
      }  
      return $caption_name   
      }
      
      proc give_levels_name { domNode name } {
      set xp {container}      
      if {[$domNode selectNodes $xp] eq ""} { 
      # No seconday level exists
      set secondary_level ""
      set xp2 {blockdata}  
      set primary_level [give_caption_name $domNode $xp2 $name]
      } else {
      set secondary_level [give_caption_name $domNode $xp $name]
      set xp3 {container/blockdata}
      set primary_level [give_caption_name $domNode $xp3 $name] 
      }
      return [list $primary_level $secondary_level]
      } 
      
      set parentNode [$domNode selectNodes [format_xpath {//container[@n=%s]} $database]]
      
      if {$parentNode eq ""} {
      error [_ "Database %s not found in the spd file" $database]  
      }
      
      eval lappend resList [database_append_list $parentNode \
      $database 0 $has_container $icon $types_icon]
      return [join $resList ","]
      ]]>
    </proc>
    <proc n='edit_database_list' args='args'>
      <![CDATA[      
      set optional {
      { -has_container container_name "" }
      { -database database_name materials }
      }
      set compulsory ""
      parse_args $optional $compulsory $args  
      
      set node [$domNode selectNodes {/*/translations/translation[@pn="User defined"]}]
      set title [get_domnode_attribute $node pn]  
      
      set list_name [$domNode @n]
      
      set xp [format_xpath {//container[@n=%s]} $database] 
      if {[$domNode selectNodes $xp] eq ""} {
      error [_ "Database %s not found in the spd file" $database] 
      }   
      
      set xps $xp
      set level_names [give_levels_name [$domNode selectNodes $xp] $database] 
      
      set primary_level [lindex $level_names 0] 
      set secondary_level [lindex $level_names 1] 
      
      
      if {$secondary_level eq "" && $has_container ne ""} {
      error [_ "The has_container flag is not available for the database %s (the different types of materials \
      should be distributed in several containers)" $database]     
      }
      
      if {$secondary_level ne ""} {
      if {$has_container eq ""} {
      append xp [format_xpath {/container[@n=%s]} $secondary_level]
      } else {
      append xp [format_xpath {/container[@n=%s and .//container[@n=%s]]} $secondary_level $has_container]      
      }
      }       
      
      if { [dict exists $dict $list_name] } {
      if {$secondary_level ne ""} {      
      append xps [format_xpath {/container[@n=%s]} $secondary_level]
      }
      append xps [format_xpath {/blockdata[@n=%s and @name=%s]} $primary_level [dict get $dict $list_name]]     
      } else { set xps "" }      
      
      set domNodes [gid_groups_conds::edit_tree_parts_window \
      -accepted_n $primary_level -select_only_one 1 \
      $boundary_conds $title $xp $xps]      
      
      set dict ""
      if { [llength $domNodes] } {
      set domNode [lindex $domNodes 0]
      if { [$domNode @n] eq $primary_level } {      
      dict set dict $list_name [$domNode @name]
      }
      }
      return [list $dict ""]      
      ]]>
    </proc>
	<proc n='ConditionState' args='args'>
	  <![CDATA[
		return [spdAux::ProcConditionState $domNode $args]
	  ]]>
	</proc>
	
	  <proc n='SolStratParamState' args='args'>
	  <![CDATA[
		return [spdAux::ProcSolStratParamState $domNode $args]
	  ]]>
	</proc>
	  <proc n='SchemeParamState' args='args'>
	  <![CDATA[
		return [spdAux::ProcSchemeParamState $domNode $args]
	  ]]>
	</proc>	   
	  <proc n='ConstLawOutputState' args='args'>
	  <![CDATA[
		return [spdAux::ProcConstLawOutputState $domNode $args]
	  ]]>
	</proc>
	  <proc n='ElementOutputState' args='args'>
	  <![CDATA[
		return [spdAux::ProcElementOutputState $domNode $args]
	  ]]>
	</proc>
	  
	  <proc n='ActiveIfAnyPartState' args='args'>
	  <![CDATA[
	  return [spdAux::ProcActiveIfAnyPartState $domNode $args]
	  ]]>
	</proc>
	  
		  <proc n='DisableIfUniqueName' args='args'>
	  <![CDATA[
		return [spdAux::ProcDisableIfUniqueName $domNode $args]
	  ]]>
	</proc>
		<proc n='CheckGeometry' args='args'>
	  <![CDATA[
		return [spdAux::ProcCheckGeometry $domNode $args]
	  ]]>
	</proc>
	  <proc n='Updateme' args='args'>
	  <![CDATA[
	  gid_groups_conds::actualize_conditions_window
	  ]]>
	</proc>
	  <proc n='DirectorVectorNonZero' args='args'>
	  <![CDATA[
	 return [spdAux::ProcDirectorVectorNonZero $domNode $args]
	  ]]>
	</proc>
	  <proc n='ShowInMode' args='args'>
	  <![CDATA[
	  return [spdAux::ProcShowInMode $domNode $args]
	  ]]>
	</proc>
	<dynamicnode command="injectProcs" args=""/>
  </procs>
  <translations>
    <translation pn="User defined"/>
  </translations>
  <display_options frame_width="186"/>
  <blockdata n="Internal data" state="hidden">
    <value n="lognoter_file" v=""/>
  </blockdata>  
</Kratos_data>
